{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to PyCloudSim Docs","text":"<p>PyCloudSim is a simulation toolkit written in python to simulate cloud computing with incorporation of Network Service and Service Funtion Chain. It is based a light-weighted discrete event simulation library Akatosh. PyCloudSim is inspired by CloudSim and CloudSim Plus. However, PyCloudSim simulates the computation fundamentally differently. </p> <p>In CloudSim, a computing work is defined as a Cloudlet with a given length. Then, the Cloudlet is scheduled onto VM. The Cloudlet included two functions defined for CPU usage and RAM usage. Hence, the actual resource usages are just random numbers generated from a predefined function.</p> <p>In PyCloudSim, a computing work is defined as vProcess which has a instruction length. Then a set of random bytes are generated as \"instructons\" to determine the RAM usage for this vProcess. Then, PyCloudSim simulates the CPU for scheduling process on multiple core for execution. Hence, vProcess could occupiy one or more vCPUCore at the same time. Each vCPUCore consumes the \"insrtuctions\" according to schedule from vCPU. While vCPUCore is executing \"instructions\", its computational power ( defined by frequency and instructions per cycle ) is considered as been used. After executing, the vCPUCore will regain the used computational power. When a vProcess has its \"instructions\" all been executed, then it is complete. Therefore, the CPU and RAM usage patterns simulated by PyCloudSim are not merely random numbers, they are more realistic to how a real computer should behave.</p> <p>In addtion, PyCloudSim also simulates the network traffic. That is, vPackets will be created along vProcess. Then, vNIC will queue and transmit them! So you can simulate a API call between vContainers! The API call is simulated as vRequest and only when its associated vProcess is complete and all its associated vPackets have reached the destination, the vRequest is complete! This is impossible within CloudSim or CloudSim Plus.</p>"},{"location":"demo/","title":"Demo","text":"<pre><code>from PyCloudSim.entity import vMicroserviceDeafult, vHost, vNetworkService, vSFC, vUser\nfrom PyCloudSim.monitor import (\nHostMonitor,\nPacketMonitor,\nMSMonitor,\nWorkFlowMonitor,\nRequestMonitor,\n)\nfrom PyCloudSim.core import simulation\nfrom PyCloudSim.util import *\nimport random\nfrom Akatosh import event\ndefault_settings()\ninitiate_topology()\nfor i in range(2):\nvHost(num_cpu_cores=2, ipc=1, frequency=2000, ram=16, rom=32, label=f\"Host {i}\")\nms1 = vMicroserviceDeafult(\ncpu=40,\ncpu_limit=80,\nram=512,\nram_limit=1024,\nimage_size=100,\nvolumes=[(\"test\", \"test\", 100, False), (\"test2\", \"test\", 100, True)],\nmin_num_containers=4,\nmax_num_containers=5,\nlabel=\"Microservice 1\",\ndeamon=False,\n)\nms2 = vMicroserviceDeafult(\ncpu=40,\ncpu_limit=80,\nram=512,\nram_limit=1024,\nimage_size=100,\nvolumes=[(\"test\", \"test\", 100, False), (\"test2\", \"test\", 100, True)],\nmin_num_containers=3,\nmax_num_containers=5,\nlabel=\"Microservice 2\",\ndeamon=False,\n)\nms3 = vMicroserviceDeafult(\ncpu=40,\ncpu_limit=80,\nram=512,\nram_limit=1024,\nimage_size=100,\nvolumes=[(\"test\", \"test\", 100, False), (\"test2\", \"test\", 100, True)],\nmin_num_containers=3,\nmax_num_containers=5,\nlabel=\"Microservice 3\",\ndeamon=False,\n)\nns = vNetworkService(\nmicroservices=[ms1, ms2, ms3],\nlinks=[(ms1, ms2), (ms2, ms3)],\nentry=ms1,\nexit=ms3,\nlabel=\"Network Service 1\",\n)\ndef random_process_length():\nreturn random.randint(10, 50)\ndef random_packet_size():\nreturn random.randint(100, 65536)\ndef random_num_packets():\nreturn random.randint(5, 10)\nsfc = vSFC(\nentry=(ms1, GET),\nexit=(ms3, POST),\npath=[(ms1, ms2, GET), (ms2, ms3, GET)],\nnetwork_service=ns,\nlabel=f\"test\",\n)\nuser = vUser()\nfor i in range(20):\nuser.request_sfc(sfc, priority=i, retry=True, backoff=lambda: random.random())\nhost_monitor = HostMonitor()\nworkflow_monitor = WorkFlowMonitor()\npacket_monitor = PacketMonitor()\nms_monitor = MSMonitor()\nreq_monitor = RequestMonitor()\nsimulation.run(10)\nhost_monitor.df.to_csv(\"./test_result/host.csv\")\npacket_monitor.df.to_csv(\"./test_result/packet.csv\")\nms_monitor.df.to_csv(\"./test_result/ms.csv\")\nworkflow_monitor.df.to_csv(\"./test_result/workflow.csv\")\nreq_monitor.df.to_csv(\"./test_result/req.csv\")\n</code></pre>"},{"location":"open5gs/","title":"Simulate Open5gs","text":"<pre><code>from PyCloudSim.entity import vMicroserviceDeafult, vHost, vNetworkService, vSFC, vUser\nfrom PyCloudSim.monitor import (\nHostMonitor,\nPacketMonitor,\nMSMonitor,\nWorkFlowMonitor,\nRequestMonitor,\nUserRequestMonitor,\n)\nfrom PyCloudSim.core import simulation\nfrom PyCloudSim.util import *\nimport random\nfrom Akatosh import event\ndefault_settings()\ninitiate_topology()\namf = vMicroserviceDeafult(\ncpu=50,\ncpu_limit=100,\nram=128,\nram_limit=256,\nimage_size=100,\nlabel=\"AMF\",\nmin_num_containers=1,\nmax_num_containers=1,\n)\nausf = vMicroserviceDeafult(\nlabel=\"AUSF\",\ncpu=50,\ncpu_limit=100,\nram=128,\nram_limit=256,\nimage_size=100,\nmin_num_containers=1,\nmax_num_containers=1,\n)\nudm = vMicroserviceDeafult(\nlabel=\"UDM\",\ncpu=50,\ncpu_limit=100,\nram=128,\nram_limit=256,\nimage_size=100,\nmin_num_containers=1,\nmax_num_containers=1,\n)\nsmf = vMicroserviceDeafult(\nlabel=\"SMF\",\ncpu=50,\ncpu_limit=100,\nram=128,\nram_limit=256,\nimage_size=100,\nmin_num_containers=1,\nmax_num_containers=1,\n)\nudr = vMicroserviceDeafult(\nlabel=\"UDR\",\ncpu=50,\ncpu_limit=100,\nram=128,\nram_limit=256,\nimage_size=100,\nmin_num_containers=1,\nmax_num_containers=1,\n)\npcf = vMicroserviceDeafult(\nlabel=\"PCF\",\ncpu=50,\ncpu_limit=100,\nram=128,\nram_limit=256,\nimage_size=100,\nmin_num_containers=1,\nmax_num_containers=1,\n)\nupf = vMicroserviceDeafult(\nlabel=\"UPF\",\ncpu=50,\ncpu_limit=100,\nram=128,\nram_limit=256,\nimage_size=100,\nmin_num_containers=1,\nmax_num_containers=3,\n)\nsfc_1 = vSFC(\nlabel=\"request_access\",\nentry=(amf, POST),\npath=[(amf, ausf, POST)],\nat=0,\n)\nsfc_2 = vSFC(\nlabel=\"notice_udm\",\npath=[(ausf, udm, POST)],\ninternal=True,\n)\nsfc_3 = vSFC(\nlabel=\"config_pcf\",\npath=[(udm, udr, POST), (udr, pcf, POST)],\ninternal=True,\n)\nsfc_4 = vSFC(\nlabel=\"config_smf\",\npath=[(udm, smf, POST)],\ninternal=True,\n)\nsfc_5 = vSFC(\nlabel=\"notice_ausf\",\npath=[(udm, ausf, POST)],\ninternal=True,\n)\nsfc_6 = vSFC(\nlabel=\"grant_access\",\nexit=(amf, POST),\npath=[(ausf, amf, POST)],\n)\nsfc_7 = vSFC(\nlabel=\"access_internet\",\nentry=(upf, GET),\nexit=(upf, POST),\n)\nfor i in range(2):\nvHost(\nram=4,\nrom=1024,\nipc=1,\nfrequency=4000,\nnum_cpu_cores=1,\nat=0,\nlabel=f\"Host {i}\",\n)\nfor _ in range(10):\nuser = vUser()\nflow1 = user.request_sfc(sfc_1)\nflow2 = user.request_sfc(sfc_2,after=flow1)\nflow3 = user.request_sfc(sfc_3,after=flow2)\nflow4 = user.request_sfc(sfc_4,after=flow3)\nflow5 = user.request_sfc(sfc_5,after=flow4)\nflow6 = user.request_sfc(sfc_6,after=flow5)\nflow7 = user.request_sfc(sfc_7,after=flow6, num_packets=100, packet_size=lambda: random.randint(100, 65536))\nhost_monitor = HostMonitor()\nworkflow_monitor = WorkFlowMonitor()\npacket_monitor = PacketMonitor()\nms_monitor = MSMonitor()\nreq_monitor = RequestMonitor()\nuser_request_monitor = UserRequestMonitor()\nsimulation.run(10)\nhost_monitor.df.to_csv(\"./test_result/host.csv\")\npacket_monitor.df.to_csv(\"./test_result/packet.csv\")\nms_monitor.df.to_csv(\"./test_result/ms.csv\")\nworkflow_monitor.df.to_csv(\"./test_result/workflow.csv\")\nreq_monitor.df.to_csv(\"./test_result/req.csv\")\nuser_request_monitor.df.to_csv(\"./test_result/user_req.csv\")\n</code></pre>"},{"location":"api/","title":"Index","text":"<p>The <code>Entity</code> class is the base for all simulated entity.</p> <p>         Bases: <code>ABC</code></p> Source code in <code>PyCloudSim\\entity\\v_entity.py</code> <pre><code>class Entity(ABC):\n_label: str\n_created_at: float\n_started_at: float\n_terminated_at: float\n_status: List[str]\ndef __init__(\nself,\nlabel: Optional[str] = None,\nat: Union[int, float, Callable] = simulation.now,\nafter: Optional[Entity | List[Entity]] = None,\n):\n\"\"\"The base class for all simulated entity\n        Args:\n            label (Optional[str], optional): short description of the entity. Defaults to None.\n            at (Union[int, float, Callable], optional): when the entity should be created. Defaults to simulation.now.\n            after (Optional[Entity  |  List[Entity]], optional): the entity must be created after. Defaults to None.\n        \"\"\"\nself._id = uuid4().int\nself._label = label if label else get_name()\nself._created_at = float()\nself._started_at = float()\nself._terminated_at = float()\nself._status = list()\nself._on_creation: Callable = lambda: None\nself._on_termination: Callable = lambda: None\nself._after = None\nif isinstance(after, list):\nself._after = [entity.terminator for entity in after]\nelif after is not None:\nself._after = after.terminator\nself._creator = Actor(\nat=at,\nafter=self.after,\naction=self.creation,\nlabel=f\"{self.__class__.__name__} {self.label} creation\",\npriority=CREATION,\n)\nself._terminator = Actor(\nat=inf,\naction=self.__terminate,\nlabel=f\"{self.__class__.__name__} {self.label} termination\",\nactive=False,\npriority=TERMINATION,\n)\n@abstractmethod\ndef creation(self):\n\"\"\"Creatation process of the entity.\"\"\"\nself._created_at = simulation.now\nself.status.append(CREATED)\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} is created.\"\n)\nself.on_creation()\n@abstractmethod\ndef termination(self):\n\"\"\"Termination process of the entity.\"\"\"\npass\ndef __terminate(self):\nif self.terminated:\nreturn\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} is terminated.\"\n)\nself._terminated_at = simulation.now\nself.status.append(TERMINATED)\nself.termination()\nself.on_termination()\ndef terminate(self):\n\"\"\"Terminate the entity.\"\"\"\nif not self.created:\nraise RuntimeError(\nf\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} is not created yet.\"\n)\nself.terminator.activate()\n@property\ndef id(self) -&gt; int:\n\"\"\"The id of the entity.\"\"\"\nreturn self._id\n@property\ndef label(self) -&gt; str:\n\"\"\"The label of the entity.\"\"\"\nreturn self._label\n@property\ndef created_at(self) -&gt; float:\n\"\"\"The time when the entity is created.\"\"\"\nreturn self._created_at\n@property\ndef started_at(self) -&gt; float:\n\"\"\"The time when the entity is started.\"\"\"\nreturn self._started_at\n@property\ndef terminated_at(self) -&gt; float:\n\"\"\"The time when the entity is terminated.\"\"\"\nreturn self._terminated_at\n@property\ndef status(self) -&gt; List[str]:\n\"\"\"The status of the entity.\"\"\"\nreturn self._status\n@property\ndef created(self) -&gt; bool:\n\"\"\"Return True if the entity is created.\"\"\"\nreturn CREATED in self._status\n@property\ndef started(self) -&gt; bool:\n\"\"\"Return True if the entity is started.\"\"\"\nreturn STARTED in self._status\n@property\ndef terminated(self) -&gt; bool:\n\"\"\"Return True if the entity is terminated.\"\"\"\nreturn TERMINATED in self._status\n@property\ndef creator(self) -&gt; Actor:\n\"\"\"The creator of the entity.\"\"\"\nreturn self._creator\n@property\ndef terminator(self) -&gt; Actor:\n\"\"\"The terminator of the entity.\"\"\"\nreturn self._terminator\n@property\ndef after(self) -&gt; Actor | List[Actor] | None:\n\"\"\"The other enity that this entity must be created after.\"\"\"\nreturn self._after\n@property\ndef on_creation(self) -&gt; Callable:\n\"\"\"Callback function on creation process\"\"\"\nreturn self._on_creation\n@on_creation.setter\ndef on_creation(self, func: Callable):\nself._on_creation = func\n@property\ndef on_termination(self) -&gt; Callable:\n\"\"\"Callback function on termination process\"\"\"\nreturn self._on_termination\n@on_termination.setter\ndef on_termination(self, func: Callable):\nself._on_termination = func\n</code></pre>"},{"location":"api/#PyCloudSim.entity.v_entity.Entity.after","title":"<code>after: Actor | List[Actor] | None</code>  <code>property</code>","text":"<p>The other enity that this entity must be created after.</p>"},{"location":"api/#PyCloudSim.entity.v_entity.Entity.created","title":"<code>created: bool</code>  <code>property</code>","text":"<p>Return True if the entity is created.</p>"},{"location":"api/#PyCloudSim.entity.v_entity.Entity.created_at","title":"<code>created_at: float</code>  <code>property</code>","text":"<p>The time when the entity is created.</p>"},{"location":"api/#PyCloudSim.entity.v_entity.Entity.creator","title":"<code>creator: Actor</code>  <code>property</code>","text":"<p>The creator of the entity.</p>"},{"location":"api/#PyCloudSim.entity.v_entity.Entity.id","title":"<code>id: int</code>  <code>property</code>","text":"<p>The id of the entity.</p>"},{"location":"api/#PyCloudSim.entity.v_entity.Entity.label","title":"<code>label: str</code>  <code>property</code>","text":"<p>The label of the entity.</p>"},{"location":"api/#PyCloudSim.entity.v_entity.Entity.on_creation","title":"<code>on_creation: Callable</code>  <code>property</code> <code>writable</code>","text":"<p>Callback function on creation process</p>"},{"location":"api/#PyCloudSim.entity.v_entity.Entity.on_termination","title":"<code>on_termination: Callable</code>  <code>property</code> <code>writable</code>","text":"<p>Callback function on termination process</p>"},{"location":"api/#PyCloudSim.entity.v_entity.Entity.started","title":"<code>started: bool</code>  <code>property</code>","text":"<p>Return True if the entity is started.</p>"},{"location":"api/#PyCloudSim.entity.v_entity.Entity.started_at","title":"<code>started_at: float</code>  <code>property</code>","text":"<p>The time when the entity is started.</p>"},{"location":"api/#PyCloudSim.entity.v_entity.Entity.status","title":"<code>status: List[str]</code>  <code>property</code>","text":"<p>The status of the entity.</p>"},{"location":"api/#PyCloudSim.entity.v_entity.Entity.terminated","title":"<code>terminated: bool</code>  <code>property</code>","text":"<p>Return True if the entity is terminated.</p>"},{"location":"api/#PyCloudSim.entity.v_entity.Entity.terminated_at","title":"<code>terminated_at: float</code>  <code>property</code>","text":"<p>The time when the entity is terminated.</p>"},{"location":"api/#PyCloudSim.entity.v_entity.Entity.terminator","title":"<code>terminator: Actor</code>  <code>property</code>","text":"<p>The terminator of the entity.</p>"},{"location":"api/#PyCloudSim.entity.v_entity.Entity.__init__","title":"<code>__init__(label=None, at=simulation.now, after=None)</code>","text":"<p>The base class for all simulated entity</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>Optional[str]</code> <p>short description of the entity. Defaults to None.</p> <code>None</code> <code>at</code> <code>Union[int, float, Callable]</code> <p>when the entity should be created. Defaults to simulation.now.</p> <code>simulation.now</code> <code>after</code> <code>Optional[Entity | List[Entity]]</code> <p>the entity must be created after. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_entity.py</code> <pre><code>def __init__(\nself,\nlabel: Optional[str] = None,\nat: Union[int, float, Callable] = simulation.now,\nafter: Optional[Entity | List[Entity]] = None,\n):\n\"\"\"The base class for all simulated entity\n    Args:\n        label (Optional[str], optional): short description of the entity. Defaults to None.\n        at (Union[int, float, Callable], optional): when the entity should be created. Defaults to simulation.now.\n        after (Optional[Entity  |  List[Entity]], optional): the entity must be created after. Defaults to None.\n    \"\"\"\nself._id = uuid4().int\nself._label = label if label else get_name()\nself._created_at = float()\nself._started_at = float()\nself._terminated_at = float()\nself._status = list()\nself._on_creation: Callable = lambda: None\nself._on_termination: Callable = lambda: None\nself._after = None\nif isinstance(after, list):\nself._after = [entity.terminator for entity in after]\nelif after is not None:\nself._after = after.terminator\nself._creator = Actor(\nat=at,\nafter=self.after,\naction=self.creation,\nlabel=f\"{self.__class__.__name__} {self.label} creation\",\npriority=CREATION,\n)\nself._terminator = Actor(\nat=inf,\naction=self.__terminate,\nlabel=f\"{self.__class__.__name__} {self.label} termination\",\nactive=False,\npriority=TERMINATION,\n)\n</code></pre>"},{"location":"api/#PyCloudSim.entity.v_entity.Entity.creation","title":"<code>creation()</code>  <code>abstractmethod</code>","text":"<p>Creatation process of the entity.</p> Source code in <code>PyCloudSim\\entity\\v_entity.py</code> <pre><code>@abstractmethod\ndef creation(self):\n\"\"\"Creatation process of the entity.\"\"\"\nself._created_at = simulation.now\nself.status.append(CREATED)\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} is created.\"\n)\nself.on_creation()\n</code></pre>"},{"location":"api/#PyCloudSim.entity.v_entity.Entity.terminate","title":"<code>terminate()</code>","text":"<p>Terminate the entity.</p> Source code in <code>PyCloudSim\\entity\\v_entity.py</code> <pre><code>def terminate(self):\n\"\"\"Terminate the entity.\"\"\"\nif not self.created:\nraise RuntimeError(\nf\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} is not created yet.\"\n)\nself.terminator.activate()\n</code></pre>"},{"location":"api/#PyCloudSim.entity.v_entity.Entity.termination","title":"<code>termination()</code>  <code>abstractmethod</code>","text":"<p>Termination process of the entity.</p> Source code in <code>PyCloudSim\\entity\\v_entity.py</code> <pre><code>@abstractmethod\ndef termination(self):\n\"\"\"Termination process of the entity.\"\"\"\npass\n</code></pre>"},{"location":"api/monitor/host_monitor/","title":"Host Monitor","text":"<p>This class collects CPU, RAM, ROM, and bandwidth usage metrics at a predefined interval for each \"vHost\" in the simulation. It enables you to monitor the resource utilization of individual hosts over time.</p>"},{"location":"api/monitor/host_monitor/#PyCloudSim.monitor.host_monitor.HostMonitor","title":"<code>HostMonitor</code>","text":"Source code in <code>PyCloudSim\\monitor\\host_monitor.py</code> <pre><code>class HostMonitor:\n_monitored_hosts: Union[PhysicalEntity, List[PhysicalEntity]]\n_df: pd.DataFrame\ndef __init__(\nself,\nmonitored_host: Optional[PhysicalEntity | List[PhysicalEntity]] = None,\nmonitor_interval: Union[int, float] = 0.01,\n) -&gt; None:\n\"\"\"Host monitor.\n        Args:\n            monitored_host (Optional[PhysicalEntity  |  List[PhysicalEntity]], optional): if none, all simulated physical entity will be monitored. Defaults to None.\n            monitor_interval (Union[int, float], optional): the sampling interval. Defaults to 0.01.\n        \"\"\"        \nif monitored_host is None:\nself._monitored_hosts = []\nself._monitored_hosts.extend(simulation.HOSTS)\nself._monitored_hosts.extend(simulation.SWITCHES)\nself._monitored_hosts.extend(simulation.ROUTERS)\nelse:\nself._monitored_hosts = monitored_host\nself._monitor_interval = monitor_interval\nself._df = pd.DataFrame(\n{\n\"host_id\": pd.Series(dtype=\"str\"),\n\"host_label\": pd.Series(dtype=\"str\"),\n\"time\": pd.Series(dtype=\"float\"),\n\"cpu_util\": pd.Series(dtype=\"float\"),\n\"ram_util\": pd.Series(dtype=\"float\"),\n\"rom_util\": pd.Series(dtype=\"float\"),\n\"bw_in_util\": pd.Series(dtype=\"float\"),\n\"bw_out_util\": pd.Series(dtype=\"float\"),\n\"num_containers\": pd.Series(dtype=\"int\"),\n\"num_processes\": pd.Series(dtype=\"int\"),\n\"power_usage\": pd.Series(dtype=\"float\"),\n}\n)\nself._process = Actor(\nat=0,\nstep=self.monitor_interval,\naction=self.action,\npriority=MONITOR_PRIORITY,\nlabel=\"Host Monitor\",\n)\ndef action(self):\n\"\"\"Telemetries collection.\n        \"\"\"\nif isinstance(self._monitored_hosts, list):\nfor host in self._monitored_hosts:\nif host.created:\nhost_telemetry = pd.DataFrame(\n{\n\"host_id\": str(host.id),\n\"host_label\": host.label,\n\"time\": float(simulation.now),\n\"cpu_util\": host.cpu.utilization_in_past(\nself.monitor_interval\n),\n\"ram_util\": host.ram.utilization_in_past(\nself.monitor_interval\n),\n\"rom_util\": host.rom.utilization_in_past(\nself.monitor_interval\n),\n\"bw_in_util\": host.uplink_utilization(\nself.monitor_interval\n),\n\"bw_out_util\": host.downlink_utilization(\nself.monitor_interval\n),\n\"num_containers\": len(host.containers)\nif type(host) == vHost\nelse 0,\n\"num_processes\": len(host.processes),\n\"power_usage\": host.power_usage(self.monitor_interval),\n},\nindex=[0],\n)\nself._df = pd.concat([self._df, host_telemetry], ignore_index=True)\nelif isinstance(self.monitored_hosts, vHost):\nif self.monitored_hosts.created:\nhost_telemetry = pd.DataFrame(\n{\n\"host_id\": str(self.monitored_hosts.id),\n\"host_label\": self.monitored_hosts.label,\n\"time\": float(simulation.now),\n\"cpu_util\": self.monitored_hosts.cpu.utilization_in_past(\nself.monitor_interval\n),\n\"ram_util\": self.monitored_hosts.ram.utilization_in_past(\nself.monitor_interval\n),\n\"rom_util\": self.monitored_hosts.rom.utilization_in_past(\nself.monitor_interval\n),\n\"bw_in_util\": self.monitored_hosts.uplink_utilization(\nself.monitor_interval\n),\n\"bw_out_util\": self.monitored_hosts.downlink_utilization(\nself.monitor_interval\n),\n\"num_containers\": len(self.monitored_hosts.containers)\nif type(self.monitored_hosts) == vHost\nelse 0,\n\"num_processes\": len(self.monitored_hosts.processes),\n\"power_usage\": self.monitored_hosts.power_usage(\nself.monitor_interval\n),\n},\nindex=[0],\n)\nself._df = pd.concat([self._df, host_telemetry], ignore_index=True)\n@property\ndef df(self):\n\"\"\"The pandas dataframe containing the telemetry data.\"\"\"\nreturn self._df\n@property\ndef monitored_hosts(self):\n\"\"\"The monitored hosts.\"\"\"\nreturn self._monitored_hosts\n@property\ndef monitor_interval(self) -&gt; Union[int, float]:\n\"\"\"The sampling interval.\"\"\"\nreturn self._monitor_interval\n</code></pre>"},{"location":"api/monitor/host_monitor/#PyCloudSim.monitor.host_monitor.HostMonitor.df","title":"<code>df</code>  <code>property</code>","text":"<p>The pandas dataframe containing the telemetry data.</p>"},{"location":"api/monitor/host_monitor/#PyCloudSim.monitor.host_monitor.HostMonitor.monitor_interval","title":"<code>monitor_interval: Union[int, float]</code>  <code>property</code>","text":"<p>The sampling interval.</p>"},{"location":"api/monitor/host_monitor/#PyCloudSim.monitor.host_monitor.HostMonitor.monitored_hosts","title":"<code>monitored_hosts</code>  <code>property</code>","text":"<p>The monitored hosts.</p>"},{"location":"api/monitor/host_monitor/#PyCloudSim.monitor.host_monitor.HostMonitor.__init__","title":"<code>__init__(monitored_host=None, monitor_interval=0.01)</code>","text":"<p>Host monitor.</p> <p>Parameters:</p> Name Type Description Default <code>monitored_host</code> <code>Optional[PhysicalEntity | List[PhysicalEntity]]</code> <p>if none, all simulated physical entity will be monitored. Defaults to None.</p> <code>None</code> <code>monitor_interval</code> <code>Union[int, float]</code> <p>the sampling interval. Defaults to 0.01.</p> <code>0.01</code> Source code in <code>PyCloudSim\\monitor\\host_monitor.py</code> <pre><code>def __init__(\nself,\nmonitored_host: Optional[PhysicalEntity | List[PhysicalEntity]] = None,\nmonitor_interval: Union[int, float] = 0.01,\n) -&gt; None:\n\"\"\"Host monitor.\n    Args:\n        monitored_host (Optional[PhysicalEntity  |  List[PhysicalEntity]], optional): if none, all simulated physical entity will be monitored. Defaults to None.\n        monitor_interval (Union[int, float], optional): the sampling interval. Defaults to 0.01.\n    \"\"\"        \nif monitored_host is None:\nself._monitored_hosts = []\nself._monitored_hosts.extend(simulation.HOSTS)\nself._monitored_hosts.extend(simulation.SWITCHES)\nself._monitored_hosts.extend(simulation.ROUTERS)\nelse:\nself._monitored_hosts = monitored_host\nself._monitor_interval = monitor_interval\nself._df = pd.DataFrame(\n{\n\"host_id\": pd.Series(dtype=\"str\"),\n\"host_label\": pd.Series(dtype=\"str\"),\n\"time\": pd.Series(dtype=\"float\"),\n\"cpu_util\": pd.Series(dtype=\"float\"),\n\"ram_util\": pd.Series(dtype=\"float\"),\n\"rom_util\": pd.Series(dtype=\"float\"),\n\"bw_in_util\": pd.Series(dtype=\"float\"),\n\"bw_out_util\": pd.Series(dtype=\"float\"),\n\"num_containers\": pd.Series(dtype=\"int\"),\n\"num_processes\": pd.Series(dtype=\"int\"),\n\"power_usage\": pd.Series(dtype=\"float\"),\n}\n)\nself._process = Actor(\nat=0,\nstep=self.monitor_interval,\naction=self.action,\npriority=MONITOR_PRIORITY,\nlabel=\"Host Monitor\",\n)\n</code></pre>"},{"location":"api/monitor/host_monitor/#PyCloudSim.monitor.host_monitor.HostMonitor.action","title":"<code>action()</code>","text":"<p>Telemetries collection.</p> Source code in <code>PyCloudSim\\monitor\\host_monitor.py</code> <pre><code>def action(self):\n\"\"\"Telemetries collection.\n    \"\"\"\nif isinstance(self._monitored_hosts, list):\nfor host in self._monitored_hosts:\nif host.created:\nhost_telemetry = pd.DataFrame(\n{\n\"host_id\": str(host.id),\n\"host_label\": host.label,\n\"time\": float(simulation.now),\n\"cpu_util\": host.cpu.utilization_in_past(\nself.monitor_interval\n),\n\"ram_util\": host.ram.utilization_in_past(\nself.monitor_interval\n),\n\"rom_util\": host.rom.utilization_in_past(\nself.monitor_interval\n),\n\"bw_in_util\": host.uplink_utilization(\nself.monitor_interval\n),\n\"bw_out_util\": host.downlink_utilization(\nself.monitor_interval\n),\n\"num_containers\": len(host.containers)\nif type(host) == vHost\nelse 0,\n\"num_processes\": len(host.processes),\n\"power_usage\": host.power_usage(self.monitor_interval),\n},\nindex=[0],\n)\nself._df = pd.concat([self._df, host_telemetry], ignore_index=True)\nelif isinstance(self.monitored_hosts, vHost):\nif self.monitored_hosts.created:\nhost_telemetry = pd.DataFrame(\n{\n\"host_id\": str(self.monitored_hosts.id),\n\"host_label\": self.monitored_hosts.label,\n\"time\": float(simulation.now),\n\"cpu_util\": self.monitored_hosts.cpu.utilization_in_past(\nself.monitor_interval\n),\n\"ram_util\": self.monitored_hosts.ram.utilization_in_past(\nself.monitor_interval\n),\n\"rom_util\": self.monitored_hosts.rom.utilization_in_past(\nself.monitor_interval\n),\n\"bw_in_util\": self.monitored_hosts.uplink_utilization(\nself.monitor_interval\n),\n\"bw_out_util\": self.monitored_hosts.downlink_utilization(\nself.monitor_interval\n),\n\"num_containers\": len(self.monitored_hosts.containers)\nif type(self.monitored_hosts) == vHost\nelse 0,\n\"num_processes\": len(self.monitored_hosts.processes),\n\"power_usage\": self.monitored_hosts.power_usage(\nself.monitor_interval\n),\n},\nindex=[0],\n)\nself._df = pd.concat([self._df, host_telemetry], ignore_index=True)\n</code></pre>"},{"location":"api/monitor/microservice_monitor/","title":"Microservice Monitor","text":"<p>The MicroserviceMonitor class collects CPU, RAM, and bandwidth usage metrics at a predefined interval for each \"vMicroservice\" in the simulation. It allows you to track the resource consumption of microservices and analyze their performance.</p>"},{"location":"api/monitor/microservice_monitor/#PyCloudSim.monitor.ms_monitor.MSMonitor","title":"<code>MSMonitor</code>","text":"Source code in <code>PyCloudSim\\monitor\\ms_monitor.py</code> <pre><code>class MSMonitor:\n_monitored_ms: Union[vMicroservice, List[vMicroservice]]\n_df: pd.DataFrame\ndef __init__(\nself,\nmonitored_host: Optional[vMicroservice | List[vMicroservice]] = None,\nmonitor_interval: Union[int, float] = 0.01,\n) -&gt; None:\n\"\"\"vMicroservice Monitor.\n        Args:\n            monitored_host (Optional[vMicroservice  |  List[vMicroservice]], optional): if one, all microservices will be monitored. Defaults to None.\n            monitor_interval (Union[int, float], optional): the sampling interval. Defaults to 0.01.\n        \"\"\"        \nif monitored_host is None:\nself._monitored_ms = simulation.MICROSERVICES\nelse:\nself._monitored_ms = monitored_host\nself._monitor_interval = monitor_interval\nself._df = pd.DataFrame(\n{\n\"ms\": pd.Series(dtype=\"str\"),\n\"ms_id\": pd.Series(dtype=\"str\"),\n\"time\": pd.Series(dtype=\"float\"),\n\"cpu_util\": pd.Series(dtype=\"float\"),\n\"ram_util\": pd.Series(dtype=\"float\"),\n\"num_containers\": pd.Series(dtype=\"int\"),\n\"num_scheduled_containers\": pd.Series(dtype=\"int\"),\n\"num_non_scheduled_containers\": pd.Series(dtype=\"int\"),\n}\n)\nself._process = Actor(\nat=0,\nstep=self.monitor_interval,\naction=self.action,\npriority=MONITOR_PRIORITY,\nlabel=\"Host Monitor\",\n)\ndef action(self):\n\"\"\"Telemetries collection.\"\"\"\nif isinstance(self._monitored_ms, list):\nfor ms in self._monitored_ms:\nif not ms.terminated:\nhost_telemetry = pd.DataFrame(\n{\n\"ms\": ms.label,\n\"ms_id\": str(ms.id),\n\"time\": float(simulation.now),\n\"cpu_util\": ms.cpu_usage_in_past(self.monitor_interval),\n\"ram_util\": ms.ram_usage_in_past(self.monitor_interval),\n\"num_containers\": len(ms.containers),\n\"num_scheduled_containers\": len(\n[\ncontainer\nfor container in ms.containers\nif container.scheduled\n]\n),\n\"num_non_scheduled_containers\": len(\n[\ncontainer\nfor container in ms.containers\nif not container.scheduled\n]\n),\n},\nindex=[0],\n)\nself._df = pd.concat([self._df, host_telemetry], ignore_index=True)\nelif isinstance(self.monitored_ms, vMicroservice):\nhost_telemetry = pd.DataFrame(\n{\n\"ms\": self.monitored_ms.label,\n\"ms_id\": str(self.monitored_ms.id),\n\"time\": float(simulation.now),\n\"cpu_util\": self.monitored_ms.cpu_usage_in_past(self.monitor_interval),\n\"ram_util\": self.monitored_ms.cpu_usage_in_past(self.monitor_interval),\n\"num_containers\": len(self.monitored_ms.containers),\n\"num_scheduled_containers\": len(\n[\ncontainer\nfor container in self.monitored_ms.containers\nif container.scheduled\n]\n),\n\"num_non_scheduled_containers\": len(\n[\ncontainer\nfor container in self.monitored_ms.containers\nif not container.scheduled\n]\n),\n},\nindex=[0],\n)\nself._df = pd.concat([self._df, host_telemetry], ignore_index=True)\n@property\ndef df(self):\n\"\"\"The pandas dataframe of the host monitor.\"\"\"\nreturn self._df\n@property\ndef monitored_ms(self) -&gt; Union[vMicroservice, List[vMicroservice]]:\n\"\"\"The monitored microservices.\"\"\"\nreturn self._monitored_ms\n@property\ndef monitor_interval(self) -&gt; Union[int, float]:\n\"\"\"The sampling interval.\"\"\"\nreturn self._monitor_interval\n</code></pre>"},{"location":"api/monitor/microservice_monitor/#PyCloudSim.monitor.ms_monitor.MSMonitor.df","title":"<code>df</code>  <code>property</code>","text":"<p>The pandas dataframe of the host monitor.</p>"},{"location":"api/monitor/microservice_monitor/#PyCloudSim.monitor.ms_monitor.MSMonitor.monitor_interval","title":"<code>monitor_interval: Union[int, float]</code>  <code>property</code>","text":"<p>The sampling interval.</p>"},{"location":"api/monitor/microservice_monitor/#PyCloudSim.monitor.ms_monitor.MSMonitor.monitored_ms","title":"<code>monitored_ms: Union[vMicroservice, List[vMicroservice]]</code>  <code>property</code>","text":"<p>The monitored microservices.</p>"},{"location":"api/monitor/microservice_monitor/#PyCloudSim.monitor.ms_monitor.MSMonitor.__init__","title":"<code>__init__(monitored_host=None, monitor_interval=0.01)</code>","text":"<p>vMicroservice Monitor.</p> <p>Parameters:</p> Name Type Description Default <code>monitored_host</code> <code>Optional[vMicroservice | List[vMicroservice]]</code> <p>if one, all microservices will be monitored. Defaults to None.</p> <code>None</code> <code>monitor_interval</code> <code>Union[int, float]</code> <p>the sampling interval. Defaults to 0.01.</p> <code>0.01</code> Source code in <code>PyCloudSim\\monitor\\ms_monitor.py</code> <pre><code>def __init__(\nself,\nmonitored_host: Optional[vMicroservice | List[vMicroservice]] = None,\nmonitor_interval: Union[int, float] = 0.01,\n) -&gt; None:\n\"\"\"vMicroservice Monitor.\n    Args:\n        monitored_host (Optional[vMicroservice  |  List[vMicroservice]], optional): if one, all microservices will be monitored. Defaults to None.\n        monitor_interval (Union[int, float], optional): the sampling interval. Defaults to 0.01.\n    \"\"\"        \nif monitored_host is None:\nself._monitored_ms = simulation.MICROSERVICES\nelse:\nself._monitored_ms = monitored_host\nself._monitor_interval = monitor_interval\nself._df = pd.DataFrame(\n{\n\"ms\": pd.Series(dtype=\"str\"),\n\"ms_id\": pd.Series(dtype=\"str\"),\n\"time\": pd.Series(dtype=\"float\"),\n\"cpu_util\": pd.Series(dtype=\"float\"),\n\"ram_util\": pd.Series(dtype=\"float\"),\n\"num_containers\": pd.Series(dtype=\"int\"),\n\"num_scheduled_containers\": pd.Series(dtype=\"int\"),\n\"num_non_scheduled_containers\": pd.Series(dtype=\"int\"),\n}\n)\nself._process = Actor(\nat=0,\nstep=self.monitor_interval,\naction=self.action,\npriority=MONITOR_PRIORITY,\nlabel=\"Host Monitor\",\n)\n</code></pre>"},{"location":"api/monitor/microservice_monitor/#PyCloudSim.monitor.ms_monitor.MSMonitor.action","title":"<code>action()</code>","text":"<p>Telemetries collection.</p> Source code in <code>PyCloudSim\\monitor\\ms_monitor.py</code> <pre><code>def action(self):\n\"\"\"Telemetries collection.\"\"\"\nif isinstance(self._monitored_ms, list):\nfor ms in self._monitored_ms:\nif not ms.terminated:\nhost_telemetry = pd.DataFrame(\n{\n\"ms\": ms.label,\n\"ms_id\": str(ms.id),\n\"time\": float(simulation.now),\n\"cpu_util\": ms.cpu_usage_in_past(self.monitor_interval),\n\"ram_util\": ms.ram_usage_in_past(self.monitor_interval),\n\"num_containers\": len(ms.containers),\n\"num_scheduled_containers\": len(\n[\ncontainer\nfor container in ms.containers\nif container.scheduled\n]\n),\n\"num_non_scheduled_containers\": len(\n[\ncontainer\nfor container in ms.containers\nif not container.scheduled\n]\n),\n},\nindex=[0],\n)\nself._df = pd.concat([self._df, host_telemetry], ignore_index=True)\nelif isinstance(self.monitored_ms, vMicroservice):\nhost_telemetry = pd.DataFrame(\n{\n\"ms\": self.monitored_ms.label,\n\"ms_id\": str(self.monitored_ms.id),\n\"time\": float(simulation.now),\n\"cpu_util\": self.monitored_ms.cpu_usage_in_past(self.monitor_interval),\n\"ram_util\": self.monitored_ms.cpu_usage_in_past(self.monitor_interval),\n\"num_containers\": len(self.monitored_ms.containers),\n\"num_scheduled_containers\": len(\n[\ncontainer\nfor container in self.monitored_ms.containers\nif container.scheduled\n]\n),\n\"num_non_scheduled_containers\": len(\n[\ncontainer\nfor container in self.monitored_ms.containers\nif not container.scheduled\n]\n),\n},\nindex=[0],\n)\nself._df = pd.concat([self._df, host_telemetry], ignore_index=True)\n</code></pre>"},{"location":"api/monitor/request_monitor/","title":"Request Monitor","text":"<p>The RequestMonitor class collects creation time, scheduled time, termination time, and retry count information for each \"vRequest\" in the simulation. It allows you to track the lifecycle of requests, including their scheduling, execution, and potential retries.</p>"},{"location":"api/monitor/request_monitor/#PyCloudSim.monitor.request_monitor.RequestMonitor","title":"<code>RequestMonitor</code>","text":"<p>Request Monitor.</p> Source code in <code>PyCloudSim\\monitor\\request_monitor.py</code> <pre><code>class RequestMonitor:\n\"\"\"Request Monitor.\"\"\"\n_df: pd.DataFrame\ndef __init__(\nself,\n) -&gt; None:\nself._df = pd.DataFrame(\n{\n\"request_id\": pd.Series(dtype=\"str\"),\n\"request_label\": pd.Series(dtype=\"str\"),\n\"user_id\": pd.Series(dtype=\"str\"),\n\"user_label\": pd.Series(dtype=\"str\"),\n\"created_at\": pd.Series(dtype=\"float\"),\n\"scheduled_at\": pd.Series(dtype=\"float\"),\n\"terminated_at\": pd.Series(dtype=\"float\"),\n\"successful\": pd.Series(dtype=\"bool\"),\n}\n)\nsimulation._request_monitor = self\ndef collect(self):\nfor request in simulation.REQUESTS:\nrequest_info = pd.DataFrame(\n{\n\"request_id\": request.id,\n\"request_label\": request.label,\n\"user_id\": request.user.id if request.user else None,\n\"user_label\": request.user.label if request.user else None,\n\"created_at\": request.created_at,\n\"scheduled_at\": request.scheduled_at,\n\"terminated_at\": request.terminated_at,\n\"successful\": request.completed,\n},\nindex=[0],\n)\nself._df = pd.concat([self._df, request_info], ignore_index=True)\n@property\ndef df(self) -&gt; pd.DataFrame:\nreturn self._df\n</code></pre>"},{"location":"api/physical_component/","title":"Index","text":"<p>The <code>PhysicalComponent</code> class is the base class for vCPU, vCPUCore and vNIC</p> <p>         Bases: <code>Entity</code>, <code>ABC</code></p> Source code in <code>PyCloudSim\\entity\\v_physical_component.py</code> <pre><code>class PhysicalComponent(Entity, ABC):\n_privisoned_at: float\ndef __init__(\nself,\nat: Union[int, float, Callable] = simulation.now,\nafter: Optional[Entity | List[Entity]] = None,\nlabel: Optional[str] = None,\n):\n\"\"\"Create a physical component.\n        Args:\n            at (Union[int, float, Callable], optional): same as entity. Defaults to simulation.now.\n            after (Optional[Entity  |  List[Entity]], optional): same as entity. Defaults to None.\n            label (Optional[str], optional): same as entity. Defaults to None.\n        \"\"\"\nsuper().__init__(at=at, after=after, label=label)\nsimulation.topology.add_node(self)\n@abstractmethod\ndef _power_on(self):\n\"\"\"Power on the physical component.\"\"\"\nif self.powered_off:\nself.status.append(POWERED_ON)\nself.on_power_on()\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} is powered on.\"\n)\ndef power_on(self):\n\"\"\"Power on the physical component.\"\"\"\nif self.powered_off:\nActor(\nat=simulation.now,\naction=self._power_on,\nlabel=f\"{self.__class__.__name__} {self.label} Power On.\",\npriority=POWERING,\n)\ndef on_power_on(self):\n\"\"\"Callback function for when the physical component is powered on.\"\"\"\npass\n@abstractmethod\ndef _power_off(self):\n\"\"\"Power off the physical component.\"\"\"\nif self.powered_on:\nself.status.remove(POWERED_ON)\nself.status.append(POWERED_OFF)\nself.on_power_off()\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} is powered off.\"\n)\ndef power_off(self):\n\"\"\"Power off the physical component.\"\"\"\nif self.powered_on:\nActor(\nat=simulation.now,\naction=self._power_off,\nlabel=f\"{self.__class__.__name__} {self.label} Power Off.\",\npriority=POWERING,\n)\ndef on_power_off(self):\n\"\"\"Callback function for when the physical component is powered off.\"\"\"\npass\n@property\ndef powered_on(self) -&gt; bool:\n\"\"\"returns True if the physical component is powered on, False otherwise.\"\"\"\nreturn POWERED_ON in self._status\n@property\ndef powered_off(self) -&gt; bool:\n\"\"\"returns True if the physical component is powered off, False otherwise.\"\"\"\nreturn POWERED_ON not in self._status\n</code></pre>"},{"location":"api/physical_component/#PyCloudSim.entity.v_physical_component.PhysicalComponent.powered_off","title":"<code>powered_off: bool</code>  <code>property</code>","text":"<p>returns True if the physical component is powered off, False otherwise.</p>"},{"location":"api/physical_component/#PyCloudSim.entity.v_physical_component.PhysicalComponent.powered_on","title":"<code>powered_on: bool</code>  <code>property</code>","text":"<p>returns True if the physical component is powered on, False otherwise.</p>"},{"location":"api/physical_component/#PyCloudSim.entity.v_physical_component.PhysicalComponent.__init__","title":"<code>__init__(at=simulation.now, after=None, label=None)</code>","text":"<p>Create a physical component.</p> <p>Parameters:</p> Name Type Description Default <code>at</code> <code>Union[int, float, Callable]</code> <p>same as entity. Defaults to simulation.now.</p> <code>simulation.now</code> <code>after</code> <code>Optional[Entity | List[Entity]]</code> <p>same as entity. Defaults to None.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>same as entity. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_physical_component.py</code> <pre><code>def __init__(\nself,\nat: Union[int, float, Callable] = simulation.now,\nafter: Optional[Entity | List[Entity]] = None,\nlabel: Optional[str] = None,\n):\n\"\"\"Create a physical component.\n    Args:\n        at (Union[int, float, Callable], optional): same as entity. Defaults to simulation.now.\n        after (Optional[Entity  |  List[Entity]], optional): same as entity. Defaults to None.\n        label (Optional[str], optional): same as entity. Defaults to None.\n    \"\"\"\nsuper().__init__(at=at, after=after, label=label)\nsimulation.topology.add_node(self)\n</code></pre>"},{"location":"api/physical_component/#PyCloudSim.entity.v_physical_component.PhysicalComponent.on_power_off","title":"<code>on_power_off()</code>","text":"<p>Callback function for when the physical component is powered off.</p> Source code in <code>PyCloudSim\\entity\\v_physical_component.py</code> <pre><code>def on_power_off(self):\n\"\"\"Callback function for when the physical component is powered off.\"\"\"\npass\n</code></pre>"},{"location":"api/physical_component/#PyCloudSim.entity.v_physical_component.PhysicalComponent.on_power_on","title":"<code>on_power_on()</code>","text":"<p>Callback function for when the physical component is powered on.</p> Source code in <code>PyCloudSim\\entity\\v_physical_component.py</code> <pre><code>def on_power_on(self):\n\"\"\"Callback function for when the physical component is powered on.\"\"\"\npass\n</code></pre>"},{"location":"api/physical_component/#PyCloudSim.entity.v_physical_component.PhysicalComponent.power_off","title":"<code>power_off()</code>","text":"<p>Power off the physical component.</p> Source code in <code>PyCloudSim\\entity\\v_physical_component.py</code> <pre><code>def power_off(self):\n\"\"\"Power off the physical component.\"\"\"\nif self.powered_on:\nActor(\nat=simulation.now,\naction=self._power_off,\nlabel=f\"{self.__class__.__name__} {self.label} Power Off.\",\npriority=POWERING,\n)\n</code></pre>"},{"location":"api/physical_component/#PyCloudSim.entity.v_physical_component.PhysicalComponent.power_on","title":"<code>power_on()</code>","text":"<p>Power on the physical component.</p> Source code in <code>PyCloudSim\\entity\\v_physical_component.py</code> <pre><code>def power_on(self):\n\"\"\"Power on the physical component.\"\"\"\nif self.powered_off:\nActor(\nat=simulation.now,\naction=self._power_on,\nlabel=f\"{self.__class__.__name__} {self.label} Power On.\",\npriority=POWERING,\n)\n</code></pre>"},{"location":"api/physical_component/v_cpu/","title":"vCPU","text":"<p>The class \"vCPU\" is an implementation derived from the \"PhysicalComponent\" class. A \"vCPU\" object consists of multiple \"vCPUCore\" instances and a cache that serves as a pool for storing \"vProcess\" objects. Whenever a new \"vProcess\" is added to the cache or a \"vProcess\" is terminated, the \"vCPU\" class handles the assignment of \"vProcess\" objects to its corresponding \"vCPUCore\" based on several factors. These factors include the priority of the \"vProcess,\" the available computational power of each \"vCPUCore,\" and the allowed CPU time of the associated \"vContainer.\" Notably, a single \"vProcess\" can be assigned to multiple \"vCPUCore\" instances, allowing for simulated parallel execution. The scheduling of \"vProcess\" is implemented as an event with only one scheduling event being active for each \"vCPU\" at any given time.</p> <p>         Bases: <code>PhysicalComponent</code></p> Source code in <code>PyCloudSim\\entity\\v_cpu.py</code> <pre><code>class vCPU(PhysicalComponent):\n_cpu_cores: List[vCPUCore]\n_processes: List[vProcess]\ndef __init__(\nself,\nipc: Union[int, float],\nfrequency: Union[int, float],\nnum_cores: int,\ntdp: Union[int, float] = 50,\nat: Union[int, float, Callable] = simulation.now,\nafter: Optional[Entity | List[Entity]] = None,\nlabel: Optional[str] = None,\n):\n\"\"\"Creates a new vCPU.\n        Args:\n            ipc (Union[int, float]): instructions per cycle.\n            frequency (Union[int, float]): the frequency of cpu core.\n            num_cores (int): the number of cores in the cpu.\n            tdp (Union[int, float], optional): the TDP, aka power consumption of the cpu. Defaults to 50W.\n            at (Union[int, float, Callable], optional): when the cpu should be created. Defaults to simulation.now.\n            after (Optional[Entity  |  List[Entity]], optional): the entity that must be terminated before the cpu can be created. Defaults to None.\n            label (Optional[str], optional): short description of the cpu. Defaults to None.\n        \"\"\"\nsuper().__init__(at, after, label)\nself._ipc = ipc\nself._frequency = frequency * 1000000\nself._num_cores = num_cores\ncpu_cores = [\nvCPUCore(\nipc=self.ipc,\nfrequency=self.frequency,\ncpu=self,\nlabel=f\"{self.label}-Core-{i}\",\n)\nfor i in range(num_cores)\n]\nself._cpu_cores = cpu_cores\nself._tdp = tdp\nself._processes = list()\nself._process_scheduler: Actor = None  # type: ignore\nsimulation.CPUS.append(self)\ndef creation(self):\n\"\"\"Creates the cpu.\"\"\"\nreturn super().creation()\ndef termination(self):\n\"\"\"Terminates the cpu.\"\"\"\nreturn super().termination()\ndef _power_on(self):\n\"\"\"Power on the cpu and all its cores.\"\"\"\nsuper()._power_on()\nfor core in self.cpu_cores:\ncore.power_on()\ndef _power_off(self):\n\"\"\"Power off the cpu and all its cores.\"\"\"\nsuper()._power_off()\nfor core in self.cpu_cores:\ncore.power_off()\ndef cache_process(self, process: vProcess):\n\"\"\"Cache a process in the cpu and call schedule_process().\"\"\"\nif not process.cached:\nself.processes.append(process)\nprocess._cpu_id = self.id\nprocess.status.append(CACHED)\nself.schedule_process()\ndef schedule_process(self):\n\"\"\"shcedule processes in the cpu queue.\"\"\"\ndef _schedule_process():\nLOGGER.debug(\nf\"{simulation.now:0.2f}:\\tvCPU {self.label} is scheduling ... {len(self.processes)} processes\"\n)\nself.processes.sort(key=lambda process: process.priority)\nfor process in self.processes:\n# if not process.executing and not process.terminated:\nfor core in self.cpu_cores:\nremaining_to_schedule_instruction_length = (\nprocess.remaining - process.current_scheduled_length\n)\nif process.__class__.__name__ == \"vPacketHandler\":\ncontainer_allowed_instruction_length = inf\nelse:\ncontainer_allowed_instruction_length = (\nprocess.container.cpu.available_quantity  # type: ignore\n/ 1000\n* core.capacity\n)\nschedulable_instruction_length = int(\nmin(\n[\nremaining_to_schedule_instruction_length,\ncontainer_allowed_instruction_length,\ncore.availablity,\n]\n)\n)\nif schedulable_instruction_length &gt; 0:\ncore.execute_process(process, schedulable_instruction_length)\nprocess._current_scheduled_length += (\nschedulable_instruction_length\n)\nscheduled_cpu_time = (\nschedulable_instruction_length / core.capacity\n) * 1000\nif process.__class__.__name__ != \"vPacketHandler\":\nprocess.container.cpu.distribute(  # type: ignore\nprocess, scheduled_cpu_time\n)\nLOGGER.debug(\nf\"{simulation.now:0.2f}:\\tvCPU {self.label} scheduled all process within the queue.\"\n)\nself._process_scheduler = None  # type: ignore\nif self.process_scheduler is None:\nself._process_scheduler = Actor(\nat=simulation.now,\naction=_schedule_process,\nlabel=f\"vCPU {self.label} Schedule vProcess\",\npriority=CPU_SCHEDULE_PROCESS,\n)\n@property\ndef ipc(self) -&gt; Union[int, float]:\n\"\"\"return the IPC of the cpu.\"\"\"\nreturn self._ipc\n@property\ndef frequency(self) -&gt; Union[int, float]:\n\"\"\"return the frequency of the cpu.\"\"\"\nreturn self._frequency\n@property\ndef num_cores(self) -&gt; int:\n\"\"\"return the number of cores of the cpu.\"\"\"\nreturn self._num_cores\n@property\ndef single_core_capacity(self) -&gt; Union[int, float]:\n\"\"\"return the single core capacity of the cpu.\"\"\"\nreturn (self.ipc * self.frequency) / simulation.cpu_acceleration\n@property\ndef cpu_cores(self) -&gt; List[vCPUCore]:\n\"\"\"return the cpu cores of the cpu.\"\"\"\nreturn self._cpu_cores\n@property\ndef capacity(self) -&gt; Union[int, float]:\n\"\"\"return the capacity of the cpu.\"\"\"\nreturn sum([core.capacity for core in self.cpu_cores])\n@property\ndef availablity(self) -&gt; Union[int, float]:\n\"\"\"return the availablity of the cpu.\"\"\"\nreturn sum([core.availablity for core in self.cpu_cores])\n@property\ndef utilization(self) -&gt; Union[int, float]:\n\"\"\"return the utilization of the cpu.\"\"\"\nreturn (self.capacity - self.availablity) / self.capacity * 100\ndef utilization_in_past(self, interval: Union[int, float]) -&gt; Union[int, float]:\n\"\"\"return the utilization of the cpu in the past interval.\"\"\"\nreturn (\nsum(\n[\ncore.computational_power.utilization_in_past(interval)\nfor core in self.cpu_cores\n]\n)\n/ self.num_cores\n)\n@property\ndef processes(self) -&gt; List[vProcess]:\n\"\"\"return the processes of the cpu.\"\"\"\nreturn self._processes\n@property\ndef process_scheduler(self) -&gt; Actor:\n\"\"\"return the process scheduler of the cpu, if it is runing at the moment.\"\"\"\nreturn self._process_scheduler\n@property\ndef tdp(self) -&gt; Union[int, float]:\n\"\"\"return the TDP of the cpu.\"\"\"\nreturn self._tdp\n</code></pre>"},{"location":"api/physical_component/v_cpu/#PyCloudSim.entity.v_cpu.vCPU.availablity","title":"<code>availablity: Union[int, float]</code>  <code>property</code>","text":"<p>return the availablity of the cpu.</p>"},{"location":"api/physical_component/v_cpu/#PyCloudSim.entity.v_cpu.vCPU.capacity","title":"<code>capacity: Union[int, float]</code>  <code>property</code>","text":"<p>return the capacity of the cpu.</p>"},{"location":"api/physical_component/v_cpu/#PyCloudSim.entity.v_cpu.vCPU.cpu_cores","title":"<code>cpu_cores: List[vCPUCore]</code>  <code>property</code>","text":"<p>return the cpu cores of the cpu.</p>"},{"location":"api/physical_component/v_cpu/#PyCloudSim.entity.v_cpu.vCPU.frequency","title":"<code>frequency: Union[int, float]</code>  <code>property</code>","text":"<p>return the frequency of the cpu.</p>"},{"location":"api/physical_component/v_cpu/#PyCloudSim.entity.v_cpu.vCPU.ipc","title":"<code>ipc: Union[int, float]</code>  <code>property</code>","text":"<p>return the IPC of the cpu.</p>"},{"location":"api/physical_component/v_cpu/#PyCloudSim.entity.v_cpu.vCPU.num_cores","title":"<code>num_cores: int</code>  <code>property</code>","text":"<p>return the number of cores of the cpu.</p>"},{"location":"api/physical_component/v_cpu/#PyCloudSim.entity.v_cpu.vCPU.process_scheduler","title":"<code>process_scheduler: Actor</code>  <code>property</code>","text":"<p>return the process scheduler of the cpu, if it is runing at the moment.</p>"},{"location":"api/physical_component/v_cpu/#PyCloudSim.entity.v_cpu.vCPU.processes","title":"<code>processes: List[vProcess]</code>  <code>property</code>","text":"<p>return the processes of the cpu.</p>"},{"location":"api/physical_component/v_cpu/#PyCloudSim.entity.v_cpu.vCPU.single_core_capacity","title":"<code>single_core_capacity: Union[int, float]</code>  <code>property</code>","text":"<p>return the single core capacity of the cpu.</p>"},{"location":"api/physical_component/v_cpu/#PyCloudSim.entity.v_cpu.vCPU.tdp","title":"<code>tdp: Union[int, float]</code>  <code>property</code>","text":"<p>return the TDP of the cpu.</p>"},{"location":"api/physical_component/v_cpu/#PyCloudSim.entity.v_cpu.vCPU.utilization","title":"<code>utilization: Union[int, float]</code>  <code>property</code>","text":"<p>return the utilization of the cpu.</p>"},{"location":"api/physical_component/v_cpu/#PyCloudSim.entity.v_cpu.vCPU.__init__","title":"<code>__init__(ipc, frequency, num_cores, tdp=50, at=simulation.now, after=None, label=None)</code>","text":"<p>Creates a new vCPU.</p> <p>Parameters:</p> Name Type Description Default <code>ipc</code> <code>Union[int, float]</code> <p>instructions per cycle.</p> required <code>frequency</code> <code>Union[int, float]</code> <p>the frequency of cpu core.</p> required <code>num_cores</code> <code>int</code> <p>the number of cores in the cpu.</p> required <code>tdp</code> <code>Union[int, float]</code> <p>the TDP, aka power consumption of the cpu. Defaults to 50W.</p> <code>50</code> <code>at</code> <code>Union[int, float, Callable]</code> <p>when the cpu should be created. Defaults to simulation.now.</p> <code>simulation.now</code> <code>after</code> <code>Optional[Entity | List[Entity]]</code> <p>the entity that must be terminated before the cpu can be created. Defaults to None.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>short description of the cpu. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_cpu.py</code> <pre><code>def __init__(\nself,\nipc: Union[int, float],\nfrequency: Union[int, float],\nnum_cores: int,\ntdp: Union[int, float] = 50,\nat: Union[int, float, Callable] = simulation.now,\nafter: Optional[Entity | List[Entity]] = None,\nlabel: Optional[str] = None,\n):\n\"\"\"Creates a new vCPU.\n    Args:\n        ipc (Union[int, float]): instructions per cycle.\n        frequency (Union[int, float]): the frequency of cpu core.\n        num_cores (int): the number of cores in the cpu.\n        tdp (Union[int, float], optional): the TDP, aka power consumption of the cpu. Defaults to 50W.\n        at (Union[int, float, Callable], optional): when the cpu should be created. Defaults to simulation.now.\n        after (Optional[Entity  |  List[Entity]], optional): the entity that must be terminated before the cpu can be created. Defaults to None.\n        label (Optional[str], optional): short description of the cpu. Defaults to None.\n    \"\"\"\nsuper().__init__(at, after, label)\nself._ipc = ipc\nself._frequency = frequency * 1000000\nself._num_cores = num_cores\ncpu_cores = [\nvCPUCore(\nipc=self.ipc,\nfrequency=self.frequency,\ncpu=self,\nlabel=f\"{self.label}-Core-{i}\",\n)\nfor i in range(num_cores)\n]\nself._cpu_cores = cpu_cores\nself._tdp = tdp\nself._processes = list()\nself._process_scheduler: Actor = None  # type: ignore\nsimulation.CPUS.append(self)\n</code></pre>"},{"location":"api/physical_component/v_cpu/#PyCloudSim.entity.v_cpu.vCPU.cache_process","title":"<code>cache_process(process)</code>","text":"<p>Cache a process in the cpu and call schedule_process().</p> Source code in <code>PyCloudSim\\entity\\v_cpu.py</code> <pre><code>def cache_process(self, process: vProcess):\n\"\"\"Cache a process in the cpu and call schedule_process().\"\"\"\nif not process.cached:\nself.processes.append(process)\nprocess._cpu_id = self.id\nprocess.status.append(CACHED)\nself.schedule_process()\n</code></pre>"},{"location":"api/physical_component/v_cpu/#PyCloudSim.entity.v_cpu.vCPU.creation","title":"<code>creation()</code>","text":"<p>Creates the cpu.</p> Source code in <code>PyCloudSim\\entity\\v_cpu.py</code> <pre><code>def creation(self):\n\"\"\"Creates the cpu.\"\"\"\nreturn super().creation()\n</code></pre>"},{"location":"api/physical_component/v_cpu/#PyCloudSim.entity.v_cpu.vCPU.schedule_process","title":"<code>schedule_process()</code>","text":"<p>shcedule processes in the cpu queue.</p> Source code in <code>PyCloudSim\\entity\\v_cpu.py</code> <pre><code>def schedule_process(self):\n\"\"\"shcedule processes in the cpu queue.\"\"\"\ndef _schedule_process():\nLOGGER.debug(\nf\"{simulation.now:0.2f}:\\tvCPU {self.label} is scheduling ... {len(self.processes)} processes\"\n)\nself.processes.sort(key=lambda process: process.priority)\nfor process in self.processes:\n# if not process.executing and not process.terminated:\nfor core in self.cpu_cores:\nremaining_to_schedule_instruction_length = (\nprocess.remaining - process.current_scheduled_length\n)\nif process.__class__.__name__ == \"vPacketHandler\":\ncontainer_allowed_instruction_length = inf\nelse:\ncontainer_allowed_instruction_length = (\nprocess.container.cpu.available_quantity  # type: ignore\n/ 1000\n* core.capacity\n)\nschedulable_instruction_length = int(\nmin(\n[\nremaining_to_schedule_instruction_length,\ncontainer_allowed_instruction_length,\ncore.availablity,\n]\n)\n)\nif schedulable_instruction_length &gt; 0:\ncore.execute_process(process, schedulable_instruction_length)\nprocess._current_scheduled_length += (\nschedulable_instruction_length\n)\nscheduled_cpu_time = (\nschedulable_instruction_length / core.capacity\n) * 1000\nif process.__class__.__name__ != \"vPacketHandler\":\nprocess.container.cpu.distribute(  # type: ignore\nprocess, scheduled_cpu_time\n)\nLOGGER.debug(\nf\"{simulation.now:0.2f}:\\tvCPU {self.label} scheduled all process within the queue.\"\n)\nself._process_scheduler = None  # type: ignore\nif self.process_scheduler is None:\nself._process_scheduler = Actor(\nat=simulation.now,\naction=_schedule_process,\nlabel=f\"vCPU {self.label} Schedule vProcess\",\npriority=CPU_SCHEDULE_PROCESS,\n)\n</code></pre>"},{"location":"api/physical_component/v_cpu/#PyCloudSim.entity.v_cpu.vCPU.termination","title":"<code>termination()</code>","text":"<p>Terminates the cpu.</p> Source code in <code>PyCloudSim\\entity\\v_cpu.py</code> <pre><code>def termination(self):\n\"\"\"Terminates the cpu.\"\"\"\nreturn super().termination()\n</code></pre>"},{"location":"api/physical_component/v_cpu/#PyCloudSim.entity.v_cpu.vCPU.utilization_in_past","title":"<code>utilization_in_past(interval)</code>","text":"<p>return the utilization of the cpu in the past interval.</p> Source code in <code>PyCloudSim\\entity\\v_cpu.py</code> <pre><code>def utilization_in_past(self, interval: Union[int, float]) -&gt; Union[int, float]:\n\"\"\"return the utilization of the cpu in the past interval.\"\"\"\nreturn (\nsum(\n[\ncore.computational_power.utilization_in_past(interval)\nfor core in self.cpu_cores\n]\n)\n/ self.num_cores\n)\n</code></pre>"},{"location":"api/physical_component/v_cpu_core/","title":"vCPUCore","text":"<p>The class \"vCPUCore\" serves as the implementation of CPU cores within the simulation. It includes two mandatory attributes: frequency and instructions-per-cycle, which determine the computational capacity of the core. The computational capacity is represented as a \"Resource\" object from the \"Akatosh\" library, enabling withdrawal or return of the available amount during the simulation. The \"vCPUCore\" is responsible for allocating the computational power to the assigned processes and reclaiming the distributed amount once the execution of the assigned process is complete. In the event that the \"vCPUCore\" is arbitrarily powered off during the simulation, all processes currently in execution will be considered as failed.</p> <p>         Bases: <code>PhysicalComponent</code></p> Source code in <code>PyCloudSim\\entity\\v_cpu_core.py</code> <pre><code>class vCPUCore(PhysicalComponent):\n_ipc: Union[int, float]\n_frequency: Union[int, float]\n_computational_power: Resource\n_processes: List[vProcess]\ndef __init__(\nself,\nipc: Union[int, float],\nfrequency: Union[int, float],\ncpu: vCPU,\nat: Union[int, float, Callable] = simulation.now,\nafter: Optional[Entity | List[Entity]] = None,\nlabel: Optional[str] = None,\n):\n\"\"\"Creates a new vCPUCore.\n        Args:\n            ipc (Union[int, float]): instructions per cycle.\n            frequency (Union[int, float]): the frequency of cpu core.\n            cpu (vCPU): the cpu that this core belongs to.\n            at (Union[int, float, Callable], optional): when the cpu core should be created. Defaults to simulation.now.\n            after (Optional[Entity  |  List[Entity]], optional): the entity that must be terminated before the cpu core is created. Defaults to None.\n            label (Optional[str], optional): the short description of the cpu core. Defaults to None.\n        \"\"\"\nsuper().__init__(at, after, label)\nself._ipc = ipc\nself._frequency = frequency\nself._cpu_id = cpu.id\nself._computational_power = Resource(\ncapacity=ipc * frequency / simulation.cpu_acceleration,\nlabel=f\"{self.__class__.__name__} {self.label} Capacity\",\n)\nself._processes = list()\nsimulation.CPU_CORES.append(self)\ndef creation(self):\n\"\"\"Creates the cpu core.\"\"\"\nreturn super().creation()\ndef termination(self):\n\"\"\"Terminates the cpu core.\"\"\"\nreturn super().termination()\ndef _power_on(self):\n\"\"\"Power on the cpu core.\"\"\"\nsuper()._power_on()\ndef _power_off(self):\n\"\"\"Power off the cpu core\"\"\"\nsuper()._power_off()\ndef execute_process(self, process: vProcess, length: int):\n\"\"\"Executes a process for a given length.\n        Args:\n            process (vProcess): the process to be executed.\n            length (int): the length of instructions to be executed.\n        \"\"\"\nself.processes.append(process)\nself.computational_power.distribute(process, length)\nexecution_time = length / self.computational_power.capacity\nprocess.executing_cores.append(self)\nprocess.status.append(EXECUTING)\nLOGGER.debug(\nf\"{simulation.now:0.2f}:\\tvCPUCore {self.label} is executing {length} instructions for {process .__class__.__name__} {process.label}, {self.availablity} Capaccity left.\"\n)\ndef _clear_executed_instructions():\nif not process.failed:\nself.computational_power.release(process, length)\nprocess._progress += length\nprocess._current_scheduled_length -= length\nself.processes.remove(process)\nprocess.executing_cores.remove(self)\nprocess.status.remove(EXECUTING)\ncpu_time = length / self.computational_power.capacity * 1000\nif process.__class__.__name__ != \"vPacketHandler\":\nprocess.container.cpu.release(process, cpu_time) #type: ignore\nLOGGER.debug(\nf\"{simulation.now:0.2f}:\\tvCPUCore {self.label} executed {length} instructions for {process .__class__.__name__} {process.label}, {self.availablity} Capacity left.\"\n)\nif process.__class__.__name__ != \"vPacketHandler\":\nLOGGER.debug(\nf\"{simulation.now:0.2f}:\\tvProcess {process.label} progress: {process.progress/process.length}, released {cpu_time} CPU Time of vContainer {process.container.label}, current CPU Time capacity {process.container.cpu.available_quantity}.\" #type: ignore\n)\nelse:\nLOGGER.debug(\nf\"{simulation.now:0.2f}:\\tvPacketHandler {process.label} progress: {process.progress/process.length}, released {cpu_time} CPU Time of vHost {process.host.label}, current CPU Time capacity {process.host.cpu.availablity}.\"\n)\nActor(\nat=simulation.now,\naction=process.complete,\nlabel=f\"vProcess {process.label} Clear Executed Instructions\",\npriority=PROCESS_COMPLETE_CHECK,\n)\nActor(\nat=simulation.now,\naction=self.cpu.schedule_process,\nlabel=f\"vCPU {self.cpu.label} Schedule Processes\",\npriority=CPU_SCHEDULE_PROCESS,\n)\nActor(\nat=simulation.now + execution_time,\naction=_clear_executed_instructions,\nlabel=f\"vCPUCore {self.label} Clear Executed Instructions\",\npriority=CORE_CLEAR_INSTRUCTIONS,\n)\n@property\ndef ipc(self) -&gt; Union[int, float]:\n\"\"\"returns the instructions per cycle of the cpu core.\"\"\"\nreturn self._ipc\n@property\ndef frequency(self) -&gt; Union[int, float]:\n\"\"\"returns the frequency of the cpu core.\"\"\"\nreturn self._frequency\n@property\ndef computational_power(self) -&gt; Resource:\n\"\"\"returns the computational power ( as Resource ) of the cpu core.\"\"\"\nreturn self._computational_power\n@property\ndef capacity(self) -&gt; Union[int, float]:\n\"\"\"returns the capacity of the cpu core, aka how many instructions can be executed per second.\"\"\"\nreturn self.computational_power.capacity\n@property\ndef availablity(self) -&gt; Union[int, float]:\n\"\"\"returns the availablity of the cpu core in number of instructions.\"\"\"\nreturn self.computational_power.available_quantity\n@property\ndef utilization(self) -&gt; Union[int, float]:\n\"\"\"returns the utilization of the cpu core in percentage.\"\"\"\nreturn self.computational_power.utilization * 100\n@property\ndef processes(self) -&gt; List[vProcess]:\n\"\"\"returns the processes that are currently executing on the cpu core.\"\"\"\nreturn self._processes\n@property\ndef cpu(self) -&gt; vCPU:\n\"\"\"returns the cpu that this cpu core belongs to.\"\"\"\nfor cpu in simulation.CPUS:\nif cpu.id == self._cpu_id:\nreturn cpu\nraise RuntimeError(f\"vCPUCore {self.label} can not found its associated vCPU.\")\n</code></pre>"},{"location":"api/physical_component/v_cpu_core/#PyCloudSim.entity.v_cpu_core.vCPUCore.availablity","title":"<code>availablity: Union[int, float]</code>  <code>property</code>","text":"<p>returns the availablity of the cpu core in number of instructions.</p>"},{"location":"api/physical_component/v_cpu_core/#PyCloudSim.entity.v_cpu_core.vCPUCore.capacity","title":"<code>capacity: Union[int, float]</code>  <code>property</code>","text":"<p>returns the capacity of the cpu core, aka how many instructions can be executed per second.</p>"},{"location":"api/physical_component/v_cpu_core/#PyCloudSim.entity.v_cpu_core.vCPUCore.computational_power","title":"<code>computational_power: Resource</code>  <code>property</code>","text":"<p>returns the computational power ( as Resource ) of the cpu core.</p>"},{"location":"api/physical_component/v_cpu_core/#PyCloudSim.entity.v_cpu_core.vCPUCore.cpu","title":"<code>cpu: vCPU</code>  <code>property</code>","text":"<p>returns the cpu that this cpu core belongs to.</p>"},{"location":"api/physical_component/v_cpu_core/#PyCloudSim.entity.v_cpu_core.vCPUCore.frequency","title":"<code>frequency: Union[int, float]</code>  <code>property</code>","text":"<p>returns the frequency of the cpu core.</p>"},{"location":"api/physical_component/v_cpu_core/#PyCloudSim.entity.v_cpu_core.vCPUCore.ipc","title":"<code>ipc: Union[int, float]</code>  <code>property</code>","text":"<p>returns the instructions per cycle of the cpu core.</p>"},{"location":"api/physical_component/v_cpu_core/#PyCloudSim.entity.v_cpu_core.vCPUCore.processes","title":"<code>processes: List[vProcess]</code>  <code>property</code>","text":"<p>returns the processes that are currently executing on the cpu core.</p>"},{"location":"api/physical_component/v_cpu_core/#PyCloudSim.entity.v_cpu_core.vCPUCore.utilization","title":"<code>utilization: Union[int, float]</code>  <code>property</code>","text":"<p>returns the utilization of the cpu core in percentage.</p>"},{"location":"api/physical_component/v_cpu_core/#PyCloudSim.entity.v_cpu_core.vCPUCore.__init__","title":"<code>__init__(ipc, frequency, cpu, at=simulation.now, after=None, label=None)</code>","text":"<p>Creates a new vCPUCore.</p> <p>Parameters:</p> Name Type Description Default <code>ipc</code> <code>Union[int, float]</code> <p>instructions per cycle.</p> required <code>frequency</code> <code>Union[int, float]</code> <p>the frequency of cpu core.</p> required <code>cpu</code> <code>vCPU</code> <p>the cpu that this core belongs to.</p> required <code>at</code> <code>Union[int, float, Callable]</code> <p>when the cpu core should be created. Defaults to simulation.now.</p> <code>simulation.now</code> <code>after</code> <code>Optional[Entity | List[Entity]]</code> <p>the entity that must be terminated before the cpu core is created. Defaults to None.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>the short description of the cpu core. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_cpu_core.py</code> <pre><code>def __init__(\nself,\nipc: Union[int, float],\nfrequency: Union[int, float],\ncpu: vCPU,\nat: Union[int, float, Callable] = simulation.now,\nafter: Optional[Entity | List[Entity]] = None,\nlabel: Optional[str] = None,\n):\n\"\"\"Creates a new vCPUCore.\n    Args:\n        ipc (Union[int, float]): instructions per cycle.\n        frequency (Union[int, float]): the frequency of cpu core.\n        cpu (vCPU): the cpu that this core belongs to.\n        at (Union[int, float, Callable], optional): when the cpu core should be created. Defaults to simulation.now.\n        after (Optional[Entity  |  List[Entity]], optional): the entity that must be terminated before the cpu core is created. Defaults to None.\n        label (Optional[str], optional): the short description of the cpu core. Defaults to None.\n    \"\"\"\nsuper().__init__(at, after, label)\nself._ipc = ipc\nself._frequency = frequency\nself._cpu_id = cpu.id\nself._computational_power = Resource(\ncapacity=ipc * frequency / simulation.cpu_acceleration,\nlabel=f\"{self.__class__.__name__} {self.label} Capacity\",\n)\nself._processes = list()\nsimulation.CPU_CORES.append(self)\n</code></pre>"},{"location":"api/physical_component/v_cpu_core/#PyCloudSim.entity.v_cpu_core.vCPUCore.creation","title":"<code>creation()</code>","text":"<p>Creates the cpu core.</p> Source code in <code>PyCloudSim\\entity\\v_cpu_core.py</code> <pre><code>def creation(self):\n\"\"\"Creates the cpu core.\"\"\"\nreturn super().creation()\n</code></pre>"},{"location":"api/physical_component/v_cpu_core/#PyCloudSim.entity.v_cpu_core.vCPUCore.execute_process","title":"<code>execute_process(process, length)</code>","text":"<p>Executes a process for a given length.</p> <p>Parameters:</p> Name Type Description Default <code>process</code> <code>vProcess</code> <p>the process to be executed.</p> required <code>length</code> <code>int</code> <p>the length of instructions to be executed.</p> required Source code in <code>PyCloudSim\\entity\\v_cpu_core.py</code> <pre><code>def execute_process(self, process: vProcess, length: int):\n\"\"\"Executes a process for a given length.\n    Args:\n        process (vProcess): the process to be executed.\n        length (int): the length of instructions to be executed.\n    \"\"\"\nself.processes.append(process)\nself.computational_power.distribute(process, length)\nexecution_time = length / self.computational_power.capacity\nprocess.executing_cores.append(self)\nprocess.status.append(EXECUTING)\nLOGGER.debug(\nf\"{simulation.now:0.2f}:\\tvCPUCore {self.label} is executing {length} instructions for {process .__class__.__name__} {process.label}, {self.availablity} Capaccity left.\"\n)\ndef _clear_executed_instructions():\nif not process.failed:\nself.computational_power.release(process, length)\nprocess._progress += length\nprocess._current_scheduled_length -= length\nself.processes.remove(process)\nprocess.executing_cores.remove(self)\nprocess.status.remove(EXECUTING)\ncpu_time = length / self.computational_power.capacity * 1000\nif process.__class__.__name__ != \"vPacketHandler\":\nprocess.container.cpu.release(process, cpu_time) #type: ignore\nLOGGER.debug(\nf\"{simulation.now:0.2f}:\\tvCPUCore {self.label} executed {length} instructions for {process .__class__.__name__} {process.label}, {self.availablity} Capacity left.\"\n)\nif process.__class__.__name__ != \"vPacketHandler\":\nLOGGER.debug(\nf\"{simulation.now:0.2f}:\\tvProcess {process.label} progress: {process.progress/process.length}, released {cpu_time} CPU Time of vContainer {process.container.label}, current CPU Time capacity {process.container.cpu.available_quantity}.\" #type: ignore\n)\nelse:\nLOGGER.debug(\nf\"{simulation.now:0.2f}:\\tvPacketHandler {process.label} progress: {process.progress/process.length}, released {cpu_time} CPU Time of vHost {process.host.label}, current CPU Time capacity {process.host.cpu.availablity}.\"\n)\nActor(\nat=simulation.now,\naction=process.complete,\nlabel=f\"vProcess {process.label} Clear Executed Instructions\",\npriority=PROCESS_COMPLETE_CHECK,\n)\nActor(\nat=simulation.now,\naction=self.cpu.schedule_process,\nlabel=f\"vCPU {self.cpu.label} Schedule Processes\",\npriority=CPU_SCHEDULE_PROCESS,\n)\nActor(\nat=simulation.now + execution_time,\naction=_clear_executed_instructions,\nlabel=f\"vCPUCore {self.label} Clear Executed Instructions\",\npriority=CORE_CLEAR_INSTRUCTIONS,\n)\n</code></pre>"},{"location":"api/physical_component/v_cpu_core/#PyCloudSim.entity.v_cpu_core.vCPUCore.termination","title":"<code>termination()</code>","text":"<p>Terminates the cpu core.</p> Source code in <code>PyCloudSim\\entity\\v_cpu_core.py</code> <pre><code>def termination(self):\n\"\"\"Terminates the cpu core.\"\"\"\nreturn super().termination()\n</code></pre>"},{"location":"api/physical_component/v_nic/","title":"vNIC","text":"<p>The class \"vNIC\" serves as the implementation of the network interface card in the simulation. It includes a queue specifically designed to store \"vPacket\" objects and has the capability to establish connections with other \"vNIC\" instances. The \"vNIC\" class is equipped with two resources: uplink bandwidth and downlink bandwidth. These resources are allocated to the transmission and reception of \"vPacket\" objects respectively. The transmission and reception functionalities of \"vPacket\" are implemented as member functions within the class. Upon receiving a \"vPacket\", a specialized \"vProcess\" called PacketHandler is created to simulate the decoding process and the associated processing delay. If there is insufficient uplink or downlink bandwidth available, the \"vPacket\" will be kept in the queue until the necessary resources become available.</p> <p>         Bases: <code>PhysicalComponent</code></p> Source code in <code>PyCloudSim\\entity\\v_nic.py</code> <pre><code>class vNIC(PhysicalComponent):\ndef __init__(\nself,\nhost: Union[vHost, vRouter, vSwitch, vGateway],\nconnected_to: Optional[Union[vHost, vRouter, vSwitch, vGateway]] = None,\nbandwidth: int = 1000,\ndelay: float = 0.02,\nip: Optional[IPv4Address] = None,\nat: Union[int, float, Callable] = simulation.now,\nafter: Optional[Entity | List[Entity]] = None,\nlabel: Optional[str] = None,\n):\n\"\"\"Create a vNIC object.\n        Args:\n            host (Union[vHost, vRouter, vSwitch, vGateway]): the host that the vNIC is attached to.\n            connected_to (Optional[Union[vHost, vRouter, vSwitch, vGateway]], optional): the device that the vNIC is connected to. Defaults to None.\n            bandwidth (int, optional): the bandwidth in MBps of the vNIC. Defaults to 1000.\n            delay (float, optional): the processing delay of the vNIC. Defaults to 0.02.\n            ip (Optional[IPv4Address], optional): the IP address of the vNIC. Defaults to None.\n            at (Union[int, float, Callable], optional): same as Entity. Defaults to simulation.now.\n            after (Optional[Entity  |  List[Entity]], optional): same as Entity. Defaults to None.\n            label (Optional[str], optional): Same as Entity. Defaults to None.\n        \"\"\"\nsuper().__init__(at, after, label)\nself._host = host\nself._connected_to = connected_to\nself._bandwidth = MiB(bandwidth)\nself._delay = delay\nself._ip = ip\nif host.__class__.__name__ == \"vHost\" or host.__class__.__name__ == \"vRouter\":\nself._type = \"Interface\"\nelse:\nself._type = \"Port\"\nself._uplink = Resource(\ncapacity=self.bandwidth, label=f\"vNIC {self.label} Uplink\"\n)\nself._downlink = Resource(\ncapacity=self.bandwidth, label=f\"vNIC {self.label} Downlink\"\n)\nsimulation.NICS.append(self)\ndef creation(self):\n\"\"\"Creation process of the vNIC\"\"\"\nreturn super().creation()\ndef termination(self):\n\"\"\"Termination process of the vNIC\"\"\"\nreturn super().termination()\ndef _power_on(self):\n\"\"\"Power on the vNIC\"\"\"\nreturn super()._power_on()\ndef _power_off(self):\n\"\"\"Power off the vNIC\"\"\"\nreturn super()._power_off()\ndef receive_packet(self, packet: vPacket, delay: float = 0.0):\n\"\"\"Rceive a vPacket, the vPacket will be dropped if the attached host does not have enough RAM.\n        Args:\n            packet (vPacket): the vPacket to be recevived.\n            delay (float, optional): the delay for receiving this vPacket in term of transmitting time. Defaults to 0.0.\n        \"\"\"\nself.uplink.distribute(packet, packet.size)\nLOGGER.debug(\nf\"{simulation.now:0.2f}:\\tvPacket {packet.label} is using {packet.size}/{self.uplink.available_quantity}/{self.uplink.capacity} bytes of vNIC {self.label} uplink.\"\n)\ndef _received_packet():\nself.uplink.release(packet)\npacket.status.remove(TRANSMITTING)\npacket.status.remove(DECODED)\ntry:\nself.host.cache_packet(packet)\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\tvPacket {packet.label} is received by {self.host.__class__.__name__} {self.host.label}\"\n)\nexcept:\npacket.drop()\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\tvPacket {packet.label} is droped by {self.host.__class__.__name__} {self.host.label}\"\n)\nActor(\nat=simulation.now + delay,\naction=_received_packet,\nlabel=f\"vNIC {self.label} Receive Packet\",\npriority=CORE_EXECUTE_PROCESS,\n)\ndef send_packet(self, packet: vPacket, delay: float = 0.0):\n\"\"\"Send a vPacket.\n        Args:\n            packet (vPacket): the vPacket to be sent.\n            delay (float, optional): the delay for sending this packet in term of transmitting time. Defaults to 0.0.\n        \"\"\"\nself.downlink.distribute(packet, packet.size)\nLOGGER.debug(\nf\"{simulation.now:0.2f}:\\tvPacket {packet.label} is using {packet.size}/{self.downlink.available_quantity}/{self.downlink.capacity} bytes of vNIC {self.label} downlink.\"\n)\nself.host.packets.remove(packet)\npacket.status.append(TRANSMITTING)\npacket.status.remove(QUEUED)\ndef _sent_packet():\nself.downlink.release(packet)\nif self.host.__class__.__name__ == \"vGateway\":\npass\nelse:\nself.host.ram.release(packet)  # type: ignore\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\tvPacket {packet.label} is sent by {self.host.__class__.__name__} {self.host.label}\"\n)\nActor(\nat=simulation.now,\naction=self.host.send_packets,\nlabel=f\"{self.__class__.__name__} {self.label} Send Packets\",\npriority=HOST_SCHEDULE_PACKET,\n)\nActor(\nat=simulation.now + delay,\naction=_sent_packet,\nlabel=f\"vNIC {self.label} Send Packet\",\npriority=CORE_EXECUTE_PROCESS,\n)\n@property\ndef host(self) -&gt; Union[vHost, vRouter, vSwitch, vGateway]:\n\"\"\"The attached host.\"\"\"\nreturn self._host\n@property\ndef connected_to(self) -&gt; Optional[Union[vHost, vRouter, vSwitch, vGateway]]:\n\"\"\"The connected device.\"\"\"\nreturn self._connected_to\n@property\ndef bandwidth(self) -&gt; float:\n\"\"\"The bandwidth of the vNIC in MB/s.\"\"\"\nreturn self._bandwidth.bytes\n@property\ndef delay(self) -&gt; float:\nreturn self._delay\n@property\ndef ip(self) -&gt; Optional[IPv4Address]:\n\"\"\"The IP address of the vNIC.\"\"\"\nif self.type == \"Interface\":\nreturn self._ip\nelse:\nreturn None\n@property\ndef type(self) -&gt; str:\n\"\"\"The type of the vNIC.\"\"\"\nreturn self._type\n@property\ndef uplink(self) -&gt; Resource:\n\"\"\"The uplink of the vNIC.\"\"\"\nreturn self._uplink\n@property\ndef downlink(self) -&gt; Resource:\n\"\"\"The downlink of the vNIC.\"\"\"\nreturn self._downlink\ndef downlink_utilization(self, inertval: float = 0.1) -&gt; float:\n\"\"\"The downlink utilization of the vNIC in percentage.\"\"\"\nreturn self.downlink.utilization_in_past(inertval) * 100\ndef uplink_utilization(self, inertval: float = 0.1) -&gt; float:\n\"\"\"The uplink utilization of the vNIC in percentage.\"\"\"\nreturn self.uplink.utilization_in_past(inertval) * 100\n</code></pre>"},{"location":"api/physical_component/v_nic/#PyCloudSim.entity.v_nic.vNIC.bandwidth","title":"<code>bandwidth: float</code>  <code>property</code>","text":"<p>The bandwidth of the vNIC in MB/s.</p>"},{"location":"api/physical_component/v_nic/#PyCloudSim.entity.v_nic.vNIC.connected_to","title":"<code>connected_to: Optional[Union[vHost, vRouter, vSwitch, vGateway]]</code>  <code>property</code>","text":"<p>The connected device.</p>"},{"location":"api/physical_component/v_nic/#PyCloudSim.entity.v_nic.vNIC.downlink","title":"<code>downlink: Resource</code>  <code>property</code>","text":"<p>The downlink of the vNIC.</p>"},{"location":"api/physical_component/v_nic/#PyCloudSim.entity.v_nic.vNIC.host","title":"<code>host: Union[vHost, vRouter, vSwitch, vGateway]</code>  <code>property</code>","text":"<p>The attached host.</p>"},{"location":"api/physical_component/v_nic/#PyCloudSim.entity.v_nic.vNIC.ip","title":"<code>ip: Optional[IPv4Address]</code>  <code>property</code>","text":"<p>The IP address of the vNIC.</p>"},{"location":"api/physical_component/v_nic/#PyCloudSim.entity.v_nic.vNIC.type","title":"<code>type: str</code>  <code>property</code>","text":"<p>The type of the vNIC.</p>"},{"location":"api/physical_component/v_nic/#PyCloudSim.entity.v_nic.vNIC.uplink","title":"<code>uplink: Resource</code>  <code>property</code>","text":"<p>The uplink of the vNIC.</p>"},{"location":"api/physical_component/v_nic/#PyCloudSim.entity.v_nic.vNIC.__init__","title":"<code>__init__(host, connected_to=None, bandwidth=1000, delay=0.02, ip=None, at=simulation.now, after=None, label=None)</code>","text":"<p>Create a vNIC object.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>Union[vHost, vRouter, vSwitch, vGateway]</code> <p>the host that the vNIC is attached to.</p> required <code>connected_to</code> <code>Optional[Union[vHost, vRouter, vSwitch, vGateway]]</code> <p>the device that the vNIC is connected to. Defaults to None.</p> <code>None</code> <code>bandwidth</code> <code>int</code> <p>the bandwidth in MBps of the vNIC. Defaults to 1000.</p> <code>1000</code> <code>delay</code> <code>float</code> <p>the processing delay of the vNIC. Defaults to 0.02.</p> <code>0.02</code> <code>ip</code> <code>Optional[IPv4Address]</code> <p>the IP address of the vNIC. Defaults to None.</p> <code>None</code> <code>at</code> <code>Union[int, float, Callable]</code> <p>same as Entity. Defaults to simulation.now.</p> <code>simulation.now</code> <code>after</code> <code>Optional[Entity | List[Entity]]</code> <p>same as Entity. Defaults to None.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>Same as Entity. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_nic.py</code> <pre><code>def __init__(\nself,\nhost: Union[vHost, vRouter, vSwitch, vGateway],\nconnected_to: Optional[Union[vHost, vRouter, vSwitch, vGateway]] = None,\nbandwidth: int = 1000,\ndelay: float = 0.02,\nip: Optional[IPv4Address] = None,\nat: Union[int, float, Callable] = simulation.now,\nafter: Optional[Entity | List[Entity]] = None,\nlabel: Optional[str] = None,\n):\n\"\"\"Create a vNIC object.\n    Args:\n        host (Union[vHost, vRouter, vSwitch, vGateway]): the host that the vNIC is attached to.\n        connected_to (Optional[Union[vHost, vRouter, vSwitch, vGateway]], optional): the device that the vNIC is connected to. Defaults to None.\n        bandwidth (int, optional): the bandwidth in MBps of the vNIC. Defaults to 1000.\n        delay (float, optional): the processing delay of the vNIC. Defaults to 0.02.\n        ip (Optional[IPv4Address], optional): the IP address of the vNIC. Defaults to None.\n        at (Union[int, float, Callable], optional): same as Entity. Defaults to simulation.now.\n        after (Optional[Entity  |  List[Entity]], optional): same as Entity. Defaults to None.\n        label (Optional[str], optional): Same as Entity. Defaults to None.\n    \"\"\"\nsuper().__init__(at, after, label)\nself._host = host\nself._connected_to = connected_to\nself._bandwidth = MiB(bandwidth)\nself._delay = delay\nself._ip = ip\nif host.__class__.__name__ == \"vHost\" or host.__class__.__name__ == \"vRouter\":\nself._type = \"Interface\"\nelse:\nself._type = \"Port\"\nself._uplink = Resource(\ncapacity=self.bandwidth, label=f\"vNIC {self.label} Uplink\"\n)\nself._downlink = Resource(\ncapacity=self.bandwidth, label=f\"vNIC {self.label} Downlink\"\n)\nsimulation.NICS.append(self)\n</code></pre>"},{"location":"api/physical_component/v_nic/#PyCloudSim.entity.v_nic.vNIC.creation","title":"<code>creation()</code>","text":"<p>Creation process of the vNIC</p> Source code in <code>PyCloudSim\\entity\\v_nic.py</code> <pre><code>def creation(self):\n\"\"\"Creation process of the vNIC\"\"\"\nreturn super().creation()\n</code></pre>"},{"location":"api/physical_component/v_nic/#PyCloudSim.entity.v_nic.vNIC.downlink_utilization","title":"<code>downlink_utilization(inertval=0.1)</code>","text":"<p>The downlink utilization of the vNIC in percentage.</p> Source code in <code>PyCloudSim\\entity\\v_nic.py</code> <pre><code>def downlink_utilization(self, inertval: float = 0.1) -&gt; float:\n\"\"\"The downlink utilization of the vNIC in percentage.\"\"\"\nreturn self.downlink.utilization_in_past(inertval) * 100\n</code></pre>"},{"location":"api/physical_component/v_nic/#PyCloudSim.entity.v_nic.vNIC.receive_packet","title":"<code>receive_packet(packet, delay=0.0)</code>","text":"<p>Rceive a vPacket, the vPacket will be dropped if the attached host does not have enough RAM.</p> <p>Parameters:</p> Name Type Description Default <code>packet</code> <code>vPacket</code> <p>the vPacket to be recevived.</p> required <code>delay</code> <code>float</code> <p>the delay for receiving this vPacket in term of transmitting time. Defaults to 0.0.</p> <code>0.0</code> Source code in <code>PyCloudSim\\entity\\v_nic.py</code> <pre><code>def receive_packet(self, packet: vPacket, delay: float = 0.0):\n\"\"\"Rceive a vPacket, the vPacket will be dropped if the attached host does not have enough RAM.\n    Args:\n        packet (vPacket): the vPacket to be recevived.\n        delay (float, optional): the delay for receiving this vPacket in term of transmitting time. Defaults to 0.0.\n    \"\"\"\nself.uplink.distribute(packet, packet.size)\nLOGGER.debug(\nf\"{simulation.now:0.2f}:\\tvPacket {packet.label} is using {packet.size}/{self.uplink.available_quantity}/{self.uplink.capacity} bytes of vNIC {self.label} uplink.\"\n)\ndef _received_packet():\nself.uplink.release(packet)\npacket.status.remove(TRANSMITTING)\npacket.status.remove(DECODED)\ntry:\nself.host.cache_packet(packet)\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\tvPacket {packet.label} is received by {self.host.__class__.__name__} {self.host.label}\"\n)\nexcept:\npacket.drop()\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\tvPacket {packet.label} is droped by {self.host.__class__.__name__} {self.host.label}\"\n)\nActor(\nat=simulation.now + delay,\naction=_received_packet,\nlabel=f\"vNIC {self.label} Receive Packet\",\npriority=CORE_EXECUTE_PROCESS,\n)\n</code></pre>"},{"location":"api/physical_component/v_nic/#PyCloudSim.entity.v_nic.vNIC.send_packet","title":"<code>send_packet(packet, delay=0.0)</code>","text":"<p>Send a vPacket.</p> <p>Parameters:</p> Name Type Description Default <code>packet</code> <code>vPacket</code> <p>the vPacket to be sent.</p> required <code>delay</code> <code>float</code> <p>the delay for sending this packet in term of transmitting time. Defaults to 0.0.</p> <code>0.0</code> Source code in <code>PyCloudSim\\entity\\v_nic.py</code> <pre><code>def send_packet(self, packet: vPacket, delay: float = 0.0):\n\"\"\"Send a vPacket.\n    Args:\n        packet (vPacket): the vPacket to be sent.\n        delay (float, optional): the delay for sending this packet in term of transmitting time. Defaults to 0.0.\n    \"\"\"\nself.downlink.distribute(packet, packet.size)\nLOGGER.debug(\nf\"{simulation.now:0.2f}:\\tvPacket {packet.label} is using {packet.size}/{self.downlink.available_quantity}/{self.downlink.capacity} bytes of vNIC {self.label} downlink.\"\n)\nself.host.packets.remove(packet)\npacket.status.append(TRANSMITTING)\npacket.status.remove(QUEUED)\ndef _sent_packet():\nself.downlink.release(packet)\nif self.host.__class__.__name__ == \"vGateway\":\npass\nelse:\nself.host.ram.release(packet)  # type: ignore\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\tvPacket {packet.label} is sent by {self.host.__class__.__name__} {self.host.label}\"\n)\nActor(\nat=simulation.now,\naction=self.host.send_packets,\nlabel=f\"{self.__class__.__name__} {self.label} Send Packets\",\npriority=HOST_SCHEDULE_PACKET,\n)\nActor(\nat=simulation.now + delay,\naction=_sent_packet,\nlabel=f\"vNIC {self.label} Send Packet\",\npriority=CORE_EXECUTE_PROCESS,\n)\n</code></pre>"},{"location":"api/physical_component/v_nic/#PyCloudSim.entity.v_nic.vNIC.termination","title":"<code>termination()</code>","text":"<p>Termination process of the vNIC</p> Source code in <code>PyCloudSim\\entity\\v_nic.py</code> <pre><code>def termination(self):\n\"\"\"Termination process of the vNIC\"\"\"\nreturn super().termination()\n</code></pre>"},{"location":"api/physical_component/v_nic/#PyCloudSim.entity.v_nic.vNIC.uplink_utilization","title":"<code>uplink_utilization(inertval=0.1)</code>","text":"<p>The uplink utilization of the vNIC in percentage.</p> Source code in <code>PyCloudSim\\entity\\v_nic.py</code> <pre><code>def uplink_utilization(self, inertval: float = 0.1) -&gt; float:\n\"\"\"The uplink utilization of the vNIC in percentage.\"\"\"\nreturn self.uplink.utilization_in_past(inertval) * 100\n</code></pre>"},{"location":"api/physical_entity/","title":"Index","text":"<p>The <code>PhysicalEntity</code> class is the base for all simulated physical entities such as Host, Switch and Router.</p> <p>         Bases: <code>PhysicalComponent</code>, <code>ABC</code></p> Source code in <code>PyCloudSim\\entity\\v_physical_entity.py</code> <pre><code>class PhysicalEntity(PhysicalComponent, ABC):\n_privisoned_at: float\ndef __init__(\nself,\nnum_cpu_cores: int = 1,\nipc: Union[int, float] = 1,\nfrequency: Union[int, float] = 1000,\nram: int = 1,\nrom: int = 1,\ndelay: float = 0.01,\nidle_power=50,\ncpu_tdp=125,\nram_tdp=50,\nat: Union[int, float, Callable] = simulation.now,\nafter: Optional[Entity | List[Entity]] = None,\nlabel: Optional[str] = None,\n):\nsuper().__init__(at=at, after=after, label=label)\nself._cpu = vCPU(\nipc=ipc, frequency=frequency, num_cores=num_cpu_cores, tdp=cpu_tdp\n)\nself._ram = Resource(\ncapacity=GiB(ram).bytes, label=f\"{self.__class__.__name__} {self.label} RAM\"\n)\nself._rom = Resource(\ncapacity=GiB(rom).bytes, label=f\"{self.__class__.__name__} {self.label} ROM\"\n)\nself._delay = delay\nself._privisoned_at = float()\nself._packets = list()\nself._interfaces: List[vNIC] = list()\nself._processes = list()\nself._packet_scheduler: Actor = None  # type: ignore\nself._idle_power = idle_power\nself._ram_tdp = ram_tdp\nsimulation.topology.add_node(self)\ndef send_packets(self):\ndef _send_packets():\nif len(self.packets) &gt; 0:\nLOGGER.debug(\nf\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} is scheduling packets, queued packets: {len(self.packets)}.\"\n)\nself.packets.sort(key=lambda packet: packet.priority)\nfor packet in self.packets:\nif (\npacket.decoded\nand not packet.terminated\nand not packet.transmitting\n):\nLOGGER.debug(\nf\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} is sending packet {packet.label}.\"\n)\nfor s_interface in self.interfaces:\nif s_interface.connected_to is packet.next_hop:\nLOGGER.debug(\nf\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} found interface {s_interface.label} for packet {packet.label}.\"\n)\nfor d_interface in packet.next_hop.interfaces:\nif d_interface.connected_to is self:\nLOGGER.debug(\nf\"{simulation.now:0.2f}:\\t{packet.next_hop.__class__.__name__} {packet.next_hop.label} found interface {d_interface.label} for packet {packet.label}.\"\n)\ndelay = packet.size / min(\n[\ns_interface.bandwidth,\nd_interface.bandwidth,\n]\n)\nif (\ns_interface.downlink.available_quantity\n&gt;= packet.size\nand d_interface.uplink.available_quantity\n&gt;= packet.size\n):\ns_interface.send_packet(packet, delay)\nd_interface.receive_packet(packet, delay)\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\tvPacket {packet.label} is in transmission from {self.__class__.__name__} {self.label} to {packet.next_hop.__class__.__name__} {packet.next_hop.label}\"\n)\nbreak\nbreak\nLOGGER.debug(\nf\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} scheduled all packets within the queue.\"\n)\nself._packet_scheduler = None  # type: ignore\nif self.packet_scheduler is None:\nself._packet_scheduler = Actor(\nat=simulation.now,\naction=_send_packets,\nlabel=f\"{self.__class__.__name__} {self.label} Send Packets\",\npriority=HOST_SCHEDULE_PACKET,\n)\ndef uplink_utilization(self, inertval: float = 0.1) -&gt; float:\nreturn float(\nsum(\n[\ninterface.uplink_utilization(inertval)\nfor interface in self.interfaces\n]\n)\n/ len(self.interfaces)\n)\ndef downlink_utilization(self, inertval: float = 0.1) -&gt; float:\nreturn float(\nsum(\n[\ninterface.downlink_utilization(inertval)\nfor interface in self.interfaces\n]\n)\n/ len(self.interfaces)\n)\ndef power_usage(\nself, interval: Union[int, float] = 0.1, func: str = \"log\"\n) -&gt; float:\ncpu_usage = self.cpu.utilization_in_past(interval) * 100\nram_usage = self.ram.utilization_in_past(interval) * 100\nif func == \"log\":\ncpu_power_usage = log((cpu_usage + 1), 100) * self.cpu_tdp\nram_power_usage = log((ram_usage + 1), 100) * self.ram_tdp\nreturn cpu_power_usage + ram_power_usage + self.idle_power\nelif func == \"linear\":\nreturn (\n(cpu_usage * self.cpu_tdp / 100)\n+ (ram_usage * self.ram_tdp / 100)\n+ self.idle_power\n)\nelse:\nraise ValueError(f\"Unknown power usage function: {func}\")\n@property\ndef privisoned_at(self) -&gt; float:\nreturn self._privisoned_at\n@property\ndef privisoned(self) -&gt; bool:\nreturn PRIVISIONED in self._status\n@property\ndef powered_on(self) -&gt; bool:\nreturn POWERED_ON in self._status\n@property\ndef powered_off(self) -&gt; bool:\nreturn POWERED_ON not in self._status\n@property\ndef packets(self) -&gt; List[vPacket]:\nreturn self._packets\n@property\ndef interfaces(self) -&gt; List[vNIC]:\nreturn self._interfaces\n@property\ndef processes(self) -&gt; List[vProcess]:\nreturn self._processes\n@property\ndef cpu(self) -&gt; vCPU:\nreturn self._cpu\n@property\ndef ram(self) -&gt; Resource:\nreturn self._ram\n@property\ndef rom(self) -&gt; Resource:\nreturn self._rom\n@property\ndef delay(self) -&gt; float:\nreturn self._delay\n@property\ndef packet_scheduler(self) -&gt; Actor:\nreturn self._packet_scheduler\n@property\ndef idle_power(self) -&gt; float:\nreturn self._idle_power\n@property\ndef cpu_tdp(self) -&gt; float:\nreturn self.cpu.tdp\n@property\ndef ram_tdp(self) -&gt; float:\nreturn self._ram_tdp\n</code></pre>"},{"location":"api/physical_entity/v_gateway/","title":"vGateway","text":"<p>The class \"vGateway\" is a unique implementation of the \"PhysicalEntity\" class. Unlike other entities, the \"vGateway\" does not possess a \"vCPU\", RAM, or ROM. Its primary role is to function as the entry point for the cloud environment, serving as the central hub for incoming and outgoing user traffic.</p> <p>The \"vGateway\" inherits all the member functions implemented for the \"vSwitch\" class, allowing it to perform routing and switching operations. However, unlike other entities, the \"vGateway\" does not create a simulated process for packet decoding upon receiving simulated packets.</p> <p>Additionally, the \"vGateway\" is designed to be linked exclusively with \"vRouter\" instances, facilitating seamless connectivity and routing between the gateway and the routers within the simulated network topology.</p> <p>         Bases: <code>PhysicalEntity</code></p> Source code in <code>PyCloudSim\\entity\\v_gateway.py</code> <pre><code>class vGateway(PhysicalEntity):\ndef __init__(\nself,\nat: Union[int, float, Callable] = simulation.now,\nafter: Optional[Entity | List[Entity]] = None,\nlabel: Optional[str] = None,\n):\n\"\"\"Create a virtual gateway, which is the entry/exit point of the simulated cluster.\n        Args:\n            at (Union[int, float, Callable], optional): same as the entity. Defaults to simulation.now.\n            after (Optional[Entity  |  List[Entity]], optional): same as the entity. Defaults to None.\n            label (Optional[str], optional): same as the entity. Defaults to None.\n        \"\"\"\nsuper().__init__(\nnum_cpu_cores=1,\nipc=1,\nfrequency=1000,\nram=1,\nrom=1,\ndelay=0.01,\nat=at,\nafter=after,\nlabel=label,\n)\ndef creation(self):\n\"\"\"Creation process of the virtual gateway.\"\"\"\nreturn super().creation()\ndef termination(self):\n\"\"\"Termination process of the virtual gateway.\"\"\"\nreturn super().termination()\ndef _power_on(self):\n\"\"\"Power on the virtual gateway.\"\"\"\nsuper()._power_on()\ndef _power_off(self):\n\"\"\"Power off the virtual gateway.\"\"\"\nsuper()._power_off()\ndef cache_packet(self, packet: vPacket):\n\"\"\"Cache a packet in the virtual gateway, no packet handler vProcess will be created.\"\"\"\nself.packets.append(packet)\nif not packet.scheduled:\npacket.status.append(SCHEDULED)\npacket._scheduled_at = simulation.now\npacket.status.append(QUEUED)\npacket.status.append(DECODED)\npacket._current_hop = self\nif packet.path[-1] is self:\npacket.complete()\nself.send_packets()\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} cached packet {packet.label}.\"\n)\n</code></pre>"},{"location":"api/physical_entity/v_gateway/#PyCloudSim.entity.v_gateway.vGateway.__init__","title":"<code>__init__(at=simulation.now, after=None, label=None)</code>","text":"<p>Create a virtual gateway, which is the entry/exit point of the simulated cluster.</p> <p>Parameters:</p> Name Type Description Default <code>at</code> <code>Union[int, float, Callable]</code> <p>same as the entity. Defaults to simulation.now.</p> <code>simulation.now</code> <code>after</code> <code>Optional[Entity | List[Entity]]</code> <p>same as the entity. Defaults to None.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>same as the entity. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_gateway.py</code> <pre><code>def __init__(\nself,\nat: Union[int, float, Callable] = simulation.now,\nafter: Optional[Entity | List[Entity]] = None,\nlabel: Optional[str] = None,\n):\n\"\"\"Create a virtual gateway, which is the entry/exit point of the simulated cluster.\n    Args:\n        at (Union[int, float, Callable], optional): same as the entity. Defaults to simulation.now.\n        after (Optional[Entity  |  List[Entity]], optional): same as the entity. Defaults to None.\n        label (Optional[str], optional): same as the entity. Defaults to None.\n    \"\"\"\nsuper().__init__(\nnum_cpu_cores=1,\nipc=1,\nfrequency=1000,\nram=1,\nrom=1,\ndelay=0.01,\nat=at,\nafter=after,\nlabel=label,\n)\n</code></pre>"},{"location":"api/physical_entity/v_gateway/#PyCloudSim.entity.v_gateway.vGateway.cache_packet","title":"<code>cache_packet(packet)</code>","text":"<p>Cache a packet in the virtual gateway, no packet handler vProcess will be created.</p> Source code in <code>PyCloudSim\\entity\\v_gateway.py</code> <pre><code>def cache_packet(self, packet: vPacket):\n\"\"\"Cache a packet in the virtual gateway, no packet handler vProcess will be created.\"\"\"\nself.packets.append(packet)\nif not packet.scheduled:\npacket.status.append(SCHEDULED)\npacket._scheduled_at = simulation.now\npacket.status.append(QUEUED)\npacket.status.append(DECODED)\npacket._current_hop = self\nif packet.path[-1] is self:\npacket.complete()\nself.send_packets()\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} cached packet {packet.label}.\"\n)\n</code></pre>"},{"location":"api/physical_entity/v_gateway/#PyCloudSim.entity.v_gateway.vGateway.creation","title":"<code>creation()</code>","text":"<p>Creation process of the virtual gateway.</p> Source code in <code>PyCloudSim\\entity\\v_gateway.py</code> <pre><code>def creation(self):\n\"\"\"Creation process of the virtual gateway.\"\"\"\nreturn super().creation()\n</code></pre>"},{"location":"api/physical_entity/v_gateway/#PyCloudSim.entity.v_gateway.vGateway.termination","title":"<code>termination()</code>","text":"<p>Termination process of the virtual gateway.</p> Source code in <code>PyCloudSim\\entity\\v_gateway.py</code> <pre><code>def termination(self):\n\"\"\"Termination process of the virtual gateway.\"\"\"\nreturn super().termination()\n</code></pre>"},{"location":"api/physical_entity/v_host/","title":"vHost","text":"<p>The <code>vHost</code> class is the implementation of simulated Host.</p> <p>         Bases: <code>PhysicalEntity</code></p> Source code in <code>PyCloudSim\\entity\\v_host.py</code> <pre><code>class vHost(PhysicalEntity):\ndef __init__(\nself,\nnum_cpu_cores: int,\nipc: Union[int, float],\nfrequency: Union[int, float],\nram: int,\nrom: int,\ndelay: float = 0.01,\ntaint: Optional[str] = None,\nswitch: Optional[vSwitch] = None,\nat: Union[int, float, Callable] = simulation.now,\nafter: Optional[Entity | List[Entity]] = None,\nlabel: Optional[str] = None,\n):\n\"\"\"Creat a virtual host.\n        Args:\n            num_cpu_cores (int): number of cpu cores.\n            ipc (Union[int, float]): the instructions per cycle of the CPU.\n            frequency (Union[int, float]): the frequency of the CPU.\n            ram (int): the size of the RAM in MiB.\n            rom (int): the size of the ROM in GiB.\n            delay (float, optional): the packet processing delay. Defaults to 0.01.\n            taint (Optional[str], optional): the taint of this vHost, used during container scheduling. Defaults to None.\n            switch (Optional[vSwitch], optional): the switch this vHost is connected with. Defaults to None.\n            at (Union[int, float, Callable], optional): same as entity. Defaults to simulation.now.\n            after (Optional[Entity  |  List[Entity]], optional): same as entity. Defaults to None.\n            label (Optional[str], optional): same as entity. Defaults to None.\n        \"\"\"\nsuper().__init__(\nnum_cpu_cores=num_cpu_cores,\nipc=ipc,\nfrequency=frequency,\nram=ram,\nrom=rom,\ndelay=delay,\nat=at,\nafter=after,\nlabel=label,\n)\nself._cpu_reservor = Resource(\ncapacity=(num_cpu_cores * 1000),\nlabel=f\"{self.__class__.__name__} {self.label} CPU reservor\",\n)\nself._ram_reservor = Resource(\ncapacity=(ram * 1024),\nlabel=f\"{self.__class__.__name__} {self.label} RAM reservor\",\n)\nself._taint = taint or str()\nself._containers = list()\nself._volumes = list()\nself._privisioned = False\nself._delay = delay\nsimulation.HOSTS.append(self)\nsimulation.topology.add_node(self)\nif switch is not None:\nswitch.connect_device(self)\nelse:\nsimulation.core_switch.connect_device(self)\ndef creation(self):\n\"\"\"The creation process of the vHost.\n        \"\"\"\nsuper().creation()\nsimulation.core_switch.connect_device(self)\ndef termination(self):\n\"\"\"The termination process of the vHost.\n        \"\"\"\nreturn super().termination()\ndef _power_on(self):\n\"\"\"Power on the vHost.\"\"\"\nsuper()._power_on()\nself.cpu.power_on()\nfor interface in self.interfaces:\ninterface.power_on()\ndef _power_off(self):\n\"\"\"Power off the vHost.\"\"\"\nsuper()._power_off()\nself.cpu.power_off()\nfor interface in self.interfaces:\ninterface.power_off()\ndef allocate_container(self, container: vContainer):\n\"\"\"Allocate a container on the vHost.\"\"\"\nself.containers.append(container)\nself.cpu_reservor.distribute(container, container.cpu_request)\nself.ram_reservor.distribute(container, container.ram_request)\nself.rom.distribute(container, container.image_size)\ncontainer._host_id = self.id\ncontainer.status.append(SCHEDULED)\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\tvContainer {container.label} is scheduled on vHost {self.label}.\"\n)\ncontainer.init_deamon()\ncontainer.microservice.evaluate()\nsimulation.request_scheduler.schedule()\ndef allocate_volume(self, volume: vVolume):\n\"\"\"Allocate a volume on the vHost.\"\"\"\nself.rom.distribute(volume, volume.size)\nself.volumes.append(volume)\nvolume._host_id = self.id\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\tvVolume {volume.label} is allocated on vHost {self.label}.\"\n)\nsimulation.volume_allocator.allocate()\ndef cache_packet(self, packet: vPacket):\n\"\"\"Cache a packet on the vHost.\"\"\"\nself.ram.distribute(packet, packet.size)\nself.packets.append(packet)\nif not packet.scheduled:\npacket.status.append(SCHEDULED)\npacket._scheduled_at = simulation.now\npacket.status.append(QUEUED)\npacket._current_hop = self\npacket_handler = vPacketHandler(\nlength=int(self.delay * self.cpu.single_core_capacity),\npacket=packet,\nhost=self,\nat=simulation.now,\n)\nself.processes.append(packet_handler)\nself.cpu.cache_process(packet_handler)\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} cached packet {packet.label}.\"\n)\n@property\ndef taint(self) -&gt; str:\n\"\"\"The taint of the vHost. Used during container scheduling.\"\"\"\nreturn self._taint\n@property\ndef containers(self) -&gt; List[Entity]:\n\"\"\"The containers on the vHost.\"\"\"\nreturn self._containers\n@property\ndef volumes(self) -&gt; List[Entity]:\n\"\"\"The volumes on the vHost.\"\"\"\nreturn self._volumes\n@property\ndef privisioned(self) -&gt; bool:\n\"\"\"return True if the vHost is privisioned, False otherwise.\"\"\"\nreturn self._privisioned\n@property\ndef delay(self) -&gt; float:\n\"\"\"the packet processing delay of the vHost.\"\"\"\nreturn self._delay\n@property\ndef cpu_reservor(self) -&gt; Resource:\n\"\"\"the reservor of the CPU of the vHost.\"\"\"\nreturn self._cpu_reservor\n@property\ndef ram_reservor(self) -&gt; Resource:\n\"\"\"the reservor of the RAM of the vHost.\"\"\"\nreturn self._ram_reservor\n</code></pre>"},{"location":"api/physical_entity/v_host/#PyCloudSim.entity.v_host.vHost.containers","title":"<code>containers: List[Entity]</code>  <code>property</code>","text":"<p>The containers on the vHost.</p>"},{"location":"api/physical_entity/v_host/#PyCloudSim.entity.v_host.vHost.cpu_reservor","title":"<code>cpu_reservor: Resource</code>  <code>property</code>","text":"<p>the reservor of the CPU of the vHost.</p>"},{"location":"api/physical_entity/v_host/#PyCloudSim.entity.v_host.vHost.delay","title":"<code>delay: float</code>  <code>property</code>","text":"<p>the packet processing delay of the vHost.</p>"},{"location":"api/physical_entity/v_host/#PyCloudSim.entity.v_host.vHost.privisioned","title":"<code>privisioned: bool</code>  <code>property</code>","text":"<p>return True if the vHost is privisioned, False otherwise.</p>"},{"location":"api/physical_entity/v_host/#PyCloudSim.entity.v_host.vHost.ram_reservor","title":"<code>ram_reservor: Resource</code>  <code>property</code>","text":"<p>the reservor of the RAM of the vHost.</p>"},{"location":"api/physical_entity/v_host/#PyCloudSim.entity.v_host.vHost.taint","title":"<code>taint: str</code>  <code>property</code>","text":"<p>The taint of the vHost. Used during container scheduling.</p>"},{"location":"api/physical_entity/v_host/#PyCloudSim.entity.v_host.vHost.volumes","title":"<code>volumes: List[Entity]</code>  <code>property</code>","text":"<p>The volumes on the vHost.</p>"},{"location":"api/physical_entity/v_host/#PyCloudSim.entity.v_host.vHost.__init__","title":"<code>__init__(num_cpu_cores, ipc, frequency, ram, rom, delay=0.01, taint=None, switch=None, at=simulation.now, after=None, label=None)</code>","text":"<p>Creat a virtual host.</p> <p>Parameters:</p> Name Type Description Default <code>num_cpu_cores</code> <code>int</code> <p>number of cpu cores.</p> required <code>ipc</code> <code>Union[int, float]</code> <p>the instructions per cycle of the CPU.</p> required <code>frequency</code> <code>Union[int, float]</code> <p>the frequency of the CPU.</p> required <code>ram</code> <code>int</code> <p>the size of the RAM in MiB.</p> required <code>rom</code> <code>int</code> <p>the size of the ROM in GiB.</p> required <code>delay</code> <code>float</code> <p>the packet processing delay. Defaults to 0.01.</p> <code>0.01</code> <code>taint</code> <code>Optional[str]</code> <p>the taint of this vHost, used during container scheduling. Defaults to None.</p> <code>None</code> <code>switch</code> <code>Optional[vSwitch]</code> <p>the switch this vHost is connected with. Defaults to None.</p> <code>None</code> <code>at</code> <code>Union[int, float, Callable]</code> <p>same as entity. Defaults to simulation.now.</p> <code>simulation.now</code> <code>after</code> <code>Optional[Entity | List[Entity]]</code> <p>same as entity. Defaults to None.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>same as entity. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_host.py</code> <pre><code>def __init__(\nself,\nnum_cpu_cores: int,\nipc: Union[int, float],\nfrequency: Union[int, float],\nram: int,\nrom: int,\ndelay: float = 0.01,\ntaint: Optional[str] = None,\nswitch: Optional[vSwitch] = None,\nat: Union[int, float, Callable] = simulation.now,\nafter: Optional[Entity | List[Entity]] = None,\nlabel: Optional[str] = None,\n):\n\"\"\"Creat a virtual host.\n    Args:\n        num_cpu_cores (int): number of cpu cores.\n        ipc (Union[int, float]): the instructions per cycle of the CPU.\n        frequency (Union[int, float]): the frequency of the CPU.\n        ram (int): the size of the RAM in MiB.\n        rom (int): the size of the ROM in GiB.\n        delay (float, optional): the packet processing delay. Defaults to 0.01.\n        taint (Optional[str], optional): the taint of this vHost, used during container scheduling. Defaults to None.\n        switch (Optional[vSwitch], optional): the switch this vHost is connected with. Defaults to None.\n        at (Union[int, float, Callable], optional): same as entity. Defaults to simulation.now.\n        after (Optional[Entity  |  List[Entity]], optional): same as entity. Defaults to None.\n        label (Optional[str], optional): same as entity. Defaults to None.\n    \"\"\"\nsuper().__init__(\nnum_cpu_cores=num_cpu_cores,\nipc=ipc,\nfrequency=frequency,\nram=ram,\nrom=rom,\ndelay=delay,\nat=at,\nafter=after,\nlabel=label,\n)\nself._cpu_reservor = Resource(\ncapacity=(num_cpu_cores * 1000),\nlabel=f\"{self.__class__.__name__} {self.label} CPU reservor\",\n)\nself._ram_reservor = Resource(\ncapacity=(ram * 1024),\nlabel=f\"{self.__class__.__name__} {self.label} RAM reservor\",\n)\nself._taint = taint or str()\nself._containers = list()\nself._volumes = list()\nself._privisioned = False\nself._delay = delay\nsimulation.HOSTS.append(self)\nsimulation.topology.add_node(self)\nif switch is not None:\nswitch.connect_device(self)\nelse:\nsimulation.core_switch.connect_device(self)\n</code></pre>"},{"location":"api/physical_entity/v_host/#PyCloudSim.entity.v_host.vHost.allocate_container","title":"<code>allocate_container(container)</code>","text":"<p>Allocate a container on the vHost.</p> Source code in <code>PyCloudSim\\entity\\v_host.py</code> <pre><code>def allocate_container(self, container: vContainer):\n\"\"\"Allocate a container on the vHost.\"\"\"\nself.containers.append(container)\nself.cpu_reservor.distribute(container, container.cpu_request)\nself.ram_reservor.distribute(container, container.ram_request)\nself.rom.distribute(container, container.image_size)\ncontainer._host_id = self.id\ncontainer.status.append(SCHEDULED)\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\tvContainer {container.label} is scheduled on vHost {self.label}.\"\n)\ncontainer.init_deamon()\ncontainer.microservice.evaluate()\nsimulation.request_scheduler.schedule()\n</code></pre>"},{"location":"api/physical_entity/v_host/#PyCloudSim.entity.v_host.vHost.allocate_volume","title":"<code>allocate_volume(volume)</code>","text":"<p>Allocate a volume on the vHost.</p> Source code in <code>PyCloudSim\\entity\\v_host.py</code> <pre><code>def allocate_volume(self, volume: vVolume):\n\"\"\"Allocate a volume on the vHost.\"\"\"\nself.rom.distribute(volume, volume.size)\nself.volumes.append(volume)\nvolume._host_id = self.id\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\tvVolume {volume.label} is allocated on vHost {self.label}.\"\n)\nsimulation.volume_allocator.allocate()\n</code></pre>"},{"location":"api/physical_entity/v_host/#PyCloudSim.entity.v_host.vHost.cache_packet","title":"<code>cache_packet(packet)</code>","text":"<p>Cache a packet on the vHost.</p> Source code in <code>PyCloudSim\\entity\\v_host.py</code> <pre><code>def cache_packet(self, packet: vPacket):\n\"\"\"Cache a packet on the vHost.\"\"\"\nself.ram.distribute(packet, packet.size)\nself.packets.append(packet)\nif not packet.scheduled:\npacket.status.append(SCHEDULED)\npacket._scheduled_at = simulation.now\npacket.status.append(QUEUED)\npacket._current_hop = self\npacket_handler = vPacketHandler(\nlength=int(self.delay * self.cpu.single_core_capacity),\npacket=packet,\nhost=self,\nat=simulation.now,\n)\nself.processes.append(packet_handler)\nself.cpu.cache_process(packet_handler)\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} cached packet {packet.label}.\"\n)\n</code></pre>"},{"location":"api/physical_entity/v_host/#PyCloudSim.entity.v_host.vHost.creation","title":"<code>creation()</code>","text":"<p>The creation process of the vHost.</p> Source code in <code>PyCloudSim\\entity\\v_host.py</code> <pre><code>def creation(self):\n\"\"\"The creation process of the vHost.\n    \"\"\"\nsuper().creation()\nsimulation.core_switch.connect_device(self)\n</code></pre>"},{"location":"api/physical_entity/v_host/#PyCloudSim.entity.v_host.vHost.termination","title":"<code>termination()</code>","text":"<p>The termination process of the vHost.</p> Source code in <code>PyCloudSim\\entity\\v_host.py</code> <pre><code>def termination(self):\n\"\"\"The termination process of the vHost.\n    \"\"\"\nreturn super().termination()\n</code></pre>"},{"location":"api/physical_entity/switch_router/","title":"Index","text":"<p>The class \"vSwitch\" and \"vRouter\" are the implementation of the switch and router in the simulated network topology. \"vSwitch\" and \"vRouter\" will create a scheduling process to schedule all \"vPacket\" in the queue to \"vNIC\" for transmission based on the priority of \"vPacket\" when a \"vPacket\" arrived or has been transmitted. The scheduling process is implemented as an \"event and only one scheduling process for each \"vSwitch\" or \"vRouter\" can exist at any time. If a \"vSwitch\" or \"vRouter\" does not have enough RAM to accommodate a \"vPacket\" upon receiving it, the \"vPacket\" will be dropped. The difference between \"vSwitch\" and \"vRouter\" are:</p> <ol> <li> <p>For a \"vSwitch,\" the IP address attribute of its \"vNIC\" is set to none, and its \"vNIC\" can be connected to any entity.</p> </li> <li> <p>For a \"vRouter,\" the IP address of each of its \"vNIC\" instances must belong to a unique network and its \"vNIC\" cannot be connected to a \"vHost\" entity.</p> </li> </ol>"},{"location":"api/physical_entity/switch_router/v_router/","title":"vRouter","text":"<p>The class \"vSwitch\" and \"vRouter\" are the implementation of the switch and router in the simulated network topology. \"vSwitch\" and \"vRouter\" will create a scheduling process to schedule all \"vPacket\" in the queue to \"vNIC\" for transmission based on the priority of \"vPacket\" when a \"vPacket\" arrived or has been transmitted. The scheduling process is implemented as an \"event and only one scheduling process for each \"vSwitch\" or \"vRouter\" can exist at any time. If a \"vSwitch\" or \"vRouter\" does not have enough RAM to accommodate a \"vPacket\" upon receiving it, the \"vPacket\" will be dropped. The difference between \"vSwitch\" and \"vRouter\" are:</p> <ol> <li> <p>For a \"vSwitch,\" the IP address attribute of its \"vNIC\" is set to none, and its \"vNIC\" can be connected to any entity.</p> </li> <li> <p>For a \"vRouter,\" the IP address of each of its \"vNIC\" instances must belong to a unique network and its \"vNIC\" cannot be connected to a \"vHost\" entity.</p> </li> </ol> <p>         Bases: <code>PhysicalEntity</code></p> Source code in <code>PyCloudSim\\entity\\v_router.py</code> <pre><code>class vRouter(PhysicalEntity):\ndef __init__(\nself,\nipc: Union[int, float],\nfrequency: Union[int, float],\nnum_cpu_cores: int,\nram: int,\ndelay: float = 0.01,\nat: Union[int, float, Callable] = simulation.now,\nafter: Optional[Entity | List[Entity]] = None,\nlabel: Optional[str] = None,\n):\n\"\"\"Create a virtual router.\n        Args:\n            ipc (Union[int, float]): the instructions per cycle of the CPU.\n            frequency (Union[int, float]): the frequency of the CPU.\n            num_cpu_cores (int): the number of CPU cores.\n            ram (int): the amount of RAM in MiB.\n            delay (float, optional): the packet processing delay. Defaults to 0.01.\n            at (Union[int, float, Callable], optional): same as entity. Defaults to simulation.now.\n            after (Optional[Entity  |  List[Entity]], optional): same as entity. Defaults to None.\n            label (Optional[str], optional): same as entity. Defaults to None.\n        \"\"\"\nsuper().__init__(\nnum_cpu_cores=num_cpu_cores,\nipc=ipc,\nfrequency=frequency,\nram=ram,\nrom=1,\ndelay=delay,\nat=at,\nafter=after,\nlabel=label,\n)\ndef creation(self):\n\"\"\"The creation process of the vRouter\"\"\"\nreturn super().creation()\ndef termination(self):\n\"\"\"The termination process of the vRouter\"\"\"\nreturn super().termination()\ndef _power_on(self):\n\"\"\"Power on the vRouter\"\"\"\nsuper()._power_on()\nself.cpu.power_on()\nfor interface in self.interfaces:\ninterface.power_on()\ndef _power_off(self):\n\"\"\"Power off the vRouter\"\"\"\nsuper()._power_off()\nself.cpu.power_off()\nfor interface in self.interfaces:\ninterface.power_off()\ndef connect_device(self, device: Union[vSwitch, vGateway], bandwidth: int = 1000):\n\"\"\"Connect the vRouter to a device.\n        Args:\n            device (Union[vSwitch, vGateway]): the device to connect to.\n            bandwidth (int, optional): the bandwidth of this link. Defaults to 1000.\n        \"\"\"\ndef _connect_device():\nif (\ndevice.__class__.__name__ != \"vSwitch\"\nand device.__class__.__name__ != \"vGateway\"\n):\nraise TypeError(\nf\"Device {device.label} type {device.__class__.__name__} is not vSwitch.\"\n)\nelif device.__class__.__name__ == \"vSwitch\":\ninterface = vNIC(host=self, connected_to=device, bandwidth=bandwidth)\ninterface._ip = device.usable_host_address[0]  # type: ignore\nself.interfaces.append(interface)\nport = vNIC(host=device, connected_to=self, bandwidth=bandwidth)\ndevice.interfaces.append(port)\nsimulation.topology.add_weighted_edges_from(\n[(self, device, min([bandwidth, interface.bandwidth]))]\n)\nsimulation.topology.add_weighted_edges_from(\n[(device, self, min([bandwidth, interface.bandwidth]))]\n)\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} connected to {device.__class__.__name__} {device.label}.\"\n)\nelif device.__class__.__name__ == \"vGateway\":\ninterface = vNIC(host=self, connected_to=device, bandwidth=bandwidth)\ninterface._ip = IPv4Address(\"0.0.0.0\")\nself.interfaces.append(interface)\nport = vNIC(host=device, connected_to=self, bandwidth=bandwidth)\ndevice.interfaces.append(port)\nsimulation.topology.add_weighted_edges_from(\n[(self, device, min([bandwidth, interface.bandwidth]))]\n)\nsimulation.topology.add_weighted_edges_from(\n[(device, self, min([bandwidth, interface.bandwidth]))]\n)\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} connected to {device.__class__.__name__} {device.label}.\"\n)\nActor(\nat=simulation.now,\naction=_connect_device,\nlabel=f\"Connect {self.__class__.__name__} {self.label} to {device.__class__.__name__} {device.label}\",\npriority=CREATION,\n)\ndef cache_packet(self, packet: vPacket):\n\"\"\"Cache a packet, this function will be automatically called by the vNIC upon receiving a packet.\n        Args:\n            packet (vPacket): the received packet.\n        \"\"\"\nself.ram.distribute(packet, packet.size)\nself.packets.append(packet)\nif not packet.scheduled:\npacket.status.append(SCHEDULED)\npacket._scheduled_at = simulation.now\npacket.status.append(QUEUED)\npacket._current_hop = self\npacket_handler = vPacketHandler(\nlength=int(self.delay * self.cpu.single_core_capacity),\npacket=packet,\nhost=self,\nat=simulation.now,\n)\nself.processes.append(packet_handler)\nself.ram.distribute(packet_handler, packet_handler.length)\nself.cpu.cache_process(packet_handler)\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} cached packet {packet.label}.\"\n)\n</code></pre>"},{"location":"api/physical_entity/switch_router/v_router/#PyCloudSim.entity.v_router.vRouter.__init__","title":"<code>__init__(ipc, frequency, num_cpu_cores, ram, delay=0.01, at=simulation.now, after=None, label=None)</code>","text":"<p>Create a virtual router.</p> <p>Parameters:</p> Name Type Description Default <code>ipc</code> <code>Union[int, float]</code> <p>the instructions per cycle of the CPU.</p> required <code>frequency</code> <code>Union[int, float]</code> <p>the frequency of the CPU.</p> required <code>num_cpu_cores</code> <code>int</code> <p>the number of CPU cores.</p> required <code>ram</code> <code>int</code> <p>the amount of RAM in MiB.</p> required <code>delay</code> <code>float</code> <p>the packet processing delay. Defaults to 0.01.</p> <code>0.01</code> <code>at</code> <code>Union[int, float, Callable]</code> <p>same as entity. Defaults to simulation.now.</p> <code>simulation.now</code> <code>after</code> <code>Optional[Entity | List[Entity]]</code> <p>same as entity. Defaults to None.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>same as entity. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_router.py</code> <pre><code>def __init__(\nself,\nipc: Union[int, float],\nfrequency: Union[int, float],\nnum_cpu_cores: int,\nram: int,\ndelay: float = 0.01,\nat: Union[int, float, Callable] = simulation.now,\nafter: Optional[Entity | List[Entity]] = None,\nlabel: Optional[str] = None,\n):\n\"\"\"Create a virtual router.\n    Args:\n        ipc (Union[int, float]): the instructions per cycle of the CPU.\n        frequency (Union[int, float]): the frequency of the CPU.\n        num_cpu_cores (int): the number of CPU cores.\n        ram (int): the amount of RAM in MiB.\n        delay (float, optional): the packet processing delay. Defaults to 0.01.\n        at (Union[int, float, Callable], optional): same as entity. Defaults to simulation.now.\n        after (Optional[Entity  |  List[Entity]], optional): same as entity. Defaults to None.\n        label (Optional[str], optional): same as entity. Defaults to None.\n    \"\"\"\nsuper().__init__(\nnum_cpu_cores=num_cpu_cores,\nipc=ipc,\nfrequency=frequency,\nram=ram,\nrom=1,\ndelay=delay,\nat=at,\nafter=after,\nlabel=label,\n)\n</code></pre>"},{"location":"api/physical_entity/switch_router/v_router/#PyCloudSim.entity.v_router.vRouter.cache_packet","title":"<code>cache_packet(packet)</code>","text":"<p>Cache a packet, this function will be automatically called by the vNIC upon receiving a packet.</p> <p>Parameters:</p> Name Type Description Default <code>packet</code> <code>vPacket</code> <p>the received packet.</p> required Source code in <code>PyCloudSim\\entity\\v_router.py</code> <pre><code>def cache_packet(self, packet: vPacket):\n\"\"\"Cache a packet, this function will be automatically called by the vNIC upon receiving a packet.\n    Args:\n        packet (vPacket): the received packet.\n    \"\"\"\nself.ram.distribute(packet, packet.size)\nself.packets.append(packet)\nif not packet.scheduled:\npacket.status.append(SCHEDULED)\npacket._scheduled_at = simulation.now\npacket.status.append(QUEUED)\npacket._current_hop = self\npacket_handler = vPacketHandler(\nlength=int(self.delay * self.cpu.single_core_capacity),\npacket=packet,\nhost=self,\nat=simulation.now,\n)\nself.processes.append(packet_handler)\nself.ram.distribute(packet_handler, packet_handler.length)\nself.cpu.cache_process(packet_handler)\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} cached packet {packet.label}.\"\n)\n</code></pre>"},{"location":"api/physical_entity/switch_router/v_router/#PyCloudSim.entity.v_router.vRouter.connect_device","title":"<code>connect_device(device, bandwidth=1000)</code>","text":"<p>Connect the vRouter to a device.</p> <p>Parameters:</p> Name Type Description Default <code>device</code> <code>Union[vSwitch, vGateway]</code> <p>the device to connect to.</p> required <code>bandwidth</code> <code>int</code> <p>the bandwidth of this link. Defaults to 1000.</p> <code>1000</code> Source code in <code>PyCloudSim\\entity\\v_router.py</code> <pre><code>def connect_device(self, device: Union[vSwitch, vGateway], bandwidth: int = 1000):\n\"\"\"Connect the vRouter to a device.\n    Args:\n        device (Union[vSwitch, vGateway]): the device to connect to.\n        bandwidth (int, optional): the bandwidth of this link. Defaults to 1000.\n    \"\"\"\ndef _connect_device():\nif (\ndevice.__class__.__name__ != \"vSwitch\"\nand device.__class__.__name__ != \"vGateway\"\n):\nraise TypeError(\nf\"Device {device.label} type {device.__class__.__name__} is not vSwitch.\"\n)\nelif device.__class__.__name__ == \"vSwitch\":\ninterface = vNIC(host=self, connected_to=device, bandwidth=bandwidth)\ninterface._ip = device.usable_host_address[0]  # type: ignore\nself.interfaces.append(interface)\nport = vNIC(host=device, connected_to=self, bandwidth=bandwidth)\ndevice.interfaces.append(port)\nsimulation.topology.add_weighted_edges_from(\n[(self, device, min([bandwidth, interface.bandwidth]))]\n)\nsimulation.topology.add_weighted_edges_from(\n[(device, self, min([bandwidth, interface.bandwidth]))]\n)\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} connected to {device.__class__.__name__} {device.label}.\"\n)\nelif device.__class__.__name__ == \"vGateway\":\ninterface = vNIC(host=self, connected_to=device, bandwidth=bandwidth)\ninterface._ip = IPv4Address(\"0.0.0.0\")\nself.interfaces.append(interface)\nport = vNIC(host=device, connected_to=self, bandwidth=bandwidth)\ndevice.interfaces.append(port)\nsimulation.topology.add_weighted_edges_from(\n[(self, device, min([bandwidth, interface.bandwidth]))]\n)\nsimulation.topology.add_weighted_edges_from(\n[(device, self, min([bandwidth, interface.bandwidth]))]\n)\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} connected to {device.__class__.__name__} {device.label}.\"\n)\nActor(\nat=simulation.now,\naction=_connect_device,\nlabel=f\"Connect {self.__class__.__name__} {self.label} to {device.__class__.__name__} {device.label}\",\npriority=CREATION,\n)\n</code></pre>"},{"location":"api/physical_entity/switch_router/v_router/#PyCloudSim.entity.v_router.vRouter.creation","title":"<code>creation()</code>","text":"<p>The creation process of the vRouter</p> Source code in <code>PyCloudSim\\entity\\v_router.py</code> <pre><code>def creation(self):\n\"\"\"The creation process of the vRouter\"\"\"\nreturn super().creation()\n</code></pre>"},{"location":"api/physical_entity/switch_router/v_router/#PyCloudSim.entity.v_router.vRouter.termination","title":"<code>termination()</code>","text":"<p>The termination process of the vRouter</p> Source code in <code>PyCloudSim\\entity\\v_router.py</code> <pre><code>def termination(self):\n\"\"\"The termination process of the vRouter\"\"\"\nreturn super().termination()\n</code></pre>"},{"location":"api/physical_entity/switch_router/v_switch/","title":"vSwitch","text":"<p>The class \"vSwitch\" and \"vRouter\" are the implementation of the switch and router in the simulated network topology. \"vSwitch\" and \"vRouter\" will create a scheduling process to schedule all \"vPacket\" in the queue to \"vNIC\" for transmission based on the priority of \"vPacket\" when a \"vPacket\" arrived or has been transmitted. The scheduling process is implemented as an \"event and only one scheduling process for each \"vSwitch\" or \"vRouter\" can exist at any time. If a \"vSwitch\" or \"vRouter\" does not have enough RAM to accommodate a \"vPacket\" upon receiving it, the \"vPacket\" will be dropped. The difference between \"vSwitch\" and \"vRouter\" are:</p> <ol> <li> <p>For a \"vSwitch,\" the IP address attribute of its \"vNIC\" is set to none, and its \"vNIC\" can be connected to any entity.</p> </li> <li> <p>For a \"vRouter,\" the IP address of each of its \"vNIC\" instances must belong to a unique network and its \"vNIC\" cannot be connected to a \"vHost\" entity.</p> </li> </ol> <p>         Bases: <code>PhysicalEntity</code></p> Source code in <code>PyCloudSim\\entity\\v_switch.py</code> <pre><code>class vSwitch(PhysicalEntity):\ndef __init__(\nself,\nipc: Union[int, float],\nfrequency: Union[int, float],\nnum_cpu_cores: int,\nram: int,\nsubnet: str,\ndelay: float = 0.01,\nat: Union[int, float, Callable] = simulation.now,\nafter: Optional[Entity | List[Entity]] = None,\nlabel: Optional[str] = None,\n):\n\"\"\"Create a virtual switch.\n        Args:\n            ipc (Union[int, float]): the instructions per cycle of the CPU.\n            frequency (Union[int, float]): the frequency of the CPU.\n            num_cpu_cores (int): the number of CPU cores.\n            ram (int): the amount of RAM in MiB.\n            subnet (str): the subnet of the switch.\n            delay (float, optional): the packet proccessing dekay. Defaults to 0.01.\n            at (Union[int, float, Callable], optional): same as entity. Defaults to simulation.now.\n            after (Optional[Entity  |  List[Entity]], optional): same as entity. Defaults to None.\n            label (Optional[str], optional): same as entity. Defaults to None.\n        \"\"\"\nsuper().__init__(\nnum_cpu_cores=num_cpu_cores,\nipc=ipc,\nfrequency=frequency,\nram=ram,\nrom=1,\ndelay=delay,\nat=at,\nafter=after,\nlabel=label,\n)\nself._subnet = IPv4Network(subnet)\nself._usable_host_address = list(self.subnet.hosts())\nsimulation.SWITCHES.append(self)\ndef creation(self):\n\"\"\"Creation process of the vSwitch.\n        \"\"\"\nreturn super().creation()\ndef termination(self):\n\"\"\"Termination process of the vSwitch.\n        \"\"\"\nreturn super().termination()\ndef _power_on(self):\n\"\"\"Power on process of the vSwitch.\"\"\"\nsuper()._power_on()\nself.cpu.power_on()\nfor interface in self.interfaces:\ninterface.power_on()\ndef _power_off(self):\n\"\"\"Power off process of the vSwitch.\"\"\"\nsuper()._power_off()\nself.cpu.power_off()\nfor interface in self.interfaces:\ninterface.power_off()\ndef connect_device(self, device: Union[vHost, vRouter], bandwidth: int = 1000):\n\"\"\"Connect a device to the vSwitch. A new vNIC will be created as a \"Port\" of the switch.\n        Args:\n            device (Union[vHost, vRouter]): the device to connect to the switch.\n            bandwidth (int, optional): the bandwidth of this link. Defaults to 1000.\n        \"\"\"\ndef _connect_device():\nport = vNIC(host=self, connected_to=device, bandwidth=bandwidth)\nself.interfaces.append(port)\nif device.__class__.__name__ == \"vHost\":\ninterface = vNIC(host=device, connected_to=self, bandwidth=bandwidth)\nchosen_ip = choice(self.usable_host_address[1:-1])\ninterface._ip = chosen_ip\ndevice.interfaces.append(interface)\ndevice.interfaces.append(interface)\nsimulation.topology.add_weighted_edges_from(\n[(self, device, min([bandwidth, interface.bandwidth]))]\n)\nsimulation.topology.add_weighted_edges_from(\n[(device, self, min([bandwidth, interface.bandwidth]))]\n)\nelif device.__class__.__name__ == \"vRouter\":\ninterface = vNIC(host=device, connected_to=self, bandwidth=bandwidth)\ninterface._ip = self.usable_host_address[0]\ndevice.interfaces.append(interface)\nsimulation.topology.add_weighted_edges_from(\n[(self, device, min([bandwidth, interface.bandwidth]))]\n)\nsimulation.topology.add_weighted_edges_from(\n[(device, self, min([bandwidth, interface.bandwidth]))]\n)\nelse:\nraise TypeError(\nf\"Device {device.label} type {device.__class__.__name__} is not vHost or vRouter.\"\n)\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} connected to {device.__class__.__name__} {device.label}.\"\n)\nActor(\nat=simulation.now,\naction=_connect_device,\nlabel=f\"Connect {self.__class__.__name__} {self.label} to {device.__class__.__name__} {device.label}\",\npriority=CREATION,\n)\ndef cache_packet(self, packet: vPacket):\n\"\"\"Cache a packet and engage the packet processing. This function is automatically called by the vNIC upon receiving any packet.\n        Args:\n            packet (vPacket): _description_\n        \"\"\"\nself.ram.distribute(packet, packet.size) \nself.packets.append(packet)\nif not packet.scheduled:\npacket.status.append(SCHEDULED)\npacket._scheduled_at = simulation.now\npacket.status.append(QUEUED)\npacket._current_hop = self\npacket_handler = vPacketHandler(\nlength=int(self.delay * self.cpu.single_core_capacity),\npacket=packet,\nhost=self,\nat=simulation.now\n)\nself.processes.append(packet_handler)\nself.ram.distribute(packet_handler, packet_handler.length)\nself.cpu.cache_process(packet_handler)\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} cached packet {packet.label}.\"\n)\n@property\ndef cpu(self) -&gt; vCPU:\n\"\"\"returns the CPU of the vSwitch.\"\"\"\nreturn self._cpu\n@property\ndef ram(self) -&gt; Resource:\n\"\"\"returns the RAM of the vSwitch.\"\"\"\nreturn self._ram\n@property\ndef subnet(self) -&gt; IPv4Network:\n\"\"\"returns the subnet of the vSwitch.\"\"\"\nreturn self._subnet\n@property\ndef usable_host_address(self) -&gt; List[IPv4Address]:\n\"\"\"returns the usable host addresses of the vSwitch.\"\"\"\nreturn self._usable_host_address\n@property\ndef delay(self) -&gt; float:\n\"\"\"returns the packet processing delay of the vSwitch.\"\"\"\nreturn self._delay\n</code></pre>"},{"location":"api/physical_entity/switch_router/v_switch/#PyCloudSim.entity.v_switch.vSwitch.cpu","title":"<code>cpu: vCPU</code>  <code>property</code>","text":"<p>returns the CPU of the vSwitch.</p>"},{"location":"api/physical_entity/switch_router/v_switch/#PyCloudSim.entity.v_switch.vSwitch.delay","title":"<code>delay: float</code>  <code>property</code>","text":"<p>returns the packet processing delay of the vSwitch.</p>"},{"location":"api/physical_entity/switch_router/v_switch/#PyCloudSim.entity.v_switch.vSwitch.ram","title":"<code>ram: Resource</code>  <code>property</code>","text":"<p>returns the RAM of the vSwitch.</p>"},{"location":"api/physical_entity/switch_router/v_switch/#PyCloudSim.entity.v_switch.vSwitch.subnet","title":"<code>subnet: IPv4Network</code>  <code>property</code>","text":"<p>returns the subnet of the vSwitch.</p>"},{"location":"api/physical_entity/switch_router/v_switch/#PyCloudSim.entity.v_switch.vSwitch.usable_host_address","title":"<code>usable_host_address: List[IPv4Address]</code>  <code>property</code>","text":"<p>returns the usable host addresses of the vSwitch.</p>"},{"location":"api/physical_entity/switch_router/v_switch/#PyCloudSim.entity.v_switch.vSwitch.__init__","title":"<code>__init__(ipc, frequency, num_cpu_cores, ram, subnet, delay=0.01, at=simulation.now, after=None, label=None)</code>","text":"<p>Create a virtual switch.</p> <p>Parameters:</p> Name Type Description Default <code>ipc</code> <code>Union[int, float]</code> <p>the instructions per cycle of the CPU.</p> required <code>frequency</code> <code>Union[int, float]</code> <p>the frequency of the CPU.</p> required <code>num_cpu_cores</code> <code>int</code> <p>the number of CPU cores.</p> required <code>ram</code> <code>int</code> <p>the amount of RAM in MiB.</p> required <code>subnet</code> <code>str</code> <p>the subnet of the switch.</p> required <code>delay</code> <code>float</code> <p>the packet proccessing dekay. Defaults to 0.01.</p> <code>0.01</code> <code>at</code> <code>Union[int, float, Callable]</code> <p>same as entity. Defaults to simulation.now.</p> <code>simulation.now</code> <code>after</code> <code>Optional[Entity | List[Entity]]</code> <p>same as entity. Defaults to None.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>same as entity. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_switch.py</code> <pre><code>def __init__(\nself,\nipc: Union[int, float],\nfrequency: Union[int, float],\nnum_cpu_cores: int,\nram: int,\nsubnet: str,\ndelay: float = 0.01,\nat: Union[int, float, Callable] = simulation.now,\nafter: Optional[Entity | List[Entity]] = None,\nlabel: Optional[str] = None,\n):\n\"\"\"Create a virtual switch.\n    Args:\n        ipc (Union[int, float]): the instructions per cycle of the CPU.\n        frequency (Union[int, float]): the frequency of the CPU.\n        num_cpu_cores (int): the number of CPU cores.\n        ram (int): the amount of RAM in MiB.\n        subnet (str): the subnet of the switch.\n        delay (float, optional): the packet proccessing dekay. Defaults to 0.01.\n        at (Union[int, float, Callable], optional): same as entity. Defaults to simulation.now.\n        after (Optional[Entity  |  List[Entity]], optional): same as entity. Defaults to None.\n        label (Optional[str], optional): same as entity. Defaults to None.\n    \"\"\"\nsuper().__init__(\nnum_cpu_cores=num_cpu_cores,\nipc=ipc,\nfrequency=frequency,\nram=ram,\nrom=1,\ndelay=delay,\nat=at,\nafter=after,\nlabel=label,\n)\nself._subnet = IPv4Network(subnet)\nself._usable_host_address = list(self.subnet.hosts())\nsimulation.SWITCHES.append(self)\n</code></pre>"},{"location":"api/physical_entity/switch_router/v_switch/#PyCloudSim.entity.v_switch.vSwitch.cache_packet","title":"<code>cache_packet(packet)</code>","text":"<p>Cache a packet and engage the packet processing. This function is automatically called by the vNIC upon receiving any packet.</p> <p>Parameters:</p> Name Type Description Default <code>packet</code> <code>vPacket</code> <p>description</p> required Source code in <code>PyCloudSim\\entity\\v_switch.py</code> <pre><code>def cache_packet(self, packet: vPacket):\n\"\"\"Cache a packet and engage the packet processing. This function is automatically called by the vNIC upon receiving any packet.\n    Args:\n        packet (vPacket): _description_\n    \"\"\"\nself.ram.distribute(packet, packet.size) \nself.packets.append(packet)\nif not packet.scheduled:\npacket.status.append(SCHEDULED)\npacket._scheduled_at = simulation.now\npacket.status.append(QUEUED)\npacket._current_hop = self\npacket_handler = vPacketHandler(\nlength=int(self.delay * self.cpu.single_core_capacity),\npacket=packet,\nhost=self,\nat=simulation.now\n)\nself.processes.append(packet_handler)\nself.ram.distribute(packet_handler, packet_handler.length)\nself.cpu.cache_process(packet_handler)\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} cached packet {packet.label}.\"\n)\n</code></pre>"},{"location":"api/physical_entity/switch_router/v_switch/#PyCloudSim.entity.v_switch.vSwitch.connect_device","title":"<code>connect_device(device, bandwidth=1000)</code>","text":"<p>Connect a device to the vSwitch. A new vNIC will be created as a \"Port\" of the switch.</p> <p>Parameters:</p> Name Type Description Default <code>device</code> <code>Union[vHost, vRouter]</code> <p>the device to connect to the switch.</p> required <code>bandwidth</code> <code>int</code> <p>the bandwidth of this link. Defaults to 1000.</p> <code>1000</code> Source code in <code>PyCloudSim\\entity\\v_switch.py</code> <pre><code>def connect_device(self, device: Union[vHost, vRouter], bandwidth: int = 1000):\n\"\"\"Connect a device to the vSwitch. A new vNIC will be created as a \"Port\" of the switch.\n    Args:\n        device (Union[vHost, vRouter]): the device to connect to the switch.\n        bandwidth (int, optional): the bandwidth of this link. Defaults to 1000.\n    \"\"\"\ndef _connect_device():\nport = vNIC(host=self, connected_to=device, bandwidth=bandwidth)\nself.interfaces.append(port)\nif device.__class__.__name__ == \"vHost\":\ninterface = vNIC(host=device, connected_to=self, bandwidth=bandwidth)\nchosen_ip = choice(self.usable_host_address[1:-1])\ninterface._ip = chosen_ip\ndevice.interfaces.append(interface)\ndevice.interfaces.append(interface)\nsimulation.topology.add_weighted_edges_from(\n[(self, device, min([bandwidth, interface.bandwidth]))]\n)\nsimulation.topology.add_weighted_edges_from(\n[(device, self, min([bandwidth, interface.bandwidth]))]\n)\nelif device.__class__.__name__ == \"vRouter\":\ninterface = vNIC(host=device, connected_to=self, bandwidth=bandwidth)\ninterface._ip = self.usable_host_address[0]\ndevice.interfaces.append(interface)\nsimulation.topology.add_weighted_edges_from(\n[(self, device, min([bandwidth, interface.bandwidth]))]\n)\nsimulation.topology.add_weighted_edges_from(\n[(device, self, min([bandwidth, interface.bandwidth]))]\n)\nelse:\nraise TypeError(\nf\"Device {device.label} type {device.__class__.__name__} is not vHost or vRouter.\"\n)\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} connected to {device.__class__.__name__} {device.label}.\"\n)\nActor(\nat=simulation.now,\naction=_connect_device,\nlabel=f\"Connect {self.__class__.__name__} {self.label} to {device.__class__.__name__} {device.label}\",\npriority=CREATION,\n)\n</code></pre>"},{"location":"api/physical_entity/switch_router/v_switch/#PyCloudSim.entity.v_switch.vSwitch.creation","title":"<code>creation()</code>","text":"<p>Creation process of the vSwitch.</p> Source code in <code>PyCloudSim\\entity\\v_switch.py</code> <pre><code>def creation(self):\n\"\"\"Creation process of the vSwitch.\n    \"\"\"\nreturn super().creation()\n</code></pre>"},{"location":"api/physical_entity/switch_router/v_switch/#PyCloudSim.entity.v_switch.vSwitch.termination","title":"<code>termination()</code>","text":"<p>Termination process of the vSwitch.</p> Source code in <code>PyCloudSim\\entity\\v_switch.py</code> <pre><code>def termination(self):\n\"\"\"Termination process of the vSwitch.\n    \"\"\"\nreturn super().termination()\n</code></pre>"},{"location":"api/scheduler/container_scheduler/","title":"Container Scheduler","text":"<p>The \"ContainerScheduler\" class is responsible for allocating suitable \"vHost\" instances to \"vContainer\" instances based on the available CPU and RAM resources. The scheduling process is implemented as an event that is triggered whenever a new \"vContainer\" is created or a \"vContainer\" is terminated. Only one scheduling process can exist at any time during the simulation.</p> <p>The \"ContainerScheduler\" class includes an abstract member function called \"findHost\", which allows developers to customize the conditions for determining which \"vHost\" instances are eligible for hosting a specific \"vContainer\". By implementing the \"findHost\" function, different scheduling strategies can be employed based on specific requirements and constraints.</p> <p>PyCloudSim provides several default schedulers that can be used with the \"ContainerScheduler\" class:</p> <ol> <li>\"Bestfit\" scheduler: This scheduler finds the most utilized \"vHost\" instance that still has available resources to host the \"vContainer\" being scheduled.</li> <li>\"Worstfit\" scheduler: This scheduler finds the most underutilized \"vHost\" instance that still has available resources to host the \"vContainer\" being scheduled.</li> <li>\"Random\" scheduler: This scheduler allocates the \"vContainer\" to a random \"vHost\" instance that has sufficient resources.</li> </ol> <p>Only one \"ContainerScheduler\" can be defined and used in the simulation. If multiple \"ContainerScheduler\" instances are initialized, the last one defined will be used during the simulation.</p> <p>The general procedure followed by the \"ContainerScheduler\" involves evaluating the available resources of each \"vHost\" instance and selecting the most suitable \"vHost\" to host the \"vContainer\" based on the defined scheduling strategy. This process ensures efficient resource allocation and utilization in the simulated cloud environment.</p>"},{"location":"api/scheduler/container_scheduler/#PyCloudSim.scheduler.container_scheduler.ContainerScheduler","title":"<code>ContainerScheduler</code>","text":"<p>         Bases: <code>ABC</code></p> Source code in <code>PyCloudSim\\scheduler\\container_scheduler.py</code> <pre><code>class ContainerScheduler(ABC):\n__host_affinity: bool\ndef __init__(\nself,\nhost_affinity: bool = False,\n) -&gt; None:\n\"\"\"Base class for container schedulers.\n        Args:\n            host_affinity (bool, optional): set to true for host affinity scheduling, that the host and container must have the same taint. Defaults to False.\n        \"\"\"        \nself._host_affinity = host_affinity\nself._active_process: Actor = None  # type: ignore\nsimulation._container_scheduler = self\n@abstractmethod\ndef find_host(self, container: vContainer) -&gt; Union[vHost, None]:\n\"\"\"Abstract function to be implemented with your specific container scheduling algorithm.\"\"\"\npass\ndef schedule(self):\n\"\"\"Event function to be called by the simulation engine to schedule containers. find_host() is called automatically by this function.\"\"\"\ndef _schedule():\nself._active_process = None  # type: ignore\nfor container in simulation.CONTAINERS:\nif (\ncontainer.scheduled\nor container.terminated\nor not container.schedulable\n):\ncontinue\nif candidate_host := self.find_host(container):\ncandidate_host.allocate_container(container)\nif not container.scheduled:\nLOGGER.info(\nf\"{simulation.now:0.2f}\\tvContainer {container.label} can not be shceduled, privisioning new vHost if possible.\"\n)\nif self.host_affinity:\nfor host in simulation.HOSTS:\nif host.taint == container.taint:\nsimulation.host_privisioner.privision(host)\nelse:\nfor host in simulation.HOSTS:\nif host.powered_off:\nsimulation.host_privisioner.privision(host)\nif self.active_process is None:\nself._active_process = Actor(\nat=simulation.now,\naction=_schedule,\nlabel=f\"vContainer Scheduling\",\npriority=CONTAINER_SCHEDULER,\n)\n@property\ndef host_affinity(self) -&gt; bool:\n\"\"\"returns True if host affinity is enabled, False otherwise.\"\"\"\nreturn self._host_affinity\n@property\ndef active_process(self) -&gt; Actor:\n\"\"\"returns the active process of the scheduler.\"\"\"\nreturn self._active_process\n</code></pre>"},{"location":"api/scheduler/container_scheduler/#PyCloudSim.scheduler.container_scheduler.ContainerScheduler.active_process","title":"<code>active_process: Actor</code>  <code>property</code>","text":"<p>returns the active process of the scheduler.</p>"},{"location":"api/scheduler/container_scheduler/#PyCloudSim.scheduler.container_scheduler.ContainerScheduler.host_affinity","title":"<code>host_affinity: bool</code>  <code>property</code>","text":"<p>returns True if host affinity is enabled, False otherwise.</p>"},{"location":"api/scheduler/container_scheduler/#PyCloudSim.scheduler.container_scheduler.ContainerScheduler.__init__","title":"<code>__init__(host_affinity=False)</code>","text":"<p>Base class for container schedulers.</p> <p>Parameters:</p> Name Type Description Default <code>host_affinity</code> <code>bool</code> <p>set to true for host affinity scheduling, that the host and container must have the same taint. Defaults to False.</p> <code>False</code> Source code in <code>PyCloudSim\\scheduler\\container_scheduler.py</code> <pre><code>def __init__(\nself,\nhost_affinity: bool = False,\n) -&gt; None:\n\"\"\"Base class for container schedulers.\n    Args:\n        host_affinity (bool, optional): set to true for host affinity scheduling, that the host and container must have the same taint. Defaults to False.\n    \"\"\"        \nself._host_affinity = host_affinity\nself._active_process: Actor = None  # type: ignore\nsimulation._container_scheduler = self\n</code></pre>"},{"location":"api/scheduler/container_scheduler/#PyCloudSim.scheduler.container_scheduler.ContainerScheduler.find_host","title":"<code>find_host(container)</code>  <code>abstractmethod</code>","text":"<p>Abstract function to be implemented with your specific container scheduling algorithm.</p> Source code in <code>PyCloudSim\\scheduler\\container_scheduler.py</code> <pre><code>@abstractmethod\ndef find_host(self, container: vContainer) -&gt; Union[vHost, None]:\n\"\"\"Abstract function to be implemented with your specific container scheduling algorithm.\"\"\"\npass\n</code></pre>"},{"location":"api/scheduler/container_scheduler/#PyCloudSim.scheduler.container_scheduler.ContainerScheduler.schedule","title":"<code>schedule()</code>","text":"<p>Event function to be called by the simulation engine to schedule containers. find_host() is called automatically by this function.</p> Source code in <code>PyCloudSim\\scheduler\\container_scheduler.py</code> <pre><code>def schedule(self):\n\"\"\"Event function to be called by the simulation engine to schedule containers. find_host() is called automatically by this function.\"\"\"\ndef _schedule():\nself._active_process = None  # type: ignore\nfor container in simulation.CONTAINERS:\nif (\ncontainer.scheduled\nor container.terminated\nor not container.schedulable\n):\ncontinue\nif candidate_host := self.find_host(container):\ncandidate_host.allocate_container(container)\nif not container.scheduled:\nLOGGER.info(\nf\"{simulation.now:0.2f}\\tvContainer {container.label} can not be shceduled, privisioning new vHost if possible.\"\n)\nif self.host_affinity:\nfor host in simulation.HOSTS:\nif host.taint == container.taint:\nsimulation.host_privisioner.privision(host)\nelse:\nfor host in simulation.HOSTS:\nif host.powered_off:\nsimulation.host_privisioner.privision(host)\nif self.active_process is None:\nself._active_process = Actor(\nat=simulation.now,\naction=_schedule,\nlabel=f\"vContainer Scheduling\",\npriority=CONTAINER_SCHEDULER,\n)\n</code></pre>"},{"location":"api/scheduler/container_scheduler/#PyCloudSim.scheduler.container_scheduler.ContainerSchedulerBestfit","title":"<code>ContainerSchedulerBestfit</code>","text":"<p>         Bases: <code>ContainerScheduler</code></p> <p>Bestfit container scheduler, that finds the fullest host for the container based on the available resources of the host.</p> Source code in <code>PyCloudSim\\scheduler\\container_scheduler.py</code> <pre><code>class ContainerSchedulerBestfit(ContainerScheduler):\n\"\"\"Bestfit container scheduler, that finds the fullest host for the container based on the available resources of the host.\n    \"\"\"\ndef find_host(self, container: vContainer) -&gt; vHost | None:\nif self._host_affinity:\ncandidate_host = [host for host in simulation.HOSTS if host.taint == container.taint and host.powered_on]\ncandidate_host.sort(key=lambda host: host.ram.utilization)\ncandidate_host.sort(key=lambda host: host.cpu.utilization)\nfor host in candidate_host:\nif (\nhost.cpu_reservor.available_quantity &gt;= container.cpu_request\nand host.ram_reservor.available_quantity\n&gt;= container.ram_request\nand host.rom.available_quantity &gt;= container.image_size\n):\nLOGGER.debug(\nf\"{simulation.now:0.2f}\\tFound vHost {host.label} {host.cpu.availablity} CPU, {host.ram.available_quantity} RAM, {host.rom.available_quantity} ROM for vContainer {container.label} {container.cpu_request} CPU, {container.ram_request} RAM, {container.image_size} ROM\"\n)\nreturn host\nelse:\nsimulation.HOSTS.sort(key=lambda host: host.ram.utilization)\nsimulation.HOSTS.sort(key=lambda host: host.cpu.utilization)\nfor host in simulation.HOSTS:\nif host.powered_on:\nif (\nhost.cpu_reservor.available_quantity &gt;= container.cpu_request\nand host.ram_reservor.available_quantity\n&gt;= container.ram_request\nand host.rom.available_quantity &gt;= container.image_size\n):\nLOGGER.debug(\nf\"{simulation.now:0.2f}\\tFound vHost {host.label} {host.cpu_reservor.available_quantity} CPU, {host.ram_reservor.available_quantity} RAM, {host.rom.available_quantity} ROM for vContainer {container.label} {container.cpu_request} CPU, {container.ram_request} RAM, {container.image_size} ROM\"\n)\nreturn host\nreturn None\n</code></pre>"},{"location":"api/scheduler/container_scheduler/#PyCloudSim.scheduler.container_scheduler.ContainerSchedulerRandom","title":"<code>ContainerSchedulerRandom</code>","text":"<p>         Bases: <code>ContainerScheduler</code></p> <p>Worstfit container scheduler, that finds the most empty host for the container based on the available resources of the host.</p> Source code in <code>PyCloudSim\\scheduler\\container_scheduler.py</code> <pre><code>class ContainerSchedulerRandom(ContainerScheduler):\n\"\"\"Worstfit container scheduler, that finds the most empty host for the container based on the available resources of the host.\n    \"\"\"\ndef find_host(self, container: vContainer) -&gt; vHost | None:\nif self._host_affinity:\ncandidate_host = [host for host in simulation.HOSTS if host.taint == container.taint and host.powered_on]\nrandom.shuffle(candidate_host)\nfor host in candidate_host:\nif (\nhost.cpu_reservor.available_quantity &gt;= container.cpu_request\nand host.ram_reservor.available_quantity\n&gt;= container.ram_request\nand host.rom.available_quantity &gt;= container.image_size\n):\nLOGGER.debug(\nf\"{simulation.now:0.2f}\\tFound vHost {host.label} {host.cpu.availablity} CPU, {host.ram.available_quantity} RAM, {host.rom.available_quantity} ROM for vContainer {container.label} {container.cpu_request} CPU, {container.ram_request} RAM, {container.image_size} ROM\"\n)\nreturn host\nelse:\nrandom.shuffle(simulation.HOSTS)\nfor host in simulation.HOSTS:\nif host.powered_on:\nif (\nhost.cpu_reservor.available_quantity &gt;= container.cpu_request\nand host.ram_reservor.available_quantity\n&gt;= container.ram_request\nand host.rom.available_quantity &gt;= container.image_size\n):\nLOGGER.debug(\nf\"{simulation.now:0.2f}\\tFound vHost {host.label} {host.cpu_reservor.available_quantity} CPU, {host.ram_reservor.available_quantity} RAM, {host.rom.available_quantity} ROM for vContainer {container.label} {container.cpu_request} CPU, {container.ram_request} RAM, {container.image_size} ROM\"\n)\nreturn host\nreturn None\n</code></pre>"},{"location":"api/scheduler/container_scheduler/#PyCloudSim.scheduler.container_scheduler.ContainerSchedulerWorstfit","title":"<code>ContainerSchedulerWorstfit</code>","text":"<p>         Bases: <code>ContainerScheduler</code></p> <p>Worstfit container scheduler, that finds the most empty host for the container based on the available resources of the host.</p> Source code in <code>PyCloudSim\\scheduler\\container_scheduler.py</code> <pre><code>class ContainerSchedulerWorstfit(ContainerScheduler):\n\"\"\"Worstfit container scheduler, that finds the most empty host for the container based on the available resources of the host.\n    \"\"\"\ndef find_host(self, container: vContainer) -&gt; vHost | None:\nif self._host_affinity:\ncandidate_host = [host for host in simulation.HOSTS if host.taint == container.taint and host.powered_on]\ncandidate_host.sort(key=lambda host: host.ram.utilization, reverse=True)\ncandidate_host.sort(key=lambda host: host.cpu.utilization, reverse=True)\nfor host in candidate_host:\nif (\nhost.cpu_reservor.available_quantity &gt;= container.cpu_request\nand host.ram_reservor.available_quantity\n&gt;= container.ram_request\nand host.rom.available_quantity &gt;= container.image_size\n):\nLOGGER.debug(\nf\"{simulation.now:0.2f}\\tFound vHost {host.label} {host.cpu.availablity} CPU, {host.ram.available_quantity} RAM, {host.rom.available_quantity} ROM for vContainer {container.label} {container.cpu_request} CPU, {container.ram_request} RAM, {container.image_size} ROM\"\n)\nreturn host\nelse:\nsimulation.HOSTS.sort(key=lambda host: host.ram.utilization, reverse=True)\nsimulation.HOSTS.sort(key=lambda host: host.cpu.utilization, reverse=True)\nfor host in simulation.HOSTS:\nif host.powered_on:\nif (\nhost.cpu_reservor.available_quantity &gt;= container.cpu_request\nand host.ram_reservor.available_quantity\n&gt;= container.ram_request\nand host.rom.available_quantity &gt;= container.image_size\n):\nLOGGER.debug(\nf\"{simulation.now:0.2f}\\tFound vHost {host.label} {host.cpu_reservor.available_quantity} CPU, {host.ram_reservor.available_quantity} RAM, {host.rom.available_quantity} ROM for vContainer {container.label} {container.cpu_request} CPU, {container.ram_request} RAM, {container.image_size} ROM\"\n)\nreturn host\nreturn None\n</code></pre>"},{"location":"api/scheduler/host_provisioner/","title":"Host Provisioner","text":"<p>The \"HostProvisioner\" class is responsible for handling the provisioning and decommissioning of \"vHost\" instances in the simulation environment. Its main tasks include provisioning a new \"vHost\" if any \"vContainer\" cannot be scheduled and decommissioning idle \"vHost\" instances that have been inactive for an extended period.</p> <p>The provisioning process is implemented as an event, and only one provisioning process can exist at any given time during the simulation. When triggered, the provisioning process evaluates the current state of the simulation and checks if there are any \"vContainer\" instances that cannot be scheduled onto available \"vHost\" instances. If such a situation is detected, a new \"vHost\" is provisioned to accommodate the unscheduled \"vContainer\" and ensure the continuity of the simulation.</p> <p>On the other hand, the decommissioning process is continuously associated with each \"vHost\" instance. It periodically checks if a \"vHost\" is idle, meaning it is not currently hosting any \"vContainer\" instances. If an idle state is detected, the decommissioning process is engaged, resulting in the shutdown of the idle \"vHost\" instance. However, if the \"vHost\" is not idle, indicating it is still hosting active \"vContainer\" instances, the decommissioning process will back off and wait for the next evaluation cycle. It's important to note that multiple decommissioning processes can coexist during the simulation, each associated with a specific \"vHost\" instance.</p> <p>By incorporating the \"HostProvisioner\" class into the simulation environment, the provisioning and decommissioning of \"vHost\" instances can be managed dynamically, optimizing resource utilization and ensuring efficient allocation of computational resources.</p>"},{"location":"api/scheduler/host_provisioner/#PyCloudSim.scheduler.host_provisioner.HostProvisioner","title":"<code>HostProvisioner</code>","text":"Source code in <code>PyCloudSim\\scheduler\\host_provisioner.py</code> <pre><code>class HostProvisioner:\n_power_saving: bool\n_evaluation_interval: Union[int, float]\ndef __init__(\nself, power_saving: bool = True, evaluation_interval: Union[int, float] = 1\n) -&gt; None:\n\"\"\"Host provisioner.\n        Args:\n            power_saving (bool, optional): set to true for power saving, that the host will be powered off if no container or volume is being hosted. Defaults to True.\n            evaluation_interval (Union[int, float], optional): the interval for the host provisioner to check on the host. Defaults to 1.\n        \"\"\"\nself._power_saving = power_saving\nif evaluation_interval &lt;= 0:\nraise ValueError(\n\"Host privisioner evaluation delay must be greater than 0.\"\n)\nself._evaluation_interval = evaluation_interval\nsimulation._host_privisioner = self\ndef privision(self, host: vHost):\n\"\"\"Provision a host.\"\"\"\ndef _evaluation():\nif host.powered_on:\nif len(host.containers) == 0:\nhost.power_off()\nelse:\nActor(\nat=simulation.now + self.evaluation_interval,\naction=_evaluation,\nlabel=\"Host Privisioning Evaluation\",\npriority=HOST_EVALUATION,\n)\nif host.privisioned:\nreturn\nhost._privisioned = True\nhost.power_on()\nsimulation.container_scheduler.schedule()\nsimulation.volume_allocator.allocate()\nif self.power_saving:\nActor(\nat=simulation.now + self.evaluation_interval,\naction=_evaluation,\nlabel=\"Host Privisioning Evaluation\",\npriority=HOST_EVALUATION,\n)\n@property\ndef power_saving(self) -&gt; bool:\n\"\"\"return true if power saving is enabled.\"\"\"\nreturn self._power_saving\n@property\ndef evaluation_interval(self) -&gt; Union[int, float]:\n\"\"\"return the evaluation interval.\"\"\"\nreturn self._evaluation_interval\n</code></pre>"},{"location":"api/scheduler/host_provisioner/#PyCloudSim.scheduler.host_provisioner.HostProvisioner.evaluation_interval","title":"<code>evaluation_interval: Union[int, float]</code>  <code>property</code>","text":"<p>return the evaluation interval.</p>"},{"location":"api/scheduler/host_provisioner/#PyCloudSim.scheduler.host_provisioner.HostProvisioner.power_saving","title":"<code>power_saving: bool</code>  <code>property</code>","text":"<p>return true if power saving is enabled.</p>"},{"location":"api/scheduler/host_provisioner/#PyCloudSim.scheduler.host_provisioner.HostProvisioner.__init__","title":"<code>__init__(power_saving=True, evaluation_interval=1)</code>","text":"<p>Host provisioner.</p> <p>Parameters:</p> Name Type Description Default <code>power_saving</code> <code>bool</code> <p>set to true for power saving, that the host will be powered off if no container or volume is being hosted. Defaults to True.</p> <code>True</code> <code>evaluation_interval</code> <code>Union[int, float]</code> <p>the interval for the host provisioner to check on the host. Defaults to 1.</p> <code>1</code> Source code in <code>PyCloudSim\\scheduler\\host_provisioner.py</code> <pre><code>def __init__(\nself, power_saving: bool = True, evaluation_interval: Union[int, float] = 1\n) -&gt; None:\n\"\"\"Host provisioner.\n    Args:\n        power_saving (bool, optional): set to true for power saving, that the host will be powered off if no container or volume is being hosted. Defaults to True.\n        evaluation_interval (Union[int, float], optional): the interval for the host provisioner to check on the host. Defaults to 1.\n    \"\"\"\nself._power_saving = power_saving\nif evaluation_interval &lt;= 0:\nraise ValueError(\n\"Host privisioner evaluation delay must be greater than 0.\"\n)\nself._evaluation_interval = evaluation_interval\nsimulation._host_privisioner = self\n</code></pre>"},{"location":"api/scheduler/host_provisioner/#PyCloudSim.scheduler.host_provisioner.HostProvisioner.privision","title":"<code>privision(host)</code>","text":"<p>Provision a host.</p> Source code in <code>PyCloudSim\\scheduler\\host_provisioner.py</code> <pre><code>def privision(self, host: vHost):\n\"\"\"Provision a host.\"\"\"\ndef _evaluation():\nif host.powered_on:\nif len(host.containers) == 0:\nhost.power_off()\nelse:\nActor(\nat=simulation.now + self.evaluation_interval,\naction=_evaluation,\nlabel=\"Host Privisioning Evaluation\",\npriority=HOST_EVALUATION,\n)\nif host.privisioned:\nreturn\nhost._privisioned = True\nhost.power_on()\nsimulation.container_scheduler.schedule()\nsimulation.volume_allocator.allocate()\nif self.power_saving:\nActor(\nat=simulation.now + self.evaluation_interval,\naction=_evaluation,\nlabel=\"Host Privisioning Evaluation\",\npriority=HOST_EVALUATION,\n)\n</code></pre>"},{"location":"api/scheduler/request_scheduler/","title":"Request Scheduler","text":"<p>The \"RequestScheduler\" class is responsible for scheduling \"vRequest\" instances onto \"vContainer\" instances in a simulated cloud environment. Since the computational resource usage of a \"vRequest\" cannot be known in advance due to the dynamic generation of \"vProcess\" and \"vPacket\" during execution, the \"RequestScheduler\" behaves like a load balancer, distributing \"vRequest\" instances among \"vContainer\" instances.</p> <p>By default, the \"RequestScheduler\" uses a logic that directs each \"vRequest\" to the \"vContainer\" instance that is currently executing the least number of \"vRequest\" instances. This default logic ensures a balanced distribution of workloads across available \"vContainer\" instances. However, the \"RequestScheduler\" class also provides an abstract member function that allows developers to customize the scheduling logic according to specific requirements.</p> <p>Similar to the \"ContainerScheduler\", the scheduling process in the \"RequestScheduler\" is implemented as an event that is triggered whenever a new \"vRequest\" is created, a current \"vRequest\" is terminated or a new 'vContainer\" is scheduled. This ensures that all unscheduled \"vRequest\" instances are processed and assigned to appropriate \"vContainer\" instances as soon as possible. During the simulation, only one \"RequestScheduler\" scheduling process can exist at any time to maintain the consistency of workload distribution.</p>"},{"location":"api/scheduler/request_scheduler/#PyCloudSim.scheduler.request_scheduler.RequestScheduler","title":"<code>RequestScheduler</code>","text":"Source code in <code>PyCloudSim\\scheduler\\request_scheduler.py</code> <pre><code>class RequestScheduler:\ndef __init__(self) -&gt; None:\n\"\"\"Request Scheduler\n        \"\"\"        \nself._active_process: Actor = None  # type: ignore\nsimulation._request_scheduler = self\ndef schedule(self):\n\"\"\"Schedule requests.\n        \"\"\"        \ndef _schedule():\nLOGGER.debug(\nf\"{simulation.now:0.2f}:\\tRequest Scheduler is scheduling...{len([req for req in simulation.REQUESTS if req.scheduled == False])} requests.\"\n)\nself._active_process = None  # type: ignore\nsimulation.REQUESTS.sort(key=lambda x: x.priority)\nfor request in simulation.REQUESTS:\nsource_endpoint = None\ntarget_endpoint = None\nif not request.scheduled and request.created:\n# find the containers\nif isinstance(request.source, vMicroservice):\nsource_endpoint = request.source.service.loadbalancer()\nelse:\nsource_endpoint = None\nif isinstance(request.target, vMicroservice):\ntarget_endpoint = request.target.service.loadbalancer()\nelse:\ntarget_endpoint = None\n# check if request schedulable\nif (\nsource_endpoint is None\nand isinstance(request.source, vMicroservice)\n) or (\ntarget_endpoint is None\nand isinstance(request.target, vMicroservice)\n):\nLOGGER.debug(f\"{simulation.now:0.2f}:\\tvRequest {request.label} not schedulable, {request.source} or {request.target} not available.\")\ncontinue\nrequest._scheduled_at = simulation.now\nrequest.status.append(SCHEDULED)\nif request.flow is not None and not request.flow.scheduled:\nrequest.flow._scheduled_at = simulation.now\nrequest.flow.status.append(SCHEDULED)\nif source_endpoint is not None:\nrequest._source_endpoint = source_endpoint\nsource_endpoint.accept_request(request)\nif target_endpoint is not None:\nrequest._target_endpoint = target_endpoint\ntarget_endpoint.accept_request(request)\nrequest.execute()\nif self._active_process is None:\nself._active_process = Actor(\nat=simulation.now,\naction=_schedule,\nlabel=f\"vRequest Scedule Start\",\npriority=REQUEST_SCHEDULER,\n)\n@property\ndef active_process(self) -&gt; Actor:\n\"\"\"return the active process of the request scheduler.\"\"\"\nreturn self._active_process\n</code></pre>"},{"location":"api/scheduler/request_scheduler/#PyCloudSim.scheduler.request_scheduler.RequestScheduler.active_process","title":"<code>active_process: Actor</code>  <code>property</code>","text":"<p>return the active process of the request scheduler.</p>"},{"location":"api/scheduler/request_scheduler/#PyCloudSim.scheduler.request_scheduler.RequestScheduler.__init__","title":"<code>__init__()</code>","text":"<p>Request Scheduler</p> Source code in <code>PyCloudSim\\scheduler\\request_scheduler.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"Request Scheduler\n    \"\"\"        \nself._active_process: Actor = None  # type: ignore\nsimulation._request_scheduler = self\n</code></pre>"},{"location":"api/scheduler/request_scheduler/#PyCloudSim.scheduler.request_scheduler.RequestScheduler.schedule","title":"<code>schedule()</code>","text":"<p>Schedule requests.</p> Source code in <code>PyCloudSim\\scheduler\\request_scheduler.py</code> <pre><code>def schedule(self):\n\"\"\"Schedule requests.\n    \"\"\"        \ndef _schedule():\nLOGGER.debug(\nf\"{simulation.now:0.2f}:\\tRequest Scheduler is scheduling...{len([req for req in simulation.REQUESTS if req.scheduled == False])} requests.\"\n)\nself._active_process = None  # type: ignore\nsimulation.REQUESTS.sort(key=lambda x: x.priority)\nfor request in simulation.REQUESTS:\nsource_endpoint = None\ntarget_endpoint = None\nif not request.scheduled and request.created:\n# find the containers\nif isinstance(request.source, vMicroservice):\nsource_endpoint = request.source.service.loadbalancer()\nelse:\nsource_endpoint = None\nif isinstance(request.target, vMicroservice):\ntarget_endpoint = request.target.service.loadbalancer()\nelse:\ntarget_endpoint = None\n# check if request schedulable\nif (\nsource_endpoint is None\nand isinstance(request.source, vMicroservice)\n) or (\ntarget_endpoint is None\nand isinstance(request.target, vMicroservice)\n):\nLOGGER.debug(f\"{simulation.now:0.2f}:\\tvRequest {request.label} not schedulable, {request.source} or {request.target} not available.\")\ncontinue\nrequest._scheduled_at = simulation.now\nrequest.status.append(SCHEDULED)\nif request.flow is not None and not request.flow.scheduled:\nrequest.flow._scheduled_at = simulation.now\nrequest.flow.status.append(SCHEDULED)\nif source_endpoint is not None:\nrequest._source_endpoint = source_endpoint\nsource_endpoint.accept_request(request)\nif target_endpoint is not None:\nrequest._target_endpoint = target_endpoint\ntarget_endpoint.accept_request(request)\nrequest.execute()\nif self._active_process is None:\nself._active_process = Actor(\nat=simulation.now,\naction=_schedule,\nlabel=f\"vRequest Scedule Start\",\npriority=REQUEST_SCHEDULER,\n)\n</code></pre>"},{"location":"api/scheduler/volume_allocator/","title":"Volume Allocator","text":"<p>The class \"vVolume\" is implemented to resemble a volume that can be attached to a container in Docker or Kubernetes which consumes the ROM from \"vHost\". A \"vContainer\" could be attached with multiple \"vVolume\" and those  \"vVolume\" could be allocated on different \"vHost\" rather than the \"vHost\" where the \"vContainer\" is hosted. A \"vVolume\" could be persistent by setting attribute \"retain\" equals to true. If a \"vVolume\" is persistent, it will not be destoried when its associated \"vContainer\" is terminated and could be reattached to a new instance of the \"vContainer\". The \"vVolume\" must be allocated first before a \"vContainer\" is scheduled. If any \"vVolume\" is failed to be allocated onto \"vHost\", the schedule of its associated \"vContainer\" will be on hold.</p>"},{"location":"api/scheduler/volume_allocator/#PyCloudSim.scheduler.volume_allocator.VolumeAllocator","title":"<code>VolumeAllocator</code>","text":"Source code in <code>PyCloudSim\\scheduler\\volume_allocator.py</code> <pre><code>class VolumeAllocator:\n_host_affinity: bool\ndef __init__(\nself,\nhost_affinity: bool = False,\n):\n\"\"\"volume allocator.\n        Args:\n            host_affinity (bool, optional): set to true to enable volume allocator. Defaults to False.\n        \"\"\"        \nself._host_affinity = host_affinity\nself._active_process: Actor = None  # type: ignore\nsimulation._volume_allocator = self\ndef allocate(self):\n\"\"\"Allocate the volume.\"\"\"\ndef _allocate():\nself._active_process = None  # type: ignore\nfor volume in simulation.VOLUMES:\nif volume.allocated or volume.terminated:\ncontinue\nif self.host_affinity:\nfor host in simulation.HOSTS:\nif (\nhost.taint == volume.taint\nand host.powered_on\nand host.rom.available_quantity &gt;= volume.size\n):\nhost.allocate_volume(volume)\nvolume._allocated = True\nself._active_process = None  # type: ignore\nbreak\nelse:\nfor host in simulation.HOSTS:\nif (\nhost.powered_on\nand host.rom.available_quantity &gt;= volume.size\n):\nhost.allocate_volume(volume)\nvolume._allocated = True\nself._active_process = None  # type: ignore\nbreak\nif not volume.allocated:\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\tvVolume {volume.label} can not be allocated, privisioning new vHost if possible.\"\n)\nif self.host_affinity:\nfor host in simulation.HOSTS:\nif host.taint == volume.taint:\nsimulation.host_privisioner.privision(host)\nelse:\nfor host in simulation.HOSTS:\nif host.powered_off:\nsimulation.host_privisioner.privision(host)\nif self.active_process is None:\nself._active_process = Actor(\nat=simulation.now,\naction=_allocate,\nlabel=f\"vVolume Allocate\",\npriority=VOLUME_ALLOCATOR,\n)\n@property\ndef host_affinity(self) -&gt; bool:\n\"\"\"Return the \"\"\"\nreturn self._host_affinity\n@property\ndef active_process(self) -&gt; Actor:\n\"\"\"return the current active scheduler process.\"\"\"\nreturn self._active_process\n</code></pre>"},{"location":"api/scheduler/volume_allocator/#PyCloudSim.scheduler.volume_allocator.VolumeAllocator.active_process","title":"<code>active_process: Actor</code>  <code>property</code>","text":"<p>return the current active scheduler process.</p>"},{"location":"api/scheduler/volume_allocator/#PyCloudSim.scheduler.volume_allocator.VolumeAllocator.host_affinity","title":"<code>host_affinity: bool</code>  <code>property</code>","text":"<p>Return the</p>"},{"location":"api/scheduler/volume_allocator/#PyCloudSim.scheduler.volume_allocator.VolumeAllocator.__init__","title":"<code>__init__(host_affinity=False)</code>","text":"<p>volume allocator.</p> <p>Parameters:</p> Name Type Description Default <code>host_affinity</code> <code>bool</code> <p>set to true to enable volume allocator. Defaults to False.</p> <code>False</code> Source code in <code>PyCloudSim\\scheduler\\volume_allocator.py</code> <pre><code>def __init__(\nself,\nhost_affinity: bool = False,\n):\n\"\"\"volume allocator.\n    Args:\n        host_affinity (bool, optional): set to true to enable volume allocator. Defaults to False.\n    \"\"\"        \nself._host_affinity = host_affinity\nself._active_process: Actor = None  # type: ignore\nsimulation._volume_allocator = self\n</code></pre>"},{"location":"api/scheduler/volume_allocator/#PyCloudSim.scheduler.volume_allocator.VolumeAllocator.allocate","title":"<code>allocate()</code>","text":"<p>Allocate the volume.</p> Source code in <code>PyCloudSim\\scheduler\\volume_allocator.py</code> <pre><code>def allocate(self):\n\"\"\"Allocate the volume.\"\"\"\ndef _allocate():\nself._active_process = None  # type: ignore\nfor volume in simulation.VOLUMES:\nif volume.allocated or volume.terminated:\ncontinue\nif self.host_affinity:\nfor host in simulation.HOSTS:\nif (\nhost.taint == volume.taint\nand host.powered_on\nand host.rom.available_quantity &gt;= volume.size\n):\nhost.allocate_volume(volume)\nvolume._allocated = True\nself._active_process = None  # type: ignore\nbreak\nelse:\nfor host in simulation.HOSTS:\nif (\nhost.powered_on\nand host.rom.available_quantity &gt;= volume.size\n):\nhost.allocate_volume(volume)\nvolume._allocated = True\nself._active_process = None  # type: ignore\nbreak\nif not volume.allocated:\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\tvVolume {volume.label} can not be allocated, privisioning new vHost if possible.\"\n)\nif self.host_affinity:\nfor host in simulation.HOSTS:\nif host.taint == volume.taint:\nsimulation.host_privisioner.privision(host)\nelse:\nfor host in simulation.HOSTS:\nif host.powered_off:\nsimulation.host_privisioner.privision(host)\nif self.active_process is None:\nself._active_process = Actor(\nat=simulation.now,\naction=_allocate,\nlabel=f\"vVolume Allocate\",\npriority=VOLUME_ALLOCATOR,\n)\n</code></pre>"},{"location":"api/virtual_entity/","title":"Index","text":"<p>The abstract class \"VirtualEntity\" extends the \"Entity\" class and introduces additional statuses that are specific to virtual entities within the simulation context. These new statuses include \"initiated,\" \"scheduled,\" \"failed,\" and \"completed.\" These statuses are designed to capture different stages or outcomes relevant to virtual entities during the simulation process.</p>"},{"location":"api/virtual_entity/v_container/","title":"vContainer","text":"<p>The class \"vContainer\" serves as an implementation of the abstract class \"VirtualEntity\" and emulates containers in Docker or Pods in Kubernetes. It encompasses the following essential attributes and member functions:</p> <ol> <li>CPU: Represents the CPU time limit allocated to the \"vContainer\".</li> <li>RAM: Denotes the maximum amount of RAM that the \"vContainer\" can utilize.</li> <li>Simulated API Call Queue: Stores the simulated API calls associated with the \"vContainer\".</li> <li>Simulated Process Queue: Holds the simulated processes assigned to the \"vContainer\".</li> <li>Crash Handling: If the RAM consumed by all the simulated processes in the queue surpasses the container's RAM capacity, the \"vContainer\" will crash. Consequently, all processes in the queue will be terminated and marked as failed.</li> <li>Simulated Daemon Process: The \"vContainer\" may include a simulated daemon process that mimics resource usage when the container is idle. This daemon process operates continuously until the \"vContainer\" is terminated.</li> </ol> <p>Overall, the \"vContainer\" encapsulates the behavior and characteristics of containerized environments, providing capabilities for resource allocation, process management, and crash handling within the simulated cloud environment.</p> <p>         Bases: <code>VirtualEntity</code></p> Source code in <code>PyCloudSim\\entity\\v_container.py</code> <pre><code>class vContainer(VirtualEntity):\ndef __init__(\nself,\ncpu: int,\ncpu_limit: int,\nram: int,\nram_limit: int,\nimage_size: int,\nvolumes: Optional[List[Tuple[str, str, int, bool]]] = None,\ndeamon: bool = False,\ntaint: Optional[str] = None,\nat: Union[int, float, Callable] = simulation.now,\nafter: Optional[Entity | List[Entity]] = None,\nlabel: Optional[str] = None,\n):\n\"\"\"Create a container with given specifications. Equivalent to a virtual machine or Pod in Kubernetes.\n        Args:\n            cpu (int): the amount of CPU requested by the container.\n            cpu_limit (int): the maximum amount of CPU that the container can use.\n            ram (int): the amount of RAM requested by the container.\n            ram_limit (int): the maximum amount of RAM that the container can use.\n            image_size (int): the size of the image that the container is running, in MB.\n            volumes (Optional[List[Tuple[str, str, int, bool]]], optional): the volumes that attaches to this container, (name, path, size in MB, persistent or not). Defaults to None.\n            deamon (bool, optional): set true will enable a deamon process for the container. Defaults to False.\n            taint (Optional[str], optional): the container taint, using for host allocation. Defaults to None.\n            at (Union[int, float, Callable], optional): when the container is created. Defaults to simulation.now.\n            after (Optional[Entity  |  List[Entity]], optional): the container must be created after the given entity is terminated. Defaults to None.\n            label (Optional[str], optional): short description of the container. Defaults to None.\n        \"\"\"\nsuper().__init__(at=at, after=after, label=label)\nself._cpu_request = cpu\nself._cpu = Resource(\ncapacity=cpu_limit, label=f\"{self.__class__.__name__} {self.label} CPU\"\n)\nself._ram_request = ram\nself._ram = Resource(\ncapacity=MiB(ram_limit).bytes,\nlabel=f\"{self.__class__.__name__} {self.label} RAM\",\n)\nself._image_size = MiB(image_size)\nself._volumes = list()\nif volumes is None:\nself._volumes: List[vVolume] = list()\nelse:\nfor volume in volumes:\nnew_volume = vVolume(volume[0], volume[1], volume[2], volume[3])\nnew_volume.attach(self)\nself._volumes.append(new_volume)\nself._deamon = deamon\nself._taint = taint or str()\nself._host_id = int()\nself._microservice_id = int()\nself._processes: List[vProcess] = list()\nself._requests: List[vRequest] = list()\nself._on_creation = lambda: simulation.container_scheduler.schedule()\nsimulation.CONTAINERS.append(self)\ndef init_deamon(self):\n\"\"\"Initialize the deamon process for the container.\"\"\"\nif self.deamon:\ndeamon = vDeamonProcess(\nlength=int(\nself.cpu_request / 1000 * self.host.cpu.single_core_capacity\n),\ncontainer=self,\nat=simulation.now,\nlabel=f\"vContainer {self.label} Deamon\",\n)\ndef accept_request(self, request: vRequest):\n\"\"\"Accept the vRequest\"\"\"\nself.requests.append(request)\nLOGGER.debug(\nf\"{simulation.now:0.2f}:\\tvContainer {self.label} accepts vRequest {request.label}.\"\n)\ndef accept_process(self, process: vProcess):\n\"\"\"Accept a process to run in the container.\"\"\"\nif self.terminated:\nprint(process.status)\nprint(process.request.status)  # type: ignore\nprint(self.label)\nraise Exception()\nself.processes.append(process)\nprocess._container_id = self.id\nprocess.status.append(SCHEDULED)\n# check if the container has enough ram resources to run the process\ntry:\nself.ram.distribute(process, process.ram_usage)\nexcept:\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\tvContainer {self.label} is crushed by vProcess {process.label} due to RAM overload.\"\n)\nself.crash()\nreturn\n# check if the container's host has enough RAM\ntry:\nself.host.ram.distribute(process, process.ram_usage)\nexcept:\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\tvContainer {self.label} is crushed by vProcess {process.label} due to vHost {self.host.label} RAM overload.\"\n)\nself.crash()\nreturn\nself.host.processes.append(process)\nself.host.cpu.cache_process(process)\nprocess._host_id = self.host.id\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\tvProcess {process.label} is accepted by vContainer {process.container.label}.\"  # type: ignore\n)\ndef termination(self):\n\"\"\"Terminate the container. Any process running in the container will be terminated as well and marked as failed.\n        Raises:\n            RuntimeError: raise if there is a volume that should not be attached to the container.\n        \"\"\"\n# deallocate the container from the host if it is scheduled\nif self.scheduled:\nself.host.containers.remove(self)\nself.host.rom.release(self)\nself.host.cpu_reservor.release(self)\nself.host.ram_reservor.release(self)\n# detach or terminate all the volumes attached to the container\ndetached_volumes: List[vVolume] = list()\nfor volume in self.volumes:\nif volume.container is not self:\nraise RuntimeError(\nf\"Virtual Volume {volume.label} is should not be attached to vContainer {self.label}.\"\n)\nif volume.retain:\nvolume.detach()\ndetached_volumes.append(volume)\nelse:\nvolume.terminate()\n# terminate all the processes running in the container\nfor process in self.processes:\nif not process.terminated:\nprocess.crash()\nfor request in self.requests:\nif not request.terminated:\nrequest.fail()\n# recover the container if neccessary\nself.microservice.containers.remove(self)\nif self.failed:\nself.microservice.recover(self, detached_volumes)\nsimulation.container_scheduler.schedule()\ndef crash(self):\n\"\"\"Crash the container. Any process running in the container will be terminated as well and marked as failed. This will call terminate() method.\"\"\"\nif not self.failed:\nself.status.append(FAILED)\nself.terminate()\nLOGGER.info(f\"{simulation.now:0.2f}:\\tvContainer {self.label} Crashed.\")\n@property\ndef cpu_request(self) -&gt; int:\n\"\"\"return the CPU request of the container in millicore.\"\"\"\nreturn self._cpu_request\n@property\ndef cpu(self) -&gt; Resource:\n\"\"\"return the CPU ( as Resource ) of the container.\"\"\"\nreturn self._cpu\n@property\ndef ram_request(self) -&gt; int:\n\"\"\"return the RAM request of the container in MiB.\"\"\"\nreturn self._ram_request\n@property\ndef ram(self) -&gt; Resource:\n\"\"\"return the RAM ( as Resource ) of the container.\"\"\"\nreturn self._ram\n@property\ndef image_size(self) -&gt; int:\n\"\"\"return the image size of the container in bytes.\"\"\"\nreturn self._image_size.bytes\n@property\ndef rom_request(self) -&gt; float:\n\"\"\"return the ROM request of the container in MiB, which is the sum of the image size and the size of the volumes attached to the container.\"\"\"\nreturn sum([volume.size for volume in self._volumes]) + self.image_size\n@property\ndef volumes(self) -&gt; List[vVolume]:\n\"\"\"return the list of volumes attached to the container.\"\"\"\nreturn self._volumes\n@property\ndef taint(self) -&gt; str:\n\"\"\"return the taint of the container.\"\"\"\nreturn self._taint\n@property\ndef host_id(self) -&gt; int:\n\"\"\"return the id of the host that the container is scheduled to.\"\"\"\nreturn self._host_id\n@property\ndef host(self) -&gt; vHost:\n\"\"\"return the host that the container is scheduled to.\"\"\"\nfor host in simulation.HOSTS:\nif host.id == self.host_id:\nreturn host\nraise RuntimeError(f\"Container {self.label} is not allocated to any host.\")\n@property\ndef microservice_id(self) -&gt; int:\n\"\"\"return the id of the microservice that the container is associated to.\"\"\"\nreturn self._microservice_id\n@property\ndef microservice(self) -&gt; vMicroservice:\n\"\"\"return the microservice that the container is associated to.\"\"\"\nfor microservice in simulation.MICROSERVICES:\nif microservice.id == self.microservice_id:\nreturn microservice\nraise RuntimeError(\nf\"Container {self.label} is not allocated to any microservice.\"\n)\n@property\ndef processes(self) -&gt; List[vProcess]:\n\"\"\"return the list of processes running in the container.\"\"\"\nreturn self._processes\n@property\ndef requests(self) -&gt; List[vRequest]:\n\"\"\"return the list of requests that the container has served.\"\"\"\nreturn self._requests\n@property\ndef deamon(self):\n\"\"\"return the deamon of the container.\"\"\"\nreturn self._deamon\n@property\ndef schedulable(self) -&gt; bool:\n\"\"\"return True if the container is schedulable ( all volumes are attached successfully ), otherwise return False.\"\"\"\nif all([volume.allocated for volume in self.volumes]):\nreturn True\nelse:\nreturn False\n@property\ndef cordon(self) -&gt; bool:\n\"\"\"return True if the container is cordon, otherwise return False.\"\"\"\nreturn CORDON in self.status\n</code></pre>"},{"location":"api/virtual_entity/v_container/#PyCloudSim.entity.v_container.vContainer.cordon","title":"<code>cordon: bool</code>  <code>property</code>","text":"<p>return True if the container is cordon, otherwise return False.</p>"},{"location":"api/virtual_entity/v_container/#PyCloudSim.entity.v_container.vContainer.cpu","title":"<code>cpu: Resource</code>  <code>property</code>","text":"<p>return the CPU ( as Resource ) of the container.</p>"},{"location":"api/virtual_entity/v_container/#PyCloudSim.entity.v_container.vContainer.cpu_request","title":"<code>cpu_request: int</code>  <code>property</code>","text":"<p>return the CPU request of the container in millicore.</p>"},{"location":"api/virtual_entity/v_container/#PyCloudSim.entity.v_container.vContainer.deamon","title":"<code>deamon</code>  <code>property</code>","text":"<p>return the deamon of the container.</p>"},{"location":"api/virtual_entity/v_container/#PyCloudSim.entity.v_container.vContainer.host","title":"<code>host: vHost</code>  <code>property</code>","text":"<p>return the host that the container is scheduled to.</p>"},{"location":"api/virtual_entity/v_container/#PyCloudSim.entity.v_container.vContainer.host_id","title":"<code>host_id: int</code>  <code>property</code>","text":"<p>return the id of the host that the container is scheduled to.</p>"},{"location":"api/virtual_entity/v_container/#PyCloudSim.entity.v_container.vContainer.image_size","title":"<code>image_size: int</code>  <code>property</code>","text":"<p>return the image size of the container in bytes.</p>"},{"location":"api/virtual_entity/v_container/#PyCloudSim.entity.v_container.vContainer.microservice","title":"<code>microservice: vMicroservice</code>  <code>property</code>","text":"<p>return the microservice that the container is associated to.</p>"},{"location":"api/virtual_entity/v_container/#PyCloudSim.entity.v_container.vContainer.microservice_id","title":"<code>microservice_id: int</code>  <code>property</code>","text":"<p>return the id of the microservice that the container is associated to.</p>"},{"location":"api/virtual_entity/v_container/#PyCloudSim.entity.v_container.vContainer.processes","title":"<code>processes: List[vProcess]</code>  <code>property</code>","text":"<p>return the list of processes running in the container.</p>"},{"location":"api/virtual_entity/v_container/#PyCloudSim.entity.v_container.vContainer.ram","title":"<code>ram: Resource</code>  <code>property</code>","text":"<p>return the RAM ( as Resource ) of the container.</p>"},{"location":"api/virtual_entity/v_container/#PyCloudSim.entity.v_container.vContainer.ram_request","title":"<code>ram_request: int</code>  <code>property</code>","text":"<p>return the RAM request of the container in MiB.</p>"},{"location":"api/virtual_entity/v_container/#PyCloudSim.entity.v_container.vContainer.requests","title":"<code>requests: List[vRequest]</code>  <code>property</code>","text":"<p>return the list of requests that the container has served.</p>"},{"location":"api/virtual_entity/v_container/#PyCloudSim.entity.v_container.vContainer.rom_request","title":"<code>rom_request: float</code>  <code>property</code>","text":"<p>return the ROM request of the container in MiB, which is the sum of the image size and the size of the volumes attached to the container.</p>"},{"location":"api/virtual_entity/v_container/#PyCloudSim.entity.v_container.vContainer.schedulable","title":"<code>schedulable: bool</code>  <code>property</code>","text":"<p>return True if the container is schedulable ( all volumes are attached successfully ), otherwise return False.</p>"},{"location":"api/virtual_entity/v_container/#PyCloudSim.entity.v_container.vContainer.taint","title":"<code>taint: str</code>  <code>property</code>","text":"<p>return the taint of the container.</p>"},{"location":"api/virtual_entity/v_container/#PyCloudSim.entity.v_container.vContainer.volumes","title":"<code>volumes: List[vVolume]</code>  <code>property</code>","text":"<p>return the list of volumes attached to the container.</p>"},{"location":"api/virtual_entity/v_container/#PyCloudSim.entity.v_container.vContainer.__init__","title":"<code>__init__(cpu, cpu_limit, ram, ram_limit, image_size, volumes=None, deamon=False, taint=None, at=simulation.now, after=None, label=None)</code>","text":"<p>Create a container with given specifications. Equivalent to a virtual machine or Pod in Kubernetes.</p> <p>Parameters:</p> Name Type Description Default <code>cpu</code> <code>int</code> <p>the amount of CPU requested by the container.</p> required <code>cpu_limit</code> <code>int</code> <p>the maximum amount of CPU that the container can use.</p> required <code>ram</code> <code>int</code> <p>the amount of RAM requested by the container.</p> required <code>ram_limit</code> <code>int</code> <p>the maximum amount of RAM that the container can use.</p> required <code>image_size</code> <code>int</code> <p>the size of the image that the container is running, in MB.</p> required <code>volumes</code> <code>Optional[List[Tuple[str, str, int, bool]]]</code> <p>the volumes that attaches to this container, (name, path, size in MB, persistent or not). Defaults to None.</p> <code>None</code> <code>deamon</code> <code>bool</code> <p>set true will enable a deamon process for the container. Defaults to False.</p> <code>False</code> <code>taint</code> <code>Optional[str]</code> <p>the container taint, using for host allocation. Defaults to None.</p> <code>None</code> <code>at</code> <code>Union[int, float, Callable]</code> <p>when the container is created. Defaults to simulation.now.</p> <code>simulation.now</code> <code>after</code> <code>Optional[Entity | List[Entity]]</code> <p>the container must be created after the given entity is terminated. Defaults to None.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>short description of the container. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_container.py</code> <pre><code>def __init__(\nself,\ncpu: int,\ncpu_limit: int,\nram: int,\nram_limit: int,\nimage_size: int,\nvolumes: Optional[List[Tuple[str, str, int, bool]]] = None,\ndeamon: bool = False,\ntaint: Optional[str] = None,\nat: Union[int, float, Callable] = simulation.now,\nafter: Optional[Entity | List[Entity]] = None,\nlabel: Optional[str] = None,\n):\n\"\"\"Create a container with given specifications. Equivalent to a virtual machine or Pod in Kubernetes.\n    Args:\n        cpu (int): the amount of CPU requested by the container.\n        cpu_limit (int): the maximum amount of CPU that the container can use.\n        ram (int): the amount of RAM requested by the container.\n        ram_limit (int): the maximum amount of RAM that the container can use.\n        image_size (int): the size of the image that the container is running, in MB.\n        volumes (Optional[List[Tuple[str, str, int, bool]]], optional): the volumes that attaches to this container, (name, path, size in MB, persistent or not). Defaults to None.\n        deamon (bool, optional): set true will enable a deamon process for the container. Defaults to False.\n        taint (Optional[str], optional): the container taint, using for host allocation. Defaults to None.\n        at (Union[int, float, Callable], optional): when the container is created. Defaults to simulation.now.\n        after (Optional[Entity  |  List[Entity]], optional): the container must be created after the given entity is terminated. Defaults to None.\n        label (Optional[str], optional): short description of the container. Defaults to None.\n    \"\"\"\nsuper().__init__(at=at, after=after, label=label)\nself._cpu_request = cpu\nself._cpu = Resource(\ncapacity=cpu_limit, label=f\"{self.__class__.__name__} {self.label} CPU\"\n)\nself._ram_request = ram\nself._ram = Resource(\ncapacity=MiB(ram_limit).bytes,\nlabel=f\"{self.__class__.__name__} {self.label} RAM\",\n)\nself._image_size = MiB(image_size)\nself._volumes = list()\nif volumes is None:\nself._volumes: List[vVolume] = list()\nelse:\nfor volume in volumes:\nnew_volume = vVolume(volume[0], volume[1], volume[2], volume[3])\nnew_volume.attach(self)\nself._volumes.append(new_volume)\nself._deamon = deamon\nself._taint = taint or str()\nself._host_id = int()\nself._microservice_id = int()\nself._processes: List[vProcess] = list()\nself._requests: List[vRequest] = list()\nself._on_creation = lambda: simulation.container_scheduler.schedule()\nsimulation.CONTAINERS.append(self)\n</code></pre>"},{"location":"api/virtual_entity/v_container/#PyCloudSim.entity.v_container.vContainer.accept_process","title":"<code>accept_process(process)</code>","text":"<p>Accept a process to run in the container.</p> Source code in <code>PyCloudSim\\entity\\v_container.py</code> <pre><code>def accept_process(self, process: vProcess):\n\"\"\"Accept a process to run in the container.\"\"\"\nif self.terminated:\nprint(process.status)\nprint(process.request.status)  # type: ignore\nprint(self.label)\nraise Exception()\nself.processes.append(process)\nprocess._container_id = self.id\nprocess.status.append(SCHEDULED)\n# check if the container has enough ram resources to run the process\ntry:\nself.ram.distribute(process, process.ram_usage)\nexcept:\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\tvContainer {self.label} is crushed by vProcess {process.label} due to RAM overload.\"\n)\nself.crash()\nreturn\n# check if the container's host has enough RAM\ntry:\nself.host.ram.distribute(process, process.ram_usage)\nexcept:\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\tvContainer {self.label} is crushed by vProcess {process.label} due to vHost {self.host.label} RAM overload.\"\n)\nself.crash()\nreturn\nself.host.processes.append(process)\nself.host.cpu.cache_process(process)\nprocess._host_id = self.host.id\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\tvProcess {process.label} is accepted by vContainer {process.container.label}.\"  # type: ignore\n)\n</code></pre>"},{"location":"api/virtual_entity/v_container/#PyCloudSim.entity.v_container.vContainer.accept_request","title":"<code>accept_request(request)</code>","text":"<p>Accept the vRequest</p> Source code in <code>PyCloudSim\\entity\\v_container.py</code> <pre><code>def accept_request(self, request: vRequest):\n\"\"\"Accept the vRequest\"\"\"\nself.requests.append(request)\nLOGGER.debug(\nf\"{simulation.now:0.2f}:\\tvContainer {self.label} accepts vRequest {request.label}.\"\n)\n</code></pre>"},{"location":"api/virtual_entity/v_container/#PyCloudSim.entity.v_container.vContainer.crash","title":"<code>crash()</code>","text":"<p>Crash the container. Any process running in the container will be terminated as well and marked as failed. This will call terminate() method.</p> Source code in <code>PyCloudSim\\entity\\v_container.py</code> <pre><code>def crash(self):\n\"\"\"Crash the container. Any process running in the container will be terminated as well and marked as failed. This will call terminate() method.\"\"\"\nif not self.failed:\nself.status.append(FAILED)\nself.terminate()\nLOGGER.info(f\"{simulation.now:0.2f}:\\tvContainer {self.label} Crashed.\")\n</code></pre>"},{"location":"api/virtual_entity/v_container/#PyCloudSim.entity.v_container.vContainer.init_deamon","title":"<code>init_deamon()</code>","text":"<p>Initialize the deamon process for the container.</p> Source code in <code>PyCloudSim\\entity\\v_container.py</code> <pre><code>def init_deamon(self):\n\"\"\"Initialize the deamon process for the container.\"\"\"\nif self.deamon:\ndeamon = vDeamonProcess(\nlength=int(\nself.cpu_request / 1000 * self.host.cpu.single_core_capacity\n),\ncontainer=self,\nat=simulation.now,\nlabel=f\"vContainer {self.label} Deamon\",\n)\n</code></pre>"},{"location":"api/virtual_entity/v_container/#PyCloudSim.entity.v_container.vContainer.termination","title":"<code>termination()</code>","text":"<p>Terminate the container. Any process running in the container will be terminated as well and marked as failed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>raise if there is a volume that should not be attached to the container.</p> Source code in <code>PyCloudSim\\entity\\v_container.py</code> <pre><code>def termination(self):\n\"\"\"Terminate the container. Any process running in the container will be terminated as well and marked as failed.\n    Raises:\n        RuntimeError: raise if there is a volume that should not be attached to the container.\n    \"\"\"\n# deallocate the container from the host if it is scheduled\nif self.scheduled:\nself.host.containers.remove(self)\nself.host.rom.release(self)\nself.host.cpu_reservor.release(self)\nself.host.ram_reservor.release(self)\n# detach or terminate all the volumes attached to the container\ndetached_volumes: List[vVolume] = list()\nfor volume in self.volumes:\nif volume.container is not self:\nraise RuntimeError(\nf\"Virtual Volume {volume.label} is should not be attached to vContainer {self.label}.\"\n)\nif volume.retain:\nvolume.detach()\ndetached_volumes.append(volume)\nelse:\nvolume.terminate()\n# terminate all the processes running in the container\nfor process in self.processes:\nif not process.terminated:\nprocess.crash()\nfor request in self.requests:\nif not request.terminated:\nrequest.fail()\n# recover the container if neccessary\nself.microservice.containers.remove(self)\nif self.failed:\nself.microservice.recover(self, detached_volumes)\nsimulation.container_scheduler.schedule()\n</code></pre>"},{"location":"api/virtual_entity/v_microservice/","title":"vMicroservice","text":"<p>The class \"vMicroservice\" is designed to resemble a deployment in Kubernetes, comprising one or more instances of the \"vContainer\" class. It encompasses the following important member functions and behaviours:</p> <ol> <li>Recovery of Failed vContainers: When any \"vContainer\" crashes or encounters a failure, the \"vMicroservice\" includes a member function that facilitates the recovery of these failed containers. This recovery process is initiated immediately after a container failure or after a specific delay, as determined by the simulation.</li> <li>Horizontal Scaling: The \"vMicroservice\" is responsible for horizontal scaling, which involves dynamically adjusting the number of \"vContainer\" instances based on certain conditions. If the overall CPU/RAM usage of all current \"vContainer\" instances exceeds a predetermined threshold, a new \"vContainer\" will be created to handle the increased workload. Conversely, if a \"vContainer\" is identified as being under-utilized, it may be forcibly terminated. Horizontal scaling is implemented as an event, and only one horizontal scaling event can occur per \"vMicroservice\" instance at any given time during the simulation.</li> <li>Readiness of vMicroservice: The readiness of a \"vMicroservice\" is determined by the number of current \"vContainer\" instances reaching the minimum required number. This minimum requirement ensures that the \"vMicroservice\" is considered ready for operation.</li> </ol> <p>In summary, the \"vMicroservice\" class emulates the behaviour of deployments in Kubernetes, facilitating the management of \"vContainer\" instances, recovery from failures, horizontal scaling, and readiness evaluation within the simulated cloud environment.</p> <p>         Bases: <code>VirtualEntity</code>, <code>ABC</code></p> Source code in <code>PyCloudSim\\entity\\v_microservice.py</code> <pre><code>class vMicroservice(VirtualEntity, ABC):\ndef __init__(\nself,\ncpu: int,\ncpu_limit: int,\nram: int,\nram_limit: int,\nimage_size: int,\nvolumes: Optional[List[Tuple[str, str, int, bool]]] = None,\ntaint: Optional[str] = None,\ndeamon: bool = False,\nmin_num_containers: int = 1,\nmax_num_containers: int = 3,\nevaluation_interval: float = 0.01,\nservice: Type[vService] = vServiceBestFit,\nports: List[int] = [],\nat: Union[int, float, Callable] = simulation.now,\nafter: Optional[Entity | List[Entity]] = None,\nlabel: Optional[str] = None,\n):\n\"\"\"Create a virtual microservice.\n        Args:\n            cpu (int): the requested CPU time.\n            cpu_limit (int): the limited CPU time.\n            ram (int): the requested RAM in MiB.\n            ram_limit (int): the limited RAM in MiB.\n            image_size (int): the image size in MiB of the microservice container instance.\n            volumes (Optional[List[Tuple[str, str, int, bool]]], optional): The volumes that are attached to each container instance, (name, path, size in MiB, retain or not). Defaults to None.\n            taint (Optional[str], optional): the taint of the microservice, used in scheduling. Defaults to None.\n            deamon (bool, optional): set true for create deamon process for container instance. Defaults to False.\n            min_num_containers (int, optional): minimum number of container instances. Defaults to 1.\n            max_num_containers (int, optional): maximum number of container instances. Defaults to 3.\n            evaluation_interval (float, optional): the interval for horizontal scaler to check on the microservice. Defaults to 0.01.\n            service (Type[vService], optional): the service for this microservice, will determine the load balancing method. Defaults to vServiceBestFit.\n            ports (List[int], optional): the port that are exposed. Defaults to [].\n            at (Union[int, float, Callable], optional): same as entity. Defaults to simulation.now.\n            after (Optional[Entity  |  List[Entity]], optional): same as entity. Defaults to None.\n            label (Optional[str], optional): same as entity. Defaults to None.\n        \"\"\"\nsuper().__init__(at, after, label)\nself._cpu = cpu\nself._cpu_limit = cpu_limit\nself._ram = ram\nself._ram_limit = ram_limit\nself._image_size = image_size\nself._volumes = volumes\nself._taint = taint\nself._volumes = volumes\nself._taint = taint\nself._deamon = deamon\nself._min_num_containers = min_num_containers\nself._containers = list()\nfor i in range(min_num_containers):\ncontainer = vContainer(\ncpu=cpu,\ncpu_limit=cpu_limit,\nram=ram,\nram_limit=ram_limit,\nimage_size=image_size,\nvolumes=volumes,\ntaint=taint,\nlabel=f\"{self.label}-{i}\",\ndeamon=self.deamon,\n)\ncontainer._microservice_id = self.id\nself.containers.append(container)\nself._max_num_containers = max_num_containers\nself._service = service(ms=self, ports=ports, label=f\"{self.label}-service\")\nself._evaluator = Actor(\nat=simulation.now,\nstep=evaluation_interval,\naction=self.evaluate,\nlabel=f\"vMicroservice {self.label} Evaluator\",\n)\nsimulation.MICROSERVICES.append(self)\ndef termination(self):\n\"\"\"Termination process of the virtual microservice.\"\"\"\nsuper().termination()\nself.service.terminate()\nfor container in self.containers:\ncontainer.terminate()\ndef evaluate(self):\n\"\"\"Evaluate the status of the virtual microservice, and trigger scaling up or down.\"\"\"\nscheduled_container = [\ncontainer for container in self.containers if container.scheduled\n]\nif len(scheduled_container) &gt;= self.min_num_containers:\nself.status.append(READY)\nLOGGER.info(f\"{simulation.now:0.2f}:\\tvMicroservice {self.label} is ready. {self.cpu_usage_in_past(0.01)} CPU, {self.ram_usage_in_past(0.01)} RAM.\")\nelse:\nif self.ready:\nself.status.remove(READY)\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\tvMicroservice {self.label} is not ready, {len(scheduled_container)}/{self.min_num_containers}.\"\n)\nfor sfc in simulation.SFCS:\nif not sfc.ready:\nsfc.evaluate()\nif self.scale_up_triggered():\nif (\nlen(self.containers) &lt; self.max_num_containers\nand len(\n[\ncontainer\nfor container in self.containers\nif not container.scheduled\n]\n)\n== 0\n):\nnew_container = vContainer(\ncpu=self.cpu,\ncpu_limit=self.cpu_limit,\nram=self.ram,\nram_limit=self.ram_limit,\nimage_size=self.image_size,\nvolumes=self.volumes,\ntaint=self.taint,\nlabel=f\"{self.label}-{len(self.containers)}\",\ndeamon=self.deamon,\n)\nnew_container._microservice_id = self.id\nself.containers.append(new_container)\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\tvMicroservice {self.label} scaled up one vContainer {new_container.label}.\"\n)\nelif self.scale_down_triggered():\nif len(self.containers) &gt; self.min_num_containers:\nself.containers.sort(key=lambda container: len(container.processes))\nif len(self.containers[0].requests) == 0:\nself.containers[0].terminate()\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\tvMicroservice {self.label} scaled down one vContainer {self.containers[0].label}.\"\n)\nelse:\nif (\nlen(\n[\ncontainer\nfor container in self.containers\nif container.status == CORDON\n]\n)\n== 0\n):\nself.containers[0].status.append(CORDON)\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\tvContainer {self.containers[0].label} is cordoned.\"\n)\ndef recover(\nself, container: vContainer, detached_volumes: Optional[List[vVolume]] = None\n):\n\"\"\"Recover a failed container instance.\"\"\"\ndef _recover():\n# find non-retained volumes to recover\nvolumes_to_recover = list()\nif self.volumes is not None and detached_volumes is not None:\nfor volume in detached_volumes:\nfor v_definitions in self.volumes:\nif (\nvolume.tag == v_definitions[0]\nand volume.path == v_definitions[1]\n):\ncontinue\nelse:\nvolumes_to_recover.append(v_definitions)\n# recover container\nrecovered_container = vContainer(\ncpu=self.cpu,\ncpu_limit=self.cpu_limit,\nram=self.ram,\nram_limit=self.ram_limit,\nimage_size=self.image_size,\nvolumes=volumes_to_recover,\ntaint=self.taint,\nlabel=container.label,\ndeamon=self.deamon,\n)\nrecovered_container._microservice_id = self.id\nif detached_volumes is not None:\nfor volume in detached_volumes:\nvolume.attach(recovered_container)\nself._containers.append(recovered_container)\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\tvMicroservice {self.label} recovered one failed containers.\"\n)\nif not self.terminated:\nActor(\nat=simulation.now,\naction=_recover,\nlabel=f\"vMicroservice {self.label} Recover\",\npriority=CREATION,\n)\n@abstractmethod\ndef scale_up_triggered(self) -&gt; bool:\n\"\"\"For developer to implement the scaling up trigger condition.\"\"\"\npass\n@abstractmethod\ndef scale_down_triggered(self) -&gt; bool:\n\"\"\"For developer to implement the scaling down trigger condition.\"\"\"\npass\n@property\ndef containers(self) -&gt; List[vContainer]:\n\"\"\"The container instances of the virtual microservice.\"\"\"\nreturn self._containers\n@property\ndef cpu(self) -&gt; int:\n\"\"\"The requested CPU time of the virtual microservice.\"\"\"\nreturn self._cpu\n@property\ndef cpu_limit(self) -&gt; int:\n\"\"\"The limited CPU time of the virtual microservice.\"\"\"\nreturn self._cpu_limit\n@property\ndef ram(self) -&gt; int:\n\"\"\"The requested RAM in MiB of the virtual microservice.\"\"\"\nreturn self._ram\n@property\ndef ram_limit(self) -&gt; int:\n\"\"\"The limited RAM in MiB of the virtual microservice.\"\"\"\nreturn self._ram_limit\n@property\ndef image_size(self) -&gt; int:\n\"\"\"The image size in MiB of the microservice container instance.\"\"\"\nreturn self._image_size\n@property\ndef volumes(self) -&gt; Optional[List[Tuple[str, str, int, bool]]]:\n\"\"\"The volumes that are attached to each container instance, (name, path, size in MiB, retain or not).\"\"\"\nreturn self._volumes\n@property\ndef taint(self) -&gt; Optional[str]:\n\"\"\"The taint of the microservice, used in scheduling.\"\"\"\nreturn self._taint\n@property\ndef min_num_containers(self) -&gt; int:\n\"\"\"The minimum number of container instances.\"\"\"\nreturn self._min_num_containers\n@property\ndef max_num_containers(self) -&gt; int:\n\"\"\"The maximum number of container instances.\"\"\"\nreturn self._max_num_containers\n@property\ndef ready(self) -&gt; bool:\n\"\"\"Return True if the virtual microservice is ready.\"\"\"\nreturn READY in self.status\n@property\ndef cpu_usage(self) -&gt; float:\n\"\"\"The CPU utilization of the virtual microservice.\"\"\"\nreturn sum([container.cpu.utilization for container in self.containers]) / len(\nself.containers\n)\ndef cpu_usage_in_past(self, interval: float) -&gt; float:\n\"\"\"The CPU utilization of the virtual microservice in the past interval.\"\"\"\nreturn sum(\n[\ncontainer.cpu.utilization_in_past(interval)\nfor container in self.containers\nif container.scheduled\n]\n) / len(self.containers)\n@property\ndef ram_usage(self) -&gt; float:\n\"\"\"The RAM utilization of the virtual microservice.\"\"\"\nreturn sum([container.ram.utilization for container in self.containers]) / len(\nself.containers\n)\ndef ram_usage_in_past(self, interval: float) -&gt; float:\n\"\"\"The RAM utilization of the virtual microservice in the past interval.\"\"\"\nreturn sum(\n[\ncontainer.ram.utilization_in_past(interval)\nfor container in self.containers\nif container.scheduled\n]\n) / len(self.containers)\n@property\ndef deamon(self) -&gt; bool:\n\"\"\"Return True if the virtual microservice has a deamon process.\"\"\"\nreturn self._deamon\n@property\ndef service(self) -&gt; vService:\n\"\"\"Return the service of the virtual microservice.\"\"\"\nreturn self._service\n</code></pre>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.containers","title":"<code>containers: List[vContainer]</code>  <code>property</code>","text":"<p>The container instances of the virtual microservice.</p>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.cpu","title":"<code>cpu: int</code>  <code>property</code>","text":"<p>The requested CPU time of the virtual microservice.</p>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.cpu_limit","title":"<code>cpu_limit: int</code>  <code>property</code>","text":"<p>The limited CPU time of the virtual microservice.</p>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.cpu_usage","title":"<code>cpu_usage: float</code>  <code>property</code>","text":"<p>The CPU utilization of the virtual microservice.</p>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.deamon","title":"<code>deamon: bool</code>  <code>property</code>","text":"<p>Return True if the virtual microservice has a deamon process.</p>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.image_size","title":"<code>image_size: int</code>  <code>property</code>","text":"<p>The image size in MiB of the microservice container instance.</p>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.max_num_containers","title":"<code>max_num_containers: int</code>  <code>property</code>","text":"<p>The maximum number of container instances.</p>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.min_num_containers","title":"<code>min_num_containers: int</code>  <code>property</code>","text":"<p>The minimum number of container instances.</p>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.ram","title":"<code>ram: int</code>  <code>property</code>","text":"<p>The requested RAM in MiB of the virtual microservice.</p>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.ram_limit","title":"<code>ram_limit: int</code>  <code>property</code>","text":"<p>The limited RAM in MiB of the virtual microservice.</p>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.ram_usage","title":"<code>ram_usage: float</code>  <code>property</code>","text":"<p>The RAM utilization of the virtual microservice.</p>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.ready","title":"<code>ready: bool</code>  <code>property</code>","text":"<p>Return True if the virtual microservice is ready.</p>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.service","title":"<code>service: vService</code>  <code>property</code>","text":"<p>Return the service of the virtual microservice.</p>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.taint","title":"<code>taint: Optional[str]</code>  <code>property</code>","text":"<p>The taint of the microservice, used in scheduling.</p>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.volumes","title":"<code>volumes: Optional[List[Tuple[str, str, int, bool]]]</code>  <code>property</code>","text":"<p>The volumes that are attached to each container instance, (name, path, size in MiB, retain or not).</p>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.__init__","title":"<code>__init__(cpu, cpu_limit, ram, ram_limit, image_size, volumes=None, taint=None, deamon=False, min_num_containers=1, max_num_containers=3, evaluation_interval=0.01, service=vServiceBestFit, ports=[], at=simulation.now, after=None, label=None)</code>","text":"<p>Create a virtual microservice.</p> <p>Parameters:</p> Name Type Description Default <code>cpu</code> <code>int</code> <p>the requested CPU time.</p> required <code>cpu_limit</code> <code>int</code> <p>the limited CPU time.</p> required <code>ram</code> <code>int</code> <p>the requested RAM in MiB.</p> required <code>ram_limit</code> <code>int</code> <p>the limited RAM in MiB.</p> required <code>image_size</code> <code>int</code> <p>the image size in MiB of the microservice container instance.</p> required <code>volumes</code> <code>Optional[List[Tuple[str, str, int, bool]]]</code> <p>The volumes that are attached to each container instance, (name, path, size in MiB, retain or not). Defaults to None.</p> <code>None</code> <code>taint</code> <code>Optional[str]</code> <p>the taint of the microservice, used in scheduling. Defaults to None.</p> <code>None</code> <code>deamon</code> <code>bool</code> <p>set true for create deamon process for container instance. Defaults to False.</p> <code>False</code> <code>min_num_containers</code> <code>int</code> <p>minimum number of container instances. Defaults to 1.</p> <code>1</code> <code>max_num_containers</code> <code>int</code> <p>maximum number of container instances. Defaults to 3.</p> <code>3</code> <code>evaluation_interval</code> <code>float</code> <p>the interval for horizontal scaler to check on the microservice. Defaults to 0.01.</p> <code>0.01</code> <code>service</code> <code>Type[vService]</code> <p>the service for this microservice, will determine the load balancing method. Defaults to vServiceBestFit.</p> <code>vServiceBestFit</code> <code>ports</code> <code>List[int]</code> <p>the port that are exposed. Defaults to [].</p> <code>[]</code> <code>at</code> <code>Union[int, float, Callable]</code> <p>same as entity. Defaults to simulation.now.</p> <code>simulation.now</code> <code>after</code> <code>Optional[Entity | List[Entity]]</code> <p>same as entity. Defaults to None.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>same as entity. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_microservice.py</code> <pre><code>def __init__(\nself,\ncpu: int,\ncpu_limit: int,\nram: int,\nram_limit: int,\nimage_size: int,\nvolumes: Optional[List[Tuple[str, str, int, bool]]] = None,\ntaint: Optional[str] = None,\ndeamon: bool = False,\nmin_num_containers: int = 1,\nmax_num_containers: int = 3,\nevaluation_interval: float = 0.01,\nservice: Type[vService] = vServiceBestFit,\nports: List[int] = [],\nat: Union[int, float, Callable] = simulation.now,\nafter: Optional[Entity | List[Entity]] = None,\nlabel: Optional[str] = None,\n):\n\"\"\"Create a virtual microservice.\n    Args:\n        cpu (int): the requested CPU time.\n        cpu_limit (int): the limited CPU time.\n        ram (int): the requested RAM in MiB.\n        ram_limit (int): the limited RAM in MiB.\n        image_size (int): the image size in MiB of the microservice container instance.\n        volumes (Optional[List[Tuple[str, str, int, bool]]], optional): The volumes that are attached to each container instance, (name, path, size in MiB, retain or not). Defaults to None.\n        taint (Optional[str], optional): the taint of the microservice, used in scheduling. Defaults to None.\n        deamon (bool, optional): set true for create deamon process for container instance. Defaults to False.\n        min_num_containers (int, optional): minimum number of container instances. Defaults to 1.\n        max_num_containers (int, optional): maximum number of container instances. Defaults to 3.\n        evaluation_interval (float, optional): the interval for horizontal scaler to check on the microservice. Defaults to 0.01.\n        service (Type[vService], optional): the service for this microservice, will determine the load balancing method. Defaults to vServiceBestFit.\n        ports (List[int], optional): the port that are exposed. Defaults to [].\n        at (Union[int, float, Callable], optional): same as entity. Defaults to simulation.now.\n        after (Optional[Entity  |  List[Entity]], optional): same as entity. Defaults to None.\n        label (Optional[str], optional): same as entity. Defaults to None.\n    \"\"\"\nsuper().__init__(at, after, label)\nself._cpu = cpu\nself._cpu_limit = cpu_limit\nself._ram = ram\nself._ram_limit = ram_limit\nself._image_size = image_size\nself._volumes = volumes\nself._taint = taint\nself._volumes = volumes\nself._taint = taint\nself._deamon = deamon\nself._min_num_containers = min_num_containers\nself._containers = list()\nfor i in range(min_num_containers):\ncontainer = vContainer(\ncpu=cpu,\ncpu_limit=cpu_limit,\nram=ram,\nram_limit=ram_limit,\nimage_size=image_size,\nvolumes=volumes,\ntaint=taint,\nlabel=f\"{self.label}-{i}\",\ndeamon=self.deamon,\n)\ncontainer._microservice_id = self.id\nself.containers.append(container)\nself._max_num_containers = max_num_containers\nself._service = service(ms=self, ports=ports, label=f\"{self.label}-service\")\nself._evaluator = Actor(\nat=simulation.now,\nstep=evaluation_interval,\naction=self.evaluate,\nlabel=f\"vMicroservice {self.label} Evaluator\",\n)\nsimulation.MICROSERVICES.append(self)\n</code></pre>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.cpu_usage_in_past","title":"<code>cpu_usage_in_past(interval)</code>","text":"<p>The CPU utilization of the virtual microservice in the past interval.</p> Source code in <code>PyCloudSim\\entity\\v_microservice.py</code> <pre><code>def cpu_usage_in_past(self, interval: float) -&gt; float:\n\"\"\"The CPU utilization of the virtual microservice in the past interval.\"\"\"\nreturn sum(\n[\ncontainer.cpu.utilization_in_past(interval)\nfor container in self.containers\nif container.scheduled\n]\n) / len(self.containers)\n</code></pre>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.evaluate","title":"<code>evaluate()</code>","text":"<p>Evaluate the status of the virtual microservice, and trigger scaling up or down.</p> Source code in <code>PyCloudSim\\entity\\v_microservice.py</code> <pre><code>def evaluate(self):\n\"\"\"Evaluate the status of the virtual microservice, and trigger scaling up or down.\"\"\"\nscheduled_container = [\ncontainer for container in self.containers if container.scheduled\n]\nif len(scheduled_container) &gt;= self.min_num_containers:\nself.status.append(READY)\nLOGGER.info(f\"{simulation.now:0.2f}:\\tvMicroservice {self.label} is ready. {self.cpu_usage_in_past(0.01)} CPU, {self.ram_usage_in_past(0.01)} RAM.\")\nelse:\nif self.ready:\nself.status.remove(READY)\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\tvMicroservice {self.label} is not ready, {len(scheduled_container)}/{self.min_num_containers}.\"\n)\nfor sfc in simulation.SFCS:\nif not sfc.ready:\nsfc.evaluate()\nif self.scale_up_triggered():\nif (\nlen(self.containers) &lt; self.max_num_containers\nand len(\n[\ncontainer\nfor container in self.containers\nif not container.scheduled\n]\n)\n== 0\n):\nnew_container = vContainer(\ncpu=self.cpu,\ncpu_limit=self.cpu_limit,\nram=self.ram,\nram_limit=self.ram_limit,\nimage_size=self.image_size,\nvolumes=self.volumes,\ntaint=self.taint,\nlabel=f\"{self.label}-{len(self.containers)}\",\ndeamon=self.deamon,\n)\nnew_container._microservice_id = self.id\nself.containers.append(new_container)\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\tvMicroservice {self.label} scaled up one vContainer {new_container.label}.\"\n)\nelif self.scale_down_triggered():\nif len(self.containers) &gt; self.min_num_containers:\nself.containers.sort(key=lambda container: len(container.processes))\nif len(self.containers[0].requests) == 0:\nself.containers[0].terminate()\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\tvMicroservice {self.label} scaled down one vContainer {self.containers[0].label}.\"\n)\nelse:\nif (\nlen(\n[\ncontainer\nfor container in self.containers\nif container.status == CORDON\n]\n)\n== 0\n):\nself.containers[0].status.append(CORDON)\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\tvContainer {self.containers[0].label} is cordoned.\"\n)\n</code></pre>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.ram_usage_in_past","title":"<code>ram_usage_in_past(interval)</code>","text":"<p>The RAM utilization of the virtual microservice in the past interval.</p> Source code in <code>PyCloudSim\\entity\\v_microservice.py</code> <pre><code>def ram_usage_in_past(self, interval: float) -&gt; float:\n\"\"\"The RAM utilization of the virtual microservice in the past interval.\"\"\"\nreturn sum(\n[\ncontainer.ram.utilization_in_past(interval)\nfor container in self.containers\nif container.scheduled\n]\n) / len(self.containers)\n</code></pre>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.recover","title":"<code>recover(container, detached_volumes=None)</code>","text":"<p>Recover a failed container instance.</p> Source code in <code>PyCloudSim\\entity\\v_microservice.py</code> <pre><code>def recover(\nself, container: vContainer, detached_volumes: Optional[List[vVolume]] = None\n):\n\"\"\"Recover a failed container instance.\"\"\"\ndef _recover():\n# find non-retained volumes to recover\nvolumes_to_recover = list()\nif self.volumes is not None and detached_volumes is not None:\nfor volume in detached_volumes:\nfor v_definitions in self.volumes:\nif (\nvolume.tag == v_definitions[0]\nand volume.path == v_definitions[1]\n):\ncontinue\nelse:\nvolumes_to_recover.append(v_definitions)\n# recover container\nrecovered_container = vContainer(\ncpu=self.cpu,\ncpu_limit=self.cpu_limit,\nram=self.ram,\nram_limit=self.ram_limit,\nimage_size=self.image_size,\nvolumes=volumes_to_recover,\ntaint=self.taint,\nlabel=container.label,\ndeamon=self.deamon,\n)\nrecovered_container._microservice_id = self.id\nif detached_volumes is not None:\nfor volume in detached_volumes:\nvolume.attach(recovered_container)\nself._containers.append(recovered_container)\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\tvMicroservice {self.label} recovered one failed containers.\"\n)\nif not self.terminated:\nActor(\nat=simulation.now,\naction=_recover,\nlabel=f\"vMicroservice {self.label} Recover\",\npriority=CREATION,\n)\n</code></pre>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.scale_down_triggered","title":"<code>scale_down_triggered()</code>  <code>abstractmethod</code>","text":"<p>For developer to implement the scaling down trigger condition.</p> Source code in <code>PyCloudSim\\entity\\v_microservice.py</code> <pre><code>@abstractmethod\ndef scale_down_triggered(self) -&gt; bool:\n\"\"\"For developer to implement the scaling down trigger condition.\"\"\"\npass\n</code></pre>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.scale_up_triggered","title":"<code>scale_up_triggered()</code>  <code>abstractmethod</code>","text":"<p>For developer to implement the scaling up trigger condition.</p> Source code in <code>PyCloudSim\\entity\\v_microservice.py</code> <pre><code>@abstractmethod\ndef scale_up_triggered(self) -&gt; bool:\n\"\"\"For developer to implement the scaling up trigger condition.\"\"\"\npass\n</code></pre>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.termination","title":"<code>termination()</code>","text":"<p>Termination process of the virtual microservice.</p> Source code in <code>PyCloudSim\\entity\\v_microservice.py</code> <pre><code>def termination(self):\n\"\"\"Termination process of the virtual microservice.\"\"\"\nsuper().termination()\nself.service.terminate()\nfor container in self.containers:\ncontainer.terminate()\n</code></pre>"},{"location":"api/virtual_entity/v_microservice/#default-vmicroservice","title":"Default vMicroservice","text":"<p>         Bases: <code>vMicroservice</code></p> Source code in <code>PyCloudSim\\entity\\v_microservice.py</code> <pre><code>class vMicroserviceDeafult(vMicroservice):\ndef __init__(\nself,\ncpu: int,\ncpu_limit: int,\nram: int,\nram_limit: int,\nimage_size: int,\nvolumes: List[Tuple[str, str, int, bool]] | None = None,\ntaint: str | None = None,\ndeamon: bool = False,\nmin_num_containers: int = 1,\nmax_num_containers: int = 3,\nevaluation_interval: float = 0.01,\ncpu_lower_bound: float = 0.2,\ncpu_upper_bound: float = 0.8,\nram_lower_bound: float = 0.2,\nram_upper_bound: float = 0.8,\ncool_down_period: float = 5,\nservice: Type[vService] = vServiceBestFit,\nports: List[int] = [],\nat: int | float | Callable[..., Any] = simulation.now,\nafter: Entity | List[Entity] | None = None,\nlabel: str | None = None,\n):\n\"\"\"Create a virtual microservice with default horizontal scaler.\"\"\"\nsuper().__init__(\ncpu,\ncpu_limit,\nram,\nram_limit,\nimage_size,\nvolumes,\ntaint,\ndeamon,\nmin_num_containers,\nmax_num_containers,\nevaluation_interval,\nservice,\nports,\nat,\nafter,\nlabel,\n)\nself._cpu_lower_bound = cpu_lower_bound\nself._cpu_upper_bound = cpu_upper_bound\nself._ram_lower_bound = ram_lower_bound\nself._ram_upper_bound = ram_upper_bound\nself._cool_down_period = cool_down_period\ndef scale_up_triggered(self) -&gt; bool:\n\"\"\"Default scaling up trigger condition.\"\"\"\nif (\nself.cpu_usage &gt; self.cpu_upper_bound\nor self.ram_usage &gt; self.ram_upper_bound\n):\nreturn True\nelse:\nreturn False\ndef scale_down_triggered(self) -&gt; bool:\n\"\"\"Default scaling down trigger condition.\"\"\"\nif (\nself.cpu_usage &lt; self.cpu_lower_bound\nand self.ram_usage &lt; self.ram_lower_bound\n):\nreturn True\nelse:\nreturn False\n@property\ndef cpu_lower_bound(self) -&gt; float:\n\"\"\"The lower bound of CPU utilization.\"\"\"\nreturn self._cpu_lower_bound\n@property\ndef cpu_upper_bound(self) -&gt; float:\n\"\"\"The upper bound of CPU utilization.\"\"\"\nreturn self._cpu_upper_bound\n@property\ndef ram_lower_bound(self) -&gt; float:\n\"\"\"The lower bound of RAM utilization.\"\"\"\nreturn self._ram_lower_bound\n@property\ndef ram_upper_bound(self) -&gt; float:\n\"\"\"The upper bound of RAM utilization.\"\"\"\nreturn self._ram_upper_bound\n@property\ndef cool_down_period(self) -&gt; float:\n\"\"\"The cool down period of the virtual microservice, no scaling operation will happen during cool down period.\"\"\"\nreturn self._cool_down_period\n</code></pre>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroserviceDeafult.cool_down_period","title":"<code>cool_down_period: float</code>  <code>property</code>","text":"<p>The cool down period of the virtual microservice, no scaling operation will happen during cool down period.</p>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroserviceDeafult.cpu_lower_bound","title":"<code>cpu_lower_bound: float</code>  <code>property</code>","text":"<p>The lower bound of CPU utilization.</p>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroserviceDeafult.cpu_upper_bound","title":"<code>cpu_upper_bound: float</code>  <code>property</code>","text":"<p>The upper bound of CPU utilization.</p>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroserviceDeafult.ram_lower_bound","title":"<code>ram_lower_bound: float</code>  <code>property</code>","text":"<p>The lower bound of RAM utilization.</p>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroserviceDeafult.ram_upper_bound","title":"<code>ram_upper_bound: float</code>  <code>property</code>","text":"<p>The upper bound of RAM utilization.</p>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroserviceDeafult.__init__","title":"<code>__init__(cpu, cpu_limit, ram, ram_limit, image_size, volumes=None, taint=None, deamon=False, min_num_containers=1, max_num_containers=3, evaluation_interval=0.01, cpu_lower_bound=0.2, cpu_upper_bound=0.8, ram_lower_bound=0.2, ram_upper_bound=0.8, cool_down_period=5, service=vServiceBestFit, ports=[], at=simulation.now, after=None, label=None)</code>","text":"<p>Create a virtual microservice with default horizontal scaler.</p> Source code in <code>PyCloudSim\\entity\\v_microservice.py</code> <pre><code>def __init__(\nself,\ncpu: int,\ncpu_limit: int,\nram: int,\nram_limit: int,\nimage_size: int,\nvolumes: List[Tuple[str, str, int, bool]] | None = None,\ntaint: str | None = None,\ndeamon: bool = False,\nmin_num_containers: int = 1,\nmax_num_containers: int = 3,\nevaluation_interval: float = 0.01,\ncpu_lower_bound: float = 0.2,\ncpu_upper_bound: float = 0.8,\nram_lower_bound: float = 0.2,\nram_upper_bound: float = 0.8,\ncool_down_period: float = 5,\nservice: Type[vService] = vServiceBestFit,\nports: List[int] = [],\nat: int | float | Callable[..., Any] = simulation.now,\nafter: Entity | List[Entity] | None = None,\nlabel: str | None = None,\n):\n\"\"\"Create a virtual microservice with default horizontal scaler.\"\"\"\nsuper().__init__(\ncpu,\ncpu_limit,\nram,\nram_limit,\nimage_size,\nvolumes,\ntaint,\ndeamon,\nmin_num_containers,\nmax_num_containers,\nevaluation_interval,\nservice,\nports,\nat,\nafter,\nlabel,\n)\nself._cpu_lower_bound = cpu_lower_bound\nself._cpu_upper_bound = cpu_upper_bound\nself._ram_lower_bound = ram_lower_bound\nself._ram_upper_bound = ram_upper_bound\nself._cool_down_period = cool_down_period\n</code></pre>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroserviceDeafult.scale_down_triggered","title":"<code>scale_down_triggered()</code>","text":"<p>Default scaling down trigger condition.</p> Source code in <code>PyCloudSim\\entity\\v_microservice.py</code> <pre><code>def scale_down_triggered(self) -&gt; bool:\n\"\"\"Default scaling down trigger condition.\"\"\"\nif (\nself.cpu_usage &lt; self.cpu_lower_bound\nand self.ram_usage &lt; self.ram_lower_bound\n):\nreturn True\nelse:\nreturn False\n</code></pre>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroserviceDeafult.scale_up_triggered","title":"<code>scale_up_triggered()</code>","text":"<p>Default scaling up trigger condition.</p> Source code in <code>PyCloudSim\\entity\\v_microservice.py</code> <pre><code>def scale_up_triggered(self) -&gt; bool:\n\"\"\"Default scaling up trigger condition.\"\"\"\nif (\nself.cpu_usage &gt; self.cpu_upper_bound\nor self.ram_usage &gt; self.ram_upper_bound\n):\nreturn True\nelse:\nreturn False\n</code></pre>"},{"location":"api/virtual_entity/v_service/","title":"vService","text":""},{"location":"api/virtual_entity/v_service/#PyCloudSim.entity.v_service.vService","title":"<code>vService</code>","text":"<p>         Bases: <code>VirtualEntity</code>, <code>ABC</code></p> Source code in <code>PyCloudSim\\entity\\v_service.py</code> <pre><code>class vService(VirtualEntity, ABC):\ndef __init__(\nself,\nms: vMicroservice,\nports: List[int] = [],\nat: int | float | Callable[..., Any] = simulation.now,\nafter: Entity | List[Entity] | None = None,\nlabel: str | None = None,\n):\n\"\"\"Base class for virtual services.\n        Args:\n            ms (vMicroservice): the associated vMicroservice.\n            ports (List[int], optional): the exposed ports for vContainers. Defaults to [].\n            at (int | float | Callable[..., Any], optional): same as entity. Defaults to simulation.now.\n            after (Entity | List[Entity] | None, optional): same as entity. Defaults to None.\n            label (str | None, optional): same as entity. Defaults to None.\n        \"\"\"        \nsuper().__init__(at, after, label)\n# assign the microservice\nself._ms_id = ms.id\n# assign the ip address\nself._ip_address = choice(simulation.virtual_network_ips)\nsimulation.virtual_network_ips.remove(self.ip_address)\n# ports\nself._ports = ports\ndef creation(self):\n\"\"\"Creation process of a vService.\"\"\"\nreturn super().creation()\ndef termination(self):\n\"\"\"Termination process of a vService.\"\"\"\nreturn super().termination()\n@abstractmethod\ndef loadbalancer(self) -&gt; vContainer:\n\"\"\"The loadbalancer of the vService. Can be implemented by the developer.\"\"\"\npass\n@property\ndef ms_id(self):\n\"\"\"The id of the associated vMicroservice.\"\"\"\nreturn self._ms_id\n@property\ndef ip_address(self):\n\"\"\"The ip address of the vService.\"\"\"\nreturn self._ip_address\n@property\ndef ms(self):\n\"\"\"The associated vMicroservice.\"\"\"\nfor ms in simulation.MICROSERVICES:\nif ms.id == self.ms_id:\nreturn ms\nraise Exception(\nf\"Can not find associated vMicroservice for vService {self.id}.\"\n)\n</code></pre>"},{"location":"api/virtual_entity/v_service/#PyCloudSim.entity.v_service.vService.ip_address","title":"<code>ip_address</code>  <code>property</code>","text":"<p>The ip address of the vService.</p>"},{"location":"api/virtual_entity/v_service/#PyCloudSim.entity.v_service.vService.ms","title":"<code>ms</code>  <code>property</code>","text":"<p>The associated vMicroservice.</p>"},{"location":"api/virtual_entity/v_service/#PyCloudSim.entity.v_service.vService.ms_id","title":"<code>ms_id</code>  <code>property</code>","text":"<p>The id of the associated vMicroservice.</p>"},{"location":"api/virtual_entity/v_service/#PyCloudSim.entity.v_service.vService.__init__","title":"<code>__init__(ms, ports=[], at=simulation.now, after=None, label=None)</code>","text":"<p>Base class for virtual services.</p> <p>Parameters:</p> Name Type Description Default <code>ms</code> <code>vMicroservice</code> <p>the associated vMicroservice.</p> required <code>ports</code> <code>List[int]</code> <p>the exposed ports for vContainers. Defaults to [].</p> <code>[]</code> <code>at</code> <code>int | float | Callable[..., Any]</code> <p>same as entity. Defaults to simulation.now.</p> <code>simulation.now</code> <code>after</code> <code>Entity | List[Entity] | None</code> <p>same as entity. Defaults to None.</p> <code>None</code> <code>label</code> <code>str | None</code> <p>same as entity. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_service.py</code> <pre><code>def __init__(\nself,\nms: vMicroservice,\nports: List[int] = [],\nat: int | float | Callable[..., Any] = simulation.now,\nafter: Entity | List[Entity] | None = None,\nlabel: str | None = None,\n):\n\"\"\"Base class for virtual services.\n    Args:\n        ms (vMicroservice): the associated vMicroservice.\n        ports (List[int], optional): the exposed ports for vContainers. Defaults to [].\n        at (int | float | Callable[..., Any], optional): same as entity. Defaults to simulation.now.\n        after (Entity | List[Entity] | None, optional): same as entity. Defaults to None.\n        label (str | None, optional): same as entity. Defaults to None.\n    \"\"\"        \nsuper().__init__(at, after, label)\n# assign the microservice\nself._ms_id = ms.id\n# assign the ip address\nself._ip_address = choice(simulation.virtual_network_ips)\nsimulation.virtual_network_ips.remove(self.ip_address)\n# ports\nself._ports = ports\n</code></pre>"},{"location":"api/virtual_entity/v_service/#PyCloudSim.entity.v_service.vService.creation","title":"<code>creation()</code>","text":"<p>Creation process of a vService.</p> Source code in <code>PyCloudSim\\entity\\v_service.py</code> <pre><code>def creation(self):\n\"\"\"Creation process of a vService.\"\"\"\nreturn super().creation()\n</code></pre>"},{"location":"api/virtual_entity/v_service/#PyCloudSim.entity.v_service.vService.loadbalancer","title":"<code>loadbalancer()</code>  <code>abstractmethod</code>","text":"<p>The loadbalancer of the vService. Can be implemented by the developer.</p> Source code in <code>PyCloudSim\\entity\\v_service.py</code> <pre><code>@abstractmethod\ndef loadbalancer(self) -&gt; vContainer:\n\"\"\"The loadbalancer of the vService. Can be implemented by the developer.\"\"\"\npass\n</code></pre>"},{"location":"api/virtual_entity/v_service/#PyCloudSim.entity.v_service.vService.termination","title":"<code>termination()</code>","text":"<p>Termination process of a vService.</p> Source code in <code>PyCloudSim\\entity\\v_service.py</code> <pre><code>def termination(self):\n\"\"\"Termination process of a vService.\"\"\"\nreturn super().termination()\n</code></pre>"},{"location":"api/virtual_entity/v_service/#PyCloudSim.entity.v_service.vServiceBestFit","title":"<code>vServiceBestFit</code>","text":"<p>         Bases: <code>vService</code></p> <p>vService with best fit loadbalancer.</p> Source code in <code>PyCloudSim\\entity\\v_service.py</code> <pre><code>class vServiceBestFit(vService):\n\"\"\"vService with best fit loadbalancer.\"\"\"\ndef __init__(\nself,\nms: vMicroservice,\nports: List[int] = [],\nat: int | float | Callable[..., Any] = simulation.now,\nafter: Entity | List[Entity] | None = None,\nlabel: str | None = None,\n):\nsuper().__init__(ms, ports, at, after, label)\ndef loadbalancer(self):\nself.ms.containers.sort(key=lambda x: x.ram.utilization)\nself.ms.containers.sort(key=lambda x: x.cpu.utilization)\nfor container in self.ms.containers:\nif container.scheduled and not container.cordon and not container.terminated:\nreturn container\nreturn None\n</code></pre>"},{"location":"api/virtual_entity/v_service/#PyCloudSim.entity.v_service.vServiceRandom","title":"<code>vServiceRandom</code>","text":"<p>         Bases: <code>vService</code></p> <p>vService with random loadbalancer.</p> Source code in <code>PyCloudSim\\entity\\v_service.py</code> <pre><code>class vServiceRandom(vService):\n\"\"\"vService with random loadbalancer.\"\"\"\ndef __init__(\nself,\nms: vMicroservice,\nports: List[int] = [],\nat: int | float | Callable[..., Any] = simulation.now,\nafter: Entity | List[Entity] | None = None,\nlabel: str | None = None,\n):\nsuper().__init__(ms, ports, at, after, label)\ndef loadbalancer(self):\nif all(container.scheduled == False for container in self.ms.containers):\nreturn None\nelif all(container.cordon == True for container in self.ms.containers):\nreturn None\nelif all(container.terminated == True for container in self.ms.containers):\nreturn None\nelse:\nwhile True:\ncontainer = choice(self.ms.containers)\nif container.scheduled:\nreturn container\n</code></pre>"},{"location":"api/virtual_entity/v_service/#PyCloudSim.entity.v_service.vServiceRoundRobin","title":"<code>vServiceRoundRobin</code>","text":"<p>         Bases: <code>vService</code></p> <p>vService with round robin loadbalancer.</p> Source code in <code>PyCloudSim\\entity\\v_service.py</code> <pre><code>class vServiceRoundRobin(vService):\n\"\"\"vService with round robin loadbalancer.\"\"\"\ndef __init__(\nself,\nms: vMicroservice,\nports: List[int] = [],\nat: int | float | Callable[..., Any] = simulation.now,\nafter: Entity | List[Entity] | None = None,\nlabel: str | None = None,\n):\nsuper().__init__(ms, ports, at, after, label)\nself._container_pointer = 0\ndef loadbalancer(self):\nif all(container.scheduled == False for container in self.ms.containers):\nreturn None\nelif all(container.cordon == True for container in self.ms.containers):\nreturn None\nelif all(container.terminated == True for container in self.ms.containers):\nreturn None\nelse:\nwhile True:\ncontainer = self.ms.containers[self.container_pointer]\nself._container_pointer = (self.container_pointer + 1) % len(\nself.ms.containers\n)\nif container.scheduled:\nreturn container\n@property\ndef container_pointer(self):\nreturn self._container_pointer\n</code></pre>"},{"location":"api/virtual_entity/v_service/#PyCloudSim.entity.v_service.vServiceWorstFit","title":"<code>vServiceWorstFit</code>","text":"<p>         Bases: <code>vService</code></p> <p>vService with worst fit loadbalancer.</p> Source code in <code>PyCloudSim\\entity\\v_service.py</code> <pre><code>class vServiceWorstFit(vService):\n\"\"\"vService with worst fit loadbalancer.\"\"\"\ndef __init__(\nself,\nms: vMicroservice,\nports: List[int] = [],\nat: int | float | Callable[..., Any] = simulation.now,\nafter: Entity | List[Entity] | None = None,\nlabel: str | None = None,\n):\nsuper().__init__(ms, ports, at, after, label)\ndef loadbalancer(self):\nself.ms.containers.sort(key=lambda x: x.ram.utilization)\nself.ms.containers.sort(key=lambda x: x.cpu.utilization)\nfor container in reversed(self.ms.containers):\nif container.scheduled and not container.cordon and not container.terminated:\nreturn container\nreturn None\n</code></pre>"},{"location":"api/virtual_entity/v_user/","title":"vUser","text":"<p>         Bases: <code>VirtualEntity</code></p> Source code in <code>PyCloudSim\\entity\\v_user.py</code> <pre><code>class vUser(VirtualEntity):\n_requests: List[vRequest]\ndef __init__(\nself,\nat: Union[int, float, Callable] = simulation.now,\nafter: Optional[Entity | List[Entity]] = None,\nlabel: Optional[str] = None,\n):\n\"\"\"Create a vUser.\"\"\"\nsuper().__init__(at, after, label)\nself._user_requests: List[vUserRequest] = list()\nsimulation.USERS.append(self)\ndef creation(self):\n\"\"\"Creation process of the vUser\"\"\"\nreturn super().creation()\ndef termination(self):\n\"\"\"Termination process of the vUser\"\"\"\nreturn super().termination()\ndef request_sfc(\nself,\nsfc: vSFC,\npriority: Union[int, Callable] = 0,\nretry: Union[bool, Callable] = True,\nbackoff: Union[int, float, Callable] = lambda: random.random(),\nprocess_length: Union[int, Callable] = 100,\npacket_size: Union[int, Callable] = 65536,\nnum_packets: Union[int, Callable] = 1,\nat: Union[int, float, Callable] = simulation.now,\nafter: Optional[Entity | List[Entity]] = None,\n):\n\"\"\"Request a vSFC.\n        Args:\n            sfc (vSFC): the requested vSFC.\n            priority (Union[int, Callable], optional): the priority of the user request. Defaults to 0.\n            retry (Union[bool, Callable], optional): set to true if the user request will repeat untill sucess. Defaults to True.\n            backoff (_type_, optional): the random backoff. Defaults to lambda:random.random().\n            process_length (Union[int, Callable], optional): the length of generated process. Defaults to 100.\n            packet_size (Union[int, Callable], optional): the packet size of the packet size. Defaults to 65536.\n            num_packets (Union[int, Callable], optional): the number of the packet for this user request. Defaults to 1.\n            at (Union[int, float, Callable], optional): same as entity. Defaults to simulation.now.\n            after (Optional[Entity  |  List[Entity]], optional): same as entity. Defaults to None.\n        \"\"\"        \nuser_request = vUserRequest(\nat=at,\nafter=after,\nuser=self,\nsfc=sfc,\npriority=priority,\nprocess_length=process_length,\npacket_size=packet_size,\nnum_packets=num_packets,\nretry=retry,\nbackoff=backoff,\nlabel=f\"U-{self.label}-R-{len(self.user_request)}-SFC-{sfc.label}\",\n)\nself.user_request.append(user_request)\nreturn user_request\n@property\ndef user_request(self) -&gt; List[vUserRequest]:\n\"\"\"The list of user requests of the vUser.\"\"\"\nreturn self._user_requests\n</code></pre>"},{"location":"api/virtual_entity/v_user/#PyCloudSim.entity.v_user.vUser.user_request","title":"<code>user_request: List[vUserRequest]</code>  <code>property</code>","text":"<p>The list of user requests of the vUser.</p>"},{"location":"api/virtual_entity/v_user/#PyCloudSim.entity.v_user.vUser.__init__","title":"<code>__init__(at=simulation.now, after=None, label=None)</code>","text":"<p>Create a vUser.</p> Source code in <code>PyCloudSim\\entity\\v_user.py</code> <pre><code>def __init__(\nself,\nat: Union[int, float, Callable] = simulation.now,\nafter: Optional[Entity | List[Entity]] = None,\nlabel: Optional[str] = None,\n):\n\"\"\"Create a vUser.\"\"\"\nsuper().__init__(at, after, label)\nself._user_requests: List[vUserRequest] = list()\nsimulation.USERS.append(self)\n</code></pre>"},{"location":"api/virtual_entity/v_user/#PyCloudSim.entity.v_user.vUser.creation","title":"<code>creation()</code>","text":"<p>Creation process of the vUser</p> Source code in <code>PyCloudSim\\entity\\v_user.py</code> <pre><code>def creation(self):\n\"\"\"Creation process of the vUser\"\"\"\nreturn super().creation()\n</code></pre>"},{"location":"api/virtual_entity/v_user/#PyCloudSim.entity.v_user.vUser.request_sfc","title":"<code>request_sfc(sfc, priority=0, retry=True, backoff=lambda : random.random(), process_length=100, packet_size=65536, num_packets=1, at=simulation.now, after=None)</code>","text":"<p>Request a vSFC.</p> <p>Parameters:</p> Name Type Description Default <code>sfc</code> <code>vSFC</code> <p>the requested vSFC.</p> required <code>priority</code> <code>Union[int, Callable]</code> <p>the priority of the user request. Defaults to 0.</p> <code>0</code> <code>retry</code> <code>Union[bool, Callable]</code> <p>set to true if the user request will repeat untill sucess. Defaults to True.</p> <code>True</code> <code>backoff</code> <code>_type_</code> <p>the random backoff. Defaults to lambda:random.random().</p> <code>lambda : random.random()</code> <code>process_length</code> <code>Union[int, Callable]</code> <p>the length of generated process. Defaults to 100.</p> <code>100</code> <code>packet_size</code> <code>Union[int, Callable]</code> <p>the packet size of the packet size. Defaults to 65536.</p> <code>65536</code> <code>num_packets</code> <code>Union[int, Callable]</code> <p>the number of the packet for this user request. Defaults to 1.</p> <code>1</code> <code>at</code> <code>Union[int, float, Callable]</code> <p>same as entity. Defaults to simulation.now.</p> <code>simulation.now</code> <code>after</code> <code>Optional[Entity | List[Entity]]</code> <p>same as entity. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_user.py</code> <pre><code>def request_sfc(\nself,\nsfc: vSFC,\npriority: Union[int, Callable] = 0,\nretry: Union[bool, Callable] = True,\nbackoff: Union[int, float, Callable] = lambda: random.random(),\nprocess_length: Union[int, Callable] = 100,\npacket_size: Union[int, Callable] = 65536,\nnum_packets: Union[int, Callable] = 1,\nat: Union[int, float, Callable] = simulation.now,\nafter: Optional[Entity | List[Entity]] = None,\n):\n\"\"\"Request a vSFC.\n    Args:\n        sfc (vSFC): the requested vSFC.\n        priority (Union[int, Callable], optional): the priority of the user request. Defaults to 0.\n        retry (Union[bool, Callable], optional): set to true if the user request will repeat untill sucess. Defaults to True.\n        backoff (_type_, optional): the random backoff. Defaults to lambda:random.random().\n        process_length (Union[int, Callable], optional): the length of generated process. Defaults to 100.\n        packet_size (Union[int, Callable], optional): the packet size of the packet size. Defaults to 65536.\n        num_packets (Union[int, Callable], optional): the number of the packet for this user request. Defaults to 1.\n        at (Union[int, float, Callable], optional): same as entity. Defaults to simulation.now.\n        after (Optional[Entity  |  List[Entity]], optional): same as entity. Defaults to None.\n    \"\"\"        \nuser_request = vUserRequest(\nat=at,\nafter=after,\nuser=self,\nsfc=sfc,\npriority=priority,\nprocess_length=process_length,\npacket_size=packet_size,\nnum_packets=num_packets,\nretry=retry,\nbackoff=backoff,\nlabel=f\"U-{self.label}-R-{len(self.user_request)}-SFC-{sfc.label}\",\n)\nself.user_request.append(user_request)\nreturn user_request\n</code></pre>"},{"location":"api/virtual_entity/v_user/#PyCloudSim.entity.v_user.vUser.termination","title":"<code>termination()</code>","text":"<p>Termination process of the vUser</p> Source code in <code>PyCloudSim\\entity\\v_user.py</code> <pre><code>def termination(self):\n\"\"\"Termination process of the vUser\"\"\"\nreturn super().termination()\n</code></pre>"},{"location":"api/virtual_entity/v_user/#vuserrequest","title":"vUserRequest","text":"<p>         Bases: <code>VirtualEntity</code></p> Source code in <code>PyCloudSim\\entity\\v_user.py</code> <pre><code>class vUserRequest(VirtualEntity):\ndef __init__(\nself,\nuser: vUser,\nsfc: vSFC,\npriority: Union[int, Callable] = 0,\nretry: Union[bool, Callable] = True,\nbackoff: Union[int, float, Callable] = lambda: random.random(),\nprocess_length: Union[int, Callable] = 100,\npacket_size: Union[int, Callable] = 65536,\nnum_packets: Union[int, Callable] = 1,\nat: int | float | Callable[..., Any] = simulation.now,\nafter: Entity | List[Entity] | None = None,\nlabel: str | None = None,\n):\n\"\"\"Create a new vUserRequest.\n        Args:\n            user (vUser): the vUser.\n            sfc (vSFC): the requested vSFC.\n            priority (Union[int, Callable], optional): the priority of the user request. Defaults to 0.\n            retry (Union[bool, Callable], optional): set to true if repeat untill sucess. Defaults to True.\n            backoff (_type_, optional): the random backoff. Defaults to lambda:random.random().\n            process_length (Union[int, Callable], optional): the length of the generated process. Defaults to 100.\n            packet_size (Union[int, Callable], optional): the size of the generated packets. Defaults to 65536.\n            num_packets (Union[int, Callable], optional): the number of generated packets. Defaults to 1.\n            at (int | float | Callable[..., Any], optional): same as entity. Defaults to simulation.now.\n            after (Entity | List[Entity] | None, optional): same as entity. Defaults to None.\n            label (str | None, optional): same as entity. Defaults to None.\n        \"\"\"\nsuper().__init__(at, after, label)\nself._user = user\nself._sfc_id = sfc.id\nself._priority = priority\nself._retry = retry\nself._backoff = backoff\nself._process_length = process_length\nself._packet_size = packet_size\nself._num_packets = num_packets\nself._flows: List[WorkFlow] = list()\ndef creation(self):\n\"\"\"Creation process of the vUserRequest\"\"\"\nself.initialize_workflow()\nsimulation.USER_REQUESTS.append(self)\nreturn super().creation()\ndef initialize_workflow(self, delay: int | float = 0):\n\"\"\"Initialize a workflow for the user request.\"\"\"\ndef _initialize_workflow():\nif self.sfc.ready:\nflow = WorkFlow(\nat=simulation.now,\nuser=self.user,\nuser_request=self,\nsfc=self.sfc,\npriority=self.priority,\nprocess_length=self.process_length,\npacket_size=self.packet_size,\nnum_packets=self.num_packets,\nlabel=f\"{self.label}-F-{len(self.flows)}\",\n)\nself.flows.append(flow)\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\tvUser {self.label} requests SFC {self.sfc.label} as WorkFlow {flow.label}.\"\n)\nelse:\nif callable(self.backoff):\nActor(\nat=simulation.now + self.backoff(),\naction=_initialize_workflow,\nlabel=f\"vUserRequest {self.label} Initialize Workflow\",\n)\nelse:\nActor(\nat=simulation.now + self.backoff,\naction=_initialize_workflow,\nlabel=f\"vUserRequest {self.label} Initialize Workflow\",\n)\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\tvUserRequest {self.label} backs off Workflow initialization because SFC {self.sfc.label} is not ready.\"\n)\nActor(\nat=simulation.now+delay,\naction=_initialize_workflow,\nlabel=f\"vUserRequest {self.label} Initialize Workflow\",\npriority=CREATION\n)\ndef termination(self):\n\"\"\"Termination process of the vUserRequest\"\"\"\nsuper().termination()\nif all(user_request.completed for user_request in simulation.USER_REQUESTS):\nsimulation._env.stop()\ndef fail(self):\n\"\"\"Fail the user request and engage the termination process if no retry is set.\"\"\"\nLOGGER.info(f\"{simulation.now:0.2f}:\\tvUserRequest {self.label} failed, retries.\")\nif callable(self.backoff):\nself.initialize_workflow(delay=self.backoff())\nelse:\nself.initialize_workflow(delay=self.backoff)\ndef complete(self):\n\"\"\"Complete the user request and engage the termination process.\"\"\"\nself.status.append(COMPLETED)\nLOGGER.info(f\"{simulation.now:0.2f}:\\tvUserRequest {self.label} completed.\")\nself.terminate()\n@property\ndef user(self):\n\"\"\"Return the vUser of the vUserRequest.\"\"\"\nreturn self._user\n@property\ndef process_length(self):\n\"\"\"Return the process length of the vUserRequest.\"\"\"\nreturn self._process_length\n@property\ndef packet_size(self):\n\"\"\"Return the packet size\"\"\"\nreturn self._packet_size\n@property\ndef num_packets(self):\n\"\"\"Return the number of packets\"\"\"\nreturn self._num_packets\n@property\ndef priority(self):\n\"\"\"Return the priority of the vUserRequest.\"\"\"\nreturn self._priority\n@property\ndef retry(self):\n\"\"\"Return the retry of the vUserRequest.\"\"\"\nreturn self._retry\n@property\ndef backoff(self):\n\"\"\"Return the backoff of the vUserRequest.\"\"\"\nreturn self._backoff\n@property\ndef sfc_id(self):\n\"\"\"Return the sfc id of the vUserRequest.\"\"\"\nreturn self._sfc_id\n@property\ndef sfc(self) -&gt; vSFC:\n\"\"\"Return the vSFC of the vUserRequest.\"\"\"\nfor sfc in simulation.SFCS:\nif sfc.id == self._sfc_id:\nreturn sfc\nraise ValueError(f\"SFCFlow {self.label} can not find its associated vSFC.\")\n@property\ndef flows(self) -&gt; List[WorkFlow]:\n\"\"\"Return the list of WorkFlows of the vUserRequest.\"\"\"\nreturn self._flows\n</code></pre>"},{"location":"api/virtual_entity/v_user/#PyCloudSim.entity.v_user.vUserRequest.backoff","title":"<code>backoff</code>  <code>property</code>","text":"<p>Return the backoff of the vUserRequest.</p>"},{"location":"api/virtual_entity/v_user/#PyCloudSim.entity.v_user.vUserRequest.flows","title":"<code>flows: List[WorkFlow]</code>  <code>property</code>","text":"<p>Return the list of WorkFlows of the vUserRequest.</p>"},{"location":"api/virtual_entity/v_user/#PyCloudSim.entity.v_user.vUserRequest.num_packets","title":"<code>num_packets</code>  <code>property</code>","text":"<p>Return the number of packets</p>"},{"location":"api/virtual_entity/v_user/#PyCloudSim.entity.v_user.vUserRequest.packet_size","title":"<code>packet_size</code>  <code>property</code>","text":"<p>Return the packet size</p>"},{"location":"api/virtual_entity/v_user/#PyCloudSim.entity.v_user.vUserRequest.priority","title":"<code>priority</code>  <code>property</code>","text":"<p>Return the priority of the vUserRequest.</p>"},{"location":"api/virtual_entity/v_user/#PyCloudSim.entity.v_user.vUserRequest.process_length","title":"<code>process_length</code>  <code>property</code>","text":"<p>Return the process length of the vUserRequest.</p>"},{"location":"api/virtual_entity/v_user/#PyCloudSim.entity.v_user.vUserRequest.retry","title":"<code>retry</code>  <code>property</code>","text":"<p>Return the retry of the vUserRequest.</p>"},{"location":"api/virtual_entity/v_user/#PyCloudSim.entity.v_user.vUserRequest.sfc","title":"<code>sfc: vSFC</code>  <code>property</code>","text":"<p>Return the vSFC of the vUserRequest.</p>"},{"location":"api/virtual_entity/v_user/#PyCloudSim.entity.v_user.vUserRequest.sfc_id","title":"<code>sfc_id</code>  <code>property</code>","text":"<p>Return the sfc id of the vUserRequest.</p>"},{"location":"api/virtual_entity/v_user/#PyCloudSim.entity.v_user.vUserRequest.user","title":"<code>user</code>  <code>property</code>","text":"<p>Return the vUser of the vUserRequest.</p>"},{"location":"api/virtual_entity/v_user/#PyCloudSim.entity.v_user.vUserRequest.__init__","title":"<code>__init__(user, sfc, priority=0, retry=True, backoff=lambda : random.random(), process_length=100, packet_size=65536, num_packets=1, at=simulation.now, after=None, label=None)</code>","text":"<p>Create a new vUserRequest.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>vUser</code> <p>the vUser.</p> required <code>sfc</code> <code>vSFC</code> <p>the requested vSFC.</p> required <code>priority</code> <code>Union[int, Callable]</code> <p>the priority of the user request. Defaults to 0.</p> <code>0</code> <code>retry</code> <code>Union[bool, Callable]</code> <p>set to true if repeat untill sucess. Defaults to True.</p> <code>True</code> <code>backoff</code> <code>_type_</code> <p>the random backoff. Defaults to lambda:random.random().</p> <code>lambda : random.random()</code> <code>process_length</code> <code>Union[int, Callable]</code> <p>the length of the generated process. Defaults to 100.</p> <code>100</code> <code>packet_size</code> <code>Union[int, Callable]</code> <p>the size of the generated packets. Defaults to 65536.</p> <code>65536</code> <code>num_packets</code> <code>Union[int, Callable]</code> <p>the number of generated packets. Defaults to 1.</p> <code>1</code> <code>at</code> <code>int | float | Callable[..., Any]</code> <p>same as entity. Defaults to simulation.now.</p> <code>simulation.now</code> <code>after</code> <code>Entity | List[Entity] | None</code> <p>same as entity. Defaults to None.</p> <code>None</code> <code>label</code> <code>str | None</code> <p>same as entity. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_user.py</code> <pre><code>def __init__(\nself,\nuser: vUser,\nsfc: vSFC,\npriority: Union[int, Callable] = 0,\nretry: Union[bool, Callable] = True,\nbackoff: Union[int, float, Callable] = lambda: random.random(),\nprocess_length: Union[int, Callable] = 100,\npacket_size: Union[int, Callable] = 65536,\nnum_packets: Union[int, Callable] = 1,\nat: int | float | Callable[..., Any] = simulation.now,\nafter: Entity | List[Entity] | None = None,\nlabel: str | None = None,\n):\n\"\"\"Create a new vUserRequest.\n    Args:\n        user (vUser): the vUser.\n        sfc (vSFC): the requested vSFC.\n        priority (Union[int, Callable], optional): the priority of the user request. Defaults to 0.\n        retry (Union[bool, Callable], optional): set to true if repeat untill sucess. Defaults to True.\n        backoff (_type_, optional): the random backoff. Defaults to lambda:random.random().\n        process_length (Union[int, Callable], optional): the length of the generated process. Defaults to 100.\n        packet_size (Union[int, Callable], optional): the size of the generated packets. Defaults to 65536.\n        num_packets (Union[int, Callable], optional): the number of generated packets. Defaults to 1.\n        at (int | float | Callable[..., Any], optional): same as entity. Defaults to simulation.now.\n        after (Entity | List[Entity] | None, optional): same as entity. Defaults to None.\n        label (str | None, optional): same as entity. Defaults to None.\n    \"\"\"\nsuper().__init__(at, after, label)\nself._user = user\nself._sfc_id = sfc.id\nself._priority = priority\nself._retry = retry\nself._backoff = backoff\nself._process_length = process_length\nself._packet_size = packet_size\nself._num_packets = num_packets\nself._flows: List[WorkFlow] = list()\n</code></pre>"},{"location":"api/virtual_entity/v_user/#PyCloudSim.entity.v_user.vUserRequest.complete","title":"<code>complete()</code>","text":"<p>Complete the user request and engage the termination process.</p> Source code in <code>PyCloudSim\\entity\\v_user.py</code> <pre><code>def complete(self):\n\"\"\"Complete the user request and engage the termination process.\"\"\"\nself.status.append(COMPLETED)\nLOGGER.info(f\"{simulation.now:0.2f}:\\tvUserRequest {self.label} completed.\")\nself.terminate()\n</code></pre>"},{"location":"api/virtual_entity/v_user/#PyCloudSim.entity.v_user.vUserRequest.creation","title":"<code>creation()</code>","text":"<p>Creation process of the vUserRequest</p> Source code in <code>PyCloudSim\\entity\\v_user.py</code> <pre><code>def creation(self):\n\"\"\"Creation process of the vUserRequest\"\"\"\nself.initialize_workflow()\nsimulation.USER_REQUESTS.append(self)\nreturn super().creation()\n</code></pre>"},{"location":"api/virtual_entity/v_user/#PyCloudSim.entity.v_user.vUserRequest.fail","title":"<code>fail()</code>","text":"<p>Fail the user request and engage the termination process if no retry is set.</p> Source code in <code>PyCloudSim\\entity\\v_user.py</code> <pre><code>def fail(self):\n\"\"\"Fail the user request and engage the termination process if no retry is set.\"\"\"\nLOGGER.info(f\"{simulation.now:0.2f}:\\tvUserRequest {self.label} failed, retries.\")\nif callable(self.backoff):\nself.initialize_workflow(delay=self.backoff())\nelse:\nself.initialize_workflow(delay=self.backoff)\n</code></pre>"},{"location":"api/virtual_entity/v_user/#PyCloudSim.entity.v_user.vUserRequest.initialize_workflow","title":"<code>initialize_workflow(delay=0)</code>","text":"<p>Initialize a workflow for the user request.</p> Source code in <code>PyCloudSim\\entity\\v_user.py</code> <pre><code>def initialize_workflow(self, delay: int | float = 0):\n\"\"\"Initialize a workflow for the user request.\"\"\"\ndef _initialize_workflow():\nif self.sfc.ready:\nflow = WorkFlow(\nat=simulation.now,\nuser=self.user,\nuser_request=self,\nsfc=self.sfc,\npriority=self.priority,\nprocess_length=self.process_length,\npacket_size=self.packet_size,\nnum_packets=self.num_packets,\nlabel=f\"{self.label}-F-{len(self.flows)}\",\n)\nself.flows.append(flow)\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\tvUser {self.label} requests SFC {self.sfc.label} as WorkFlow {flow.label}.\"\n)\nelse:\nif callable(self.backoff):\nActor(\nat=simulation.now + self.backoff(),\naction=_initialize_workflow,\nlabel=f\"vUserRequest {self.label} Initialize Workflow\",\n)\nelse:\nActor(\nat=simulation.now + self.backoff,\naction=_initialize_workflow,\nlabel=f\"vUserRequest {self.label} Initialize Workflow\",\n)\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\tvUserRequest {self.label} backs off Workflow initialization because SFC {self.sfc.label} is not ready.\"\n)\nActor(\nat=simulation.now+delay,\naction=_initialize_workflow,\nlabel=f\"vUserRequest {self.label} Initialize Workflow\",\npriority=CREATION\n)\n</code></pre>"},{"location":"api/virtual_entity/v_user/#PyCloudSim.entity.v_user.vUserRequest.termination","title":"<code>termination()</code>","text":"<p>Termination process of the vUserRequest</p> Source code in <code>PyCloudSim\\entity\\v_user.py</code> <pre><code>def termination(self):\n\"\"\"Termination process of the vUserRequest\"\"\"\nsuper().termination()\nif all(user_request.completed for user_request in simulation.USER_REQUESTS):\nsimulation._env.stop()\n</code></pre>"},{"location":"api/virtual_entity/v_user/#workflow","title":"WorkFLow","text":"<p>         Bases: <code>VirtualEntity</code></p> Source code in <code>PyCloudSim\\entity\\v_user.py</code> <pre><code>class WorkFlow(VirtualEntity):\ndef __init__(\nself,\nuser: vUser,\nuser_request: vUserRequest,\nsfc: vSFC,\nprocess_length: Union[int, Callable] = 100,\npacket_size: Union[int, Callable] = 65536,\nnum_packets: Union[int, Callable] = 1,\npriority: Union[int, Callable] = 0,\nat: int | float | Callable[..., Any] = simulation.now,\nafter: Entity | List[Entity] | None = None,\nlabel: str | None = None,\n):\n\"\"\"Create a new WorkFlow.\n        Args:\n            user (vUser): the vUser.\n            sfc (vSFC): the vSFC.\n            process_length (Union[int, Callable], optional): the process length. Defaults to 100.\n            packet_size (Union[int, Callable], optional): the packet size. Defaults to 65536.\n            num_packets (Union[int, Callable], optional): the number of packet (Do not change the GET/ACK packet). Defaults to 1.\n            priority (Union[int, Callable], optional): the priority of the workflow. Defaults to 0.\n            retry (Union[bool, Callable], optional): set true for retrying until complete. Defaults to True.\n            retry_delay (_type_, optional): the delay beofore retrying the workflow. Defaults to lambda:random.random().\n            at (int | float | Callable[..., Any], optional): when the workflow should be created. Defaults to simulation.now.\n            after (Entity | List[Entity] | None, optional): the entity that the workflow must be created after. Defaults to None.\n            label (str | None, optional): short desciption of the workflow. Defaults to None.\n        \"\"\"\nsuper().__init__(at, after, label)\nself._user = user\nself._user_request = user_request\nself._sfc_id = sfc.id\nself._process_length = process_length\nself._packet_size = packet_size\nself._num_packets = num_packets\nself._priority = priority\nself._requests = list()\nself._on_creation = self.initialize_requests\nsimulation.WORKFLOWS.append(self)\ndef termination(self):\nif self.completed:\nself.user_request.complete()\nif self.failed:\nself.user_request.fail()            \nsuper().termination()\ndef initialize_requests(self, delay: int | float = 0):\nif self.sfc.entry is not None and not self.sfc.internal:\nself.requests.append(\nvRequest(\nat=simulation.now,\nsource=self.user,\ntarget=self.sfc.entry[0],\nflow=self,\ntype=self.sfc.entry[1],\nlabel=f\"{self.label}-R-{len(self.requests)}\",\n)\n)\n# initialize path request\nfor link in self.sfc.path:\nself.requests.append(\nvRequest(\nat=simulation.now,\nsource=link[0],\ntarget=link[1],\ntype=link[2],\nflow=self,\nlabel=f\"{self.label}-R-{len(self.requests)}\",\nafter=self.requests[-1] if len(self.requests) &gt; 0 else None,\n)\n)\n# initialize tail request\nif self.sfc.exit is not None and not self.sfc.internal:\nself.requests.append(\nvRequest(\nat=simulation.now,\nsource=self.sfc.exit[0],\ntarget=self.user,\ntype=self.sfc.exit[1],\nflow=self,\nlabel=f\"{self.label}-R-{len(self.requests)}\",\nafter=self.requests[-1] if len(self.requests) &gt; 0 else None,\n)\n)\nself.requests[-1]._on_termination = (\nlambda: self.complete()\nif self.requests[-1].completed and not self.failed\nelse None\n)\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\tWorkflow {self.label} initialized vRequests.\"\n)\ndef complete(self):\n\"\"\"COMPLETE the workflow and engage the termination process.\"\"\"\nself.status.append(COMPLETED)\nself.terminate()\nLOGGER.info(f\"{simulation.now:0.2f}:\\tWorkflow {self.label} completed.\")\ndef fail(self):\n\"\"\"Fail the workflow and engage the termination process if no retry is set.\"\"\"\nself.status.append(FAILED)\nself.terminate()\nLOGGER.info(f\"{simulation.now:0.2f}:\\tWorkflow {self.label} failed.\")\n@property\ndef requests(self) -&gt; List[vRequest]:\nreturn self._requests\n@property\ndef user(self):\nreturn self._user\n@property\ndef user_request(self):\nreturn self._user_request\n@property\ndef process_length(self):\nreturn self._process_length\n@property\ndef packet_size(self):\nreturn self._packet_size\n@property\ndef num_packets(self):\nreturn self._num_packets\n@property\ndef priority(self):\nreturn self._priority\n@property\ndef sfc_id(self):\nreturn self._sfc_id\n@property\ndef sfc(self) -&gt; vSFC:\nfor sfc in simulation.SFCS:\nif sfc.id == self._sfc_id:\nreturn sfc\nraise ValueError(f\"SFCFlow {self.label} can not find its associated vSFC.\")\n</code></pre>"},{"location":"api/virtual_entity/v_user/#PyCloudSim.entity.v_user.WorkFlow.__init__","title":"<code>__init__(user, user_request, sfc, process_length=100, packet_size=65536, num_packets=1, priority=0, at=simulation.now, after=None, label=None)</code>","text":"<p>Create a new WorkFlow.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>vUser</code> <p>the vUser.</p> required <code>sfc</code> <code>vSFC</code> <p>the vSFC.</p> required <code>process_length</code> <code>Union[int, Callable]</code> <p>the process length. Defaults to 100.</p> <code>100</code> <code>packet_size</code> <code>Union[int, Callable]</code> <p>the packet size. Defaults to 65536.</p> <code>65536</code> <code>num_packets</code> <code>Union[int, Callable]</code> <p>the number of packet (Do not change the GET/ACK packet). Defaults to 1.</p> <code>1</code> <code>priority</code> <code>Union[int, Callable]</code> <p>the priority of the workflow. Defaults to 0.</p> <code>0</code> <code>retry</code> <code>Union[bool, Callable]</code> <p>set true for retrying until complete. Defaults to True.</p> required <code>retry_delay</code> <code>_type_</code> <p>the delay beofore retrying the workflow. Defaults to lambda:random.random().</p> required <code>at</code> <code>int | float | Callable[..., Any]</code> <p>when the workflow should be created. Defaults to simulation.now.</p> <code>simulation.now</code> <code>after</code> <code>Entity | List[Entity] | None</code> <p>the entity that the workflow must be created after. Defaults to None.</p> <code>None</code> <code>label</code> <code>str | None</code> <p>short desciption of the workflow. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_user.py</code> <pre><code>def __init__(\nself,\nuser: vUser,\nuser_request: vUserRequest,\nsfc: vSFC,\nprocess_length: Union[int, Callable] = 100,\npacket_size: Union[int, Callable] = 65536,\nnum_packets: Union[int, Callable] = 1,\npriority: Union[int, Callable] = 0,\nat: int | float | Callable[..., Any] = simulation.now,\nafter: Entity | List[Entity] | None = None,\nlabel: str | None = None,\n):\n\"\"\"Create a new WorkFlow.\n    Args:\n        user (vUser): the vUser.\n        sfc (vSFC): the vSFC.\n        process_length (Union[int, Callable], optional): the process length. Defaults to 100.\n        packet_size (Union[int, Callable], optional): the packet size. Defaults to 65536.\n        num_packets (Union[int, Callable], optional): the number of packet (Do not change the GET/ACK packet). Defaults to 1.\n        priority (Union[int, Callable], optional): the priority of the workflow. Defaults to 0.\n        retry (Union[bool, Callable], optional): set true for retrying until complete. Defaults to True.\n        retry_delay (_type_, optional): the delay beofore retrying the workflow. Defaults to lambda:random.random().\n        at (int | float | Callable[..., Any], optional): when the workflow should be created. Defaults to simulation.now.\n        after (Entity | List[Entity] | None, optional): the entity that the workflow must be created after. Defaults to None.\n        label (str | None, optional): short desciption of the workflow. Defaults to None.\n    \"\"\"\nsuper().__init__(at, after, label)\nself._user = user\nself._user_request = user_request\nself._sfc_id = sfc.id\nself._process_length = process_length\nself._packet_size = packet_size\nself._num_packets = num_packets\nself._priority = priority\nself._requests = list()\nself._on_creation = self.initialize_requests\nsimulation.WORKFLOWS.append(self)\n</code></pre>"},{"location":"api/virtual_entity/v_user/#PyCloudSim.entity.v_user.WorkFlow.complete","title":"<code>complete()</code>","text":"<p>COMPLETE the workflow and engage the termination process.</p> Source code in <code>PyCloudSim\\entity\\v_user.py</code> <pre><code>def complete(self):\n\"\"\"COMPLETE the workflow and engage the termination process.\"\"\"\nself.status.append(COMPLETED)\nself.terminate()\nLOGGER.info(f\"{simulation.now:0.2f}:\\tWorkflow {self.label} completed.\")\n</code></pre>"},{"location":"api/virtual_entity/v_user/#PyCloudSim.entity.v_user.WorkFlow.fail","title":"<code>fail()</code>","text":"<p>Fail the workflow and engage the termination process if no retry is set.</p> Source code in <code>PyCloudSim\\entity\\v_user.py</code> <pre><code>def fail(self):\n\"\"\"Fail the workflow and engage the termination process if no retry is set.\"\"\"\nself.status.append(FAILED)\nself.terminate()\nLOGGER.info(f\"{simulation.now:0.2f}:\\tWorkflow {self.label} failed.\")\n</code></pre>"},{"location":"api/virtual_entity/v_volume/","title":"vVolume","text":"<p>The class \"vVolume\" is implemented to resemble a volume that can be attached to a container in Docker or Kubernetes which consumes the ROM from \"vHost\". A \"vContainer\" could be attached with multiple \"vVolume\" and those  \"vVolume\" could be allocated on different \"vHost\" rather than the \"vHost\" where the \"vContainer\" is hosted. A \"vVolume\" could be persistent by setting attribute \"retain\" equals to true. If a \"vVolume\" is persistent, it will not be destoried when its associated \"vContainer\" is terminated and could be reattached to a new instance of the \"vContainer\". The \"vVolume\" must be allocated first before a \"vContainer\" is scheduled. If any \"vVolume\" is failed to be allocated onto \"vHost\", the schedule of its associated \"vContainer\" will be on hold.</p> <p>         Bases: <code>VirtualEntity</code></p> Source code in <code>PyCloudSim\\entity\\v_volume.py</code> <pre><code>class vVolume(VirtualEntity):\ndef __init__(\nself,\ntag: Optional[str] = None,\npath: Optional[str] = None,\nsize: int = 100,\nretain: bool = False,\ntaint: Optional[str] = None,\nat: Union[int, float, Callable] = simulation.now,\nafter: Optional[Entity | List[Entity]] = None,\nlabel: Optional[str] = None,\n):\n\"\"\"Create a vVolume.\n        Args:\n            tag (Optional[str], optional): the tag of the vVolume. Defaults to None.\n            path (Optional[str], optional): the path of the vVolume. Defaults to None.\n            size (int, optional): the sime of the vVolume in MiB. Defaults to 100.\n            retain (bool, optional): set true if the vVolume will be retained. Defaults to False.\n            taint (Optional[str], optional): the taint of the vVolume. Defaults to None.\n            at (Union[int, float, Callable], optional): same as entity. Defaults to simulation.now.\n            after (Optional[Entity  |  List[Entity]], optional): same as entity. Defaults to None.\n            label (Optional[str], optional): same as entity. Defaults to None.\n        \"\"\"        \nsuper().__init__(at, after, label)\nself._container_id = int()\nself._host_id = int()\nself._tag = tag or str()\nself._path = path or str()\nself._size = MiB(size)\nself._retain = retain\nself._taint = taint or str()\nself._attached = False\nself._allocated = False\nself._on_creation = simulation.volume_allocator.allocate\nsimulation.VOLUMES.append(self)\ndef termination(self):\n\"\"\"The termination of a vVolume.\"\"\"\nsuper().termination()\nif self.allocated:\nself.host.rom.release(self)\nsimulation.volume_allocator.allocate()\ndef attach(self, container: vContainer):\n\"\"\"Attach the vVolume to a vContainer.\"\"\"\ndef _attach():\nself._container_id = container.id\nself._attached = True\nLOGGER.info(f\"{simulation.now:0.2f}:\\tVirtual Volume {self.label} is attached to vContainer {container.label}.\")\nActor(\naction=_attach,\nat=simulation.now,\nlabel=f\"vVolume {self.label} Attach\",\npriority=VOLUME_ATACH,\n)\ndef detach(self):\n\"\"\"Detach the vVolume from a vContainer.\"\"\"\ndef _detach():\nLOGGER.info(f\"{simulation.now:0.2f}:\\tVirtual Volume {self.label} is detached from vContainer {self.container.label}.\")\nself._container_id = int()\nself._attached = False\nActor(\naction=_detach,\nat=simulation.now,\nlabel=f\"vVolume {self.label} Detach\",\npriority=VOLUME_DETACH,\n)\n@property\ndef container_id(self) -&gt; int:\n\"\"\"The id of the vContainer that the vVolume is attached to.\"\"\"\nreturn self._container_id\n@property\ndef container(self) -&gt; vContainer:\n\"\"\"The vContainer that the vVolume is attached to.\"\"\"\nfor container in simulation.CONTAINERS:\nif container.id == self.container_id:\nreturn container\nwarnings.warn(f\"Virtual Volume {self.label} is detached.\")\nreturn None  # type: ignore\n@property\ndef host_id(self) -&gt; int:\n\"\"\"The id of the vHost that the vVolume is allocated on.\"\"\"\nreturn self._host_id\n@property\ndef host(self) -&gt; vHost:\n\"\"\"The vHost that the vVolume is allocated on.\"\"\"\nfor host in simulation.HOSTS:\nif host.id == self.host_id:\nreturn host\nraise RuntimeError(f\"Virtual Volume {self.label} is not allocated on any host.\")\n@property\ndef tag(self) -&gt; str:\n\"\"\"The tag of the vVolume.\"\"\"\nreturn self._tag\n@property\ndef path(self) -&gt; str:\n\"\"\"The path of the vVolume.\"\"\"\nreturn self._path\n@property\ndef size(self) -&gt; Union[int, float]:\n\"\"\"The size of the vVolume in MiB.\"\"\"\nreturn self._size.bytes\n@property\ndef retain(self) -&gt; bool:\n\"\"\"Return true if the vVolume is retained.\"\"\"\nreturn self._retain\n@property\ndef taint(self) -&gt; str:\n\"\"\"The taint of the vVolume.\"\"\"\nreturn self._taint\n@property\ndef attached(self) -&gt; bool:\n\"\"\"Check if the vVolume is attached to a vContainer.\"\"\"\nreturn self._attached\n@property\ndef allocated(self) -&gt; bool:\n\"\"\"Check if the vVolume is allocated on a vHost.\"\"\"\nreturn self._allocated\n</code></pre>"},{"location":"api/virtual_entity/v_volume/#PyCloudSim.entity.v_volume.vVolume.allocated","title":"<code>allocated: bool</code>  <code>property</code>","text":"<p>Check if the vVolume is allocated on a vHost.</p>"},{"location":"api/virtual_entity/v_volume/#PyCloudSim.entity.v_volume.vVolume.attached","title":"<code>attached: bool</code>  <code>property</code>","text":"<p>Check if the vVolume is attached to a vContainer.</p>"},{"location":"api/virtual_entity/v_volume/#PyCloudSim.entity.v_volume.vVolume.container","title":"<code>container: vContainer</code>  <code>property</code>","text":"<p>The vContainer that the vVolume is attached to.</p>"},{"location":"api/virtual_entity/v_volume/#PyCloudSim.entity.v_volume.vVolume.container_id","title":"<code>container_id: int</code>  <code>property</code>","text":"<p>The id of the vContainer that the vVolume is attached to.</p>"},{"location":"api/virtual_entity/v_volume/#PyCloudSim.entity.v_volume.vVolume.host","title":"<code>host: vHost</code>  <code>property</code>","text":"<p>The vHost that the vVolume is allocated on.</p>"},{"location":"api/virtual_entity/v_volume/#PyCloudSim.entity.v_volume.vVolume.host_id","title":"<code>host_id: int</code>  <code>property</code>","text":"<p>The id of the vHost that the vVolume is allocated on.</p>"},{"location":"api/virtual_entity/v_volume/#PyCloudSim.entity.v_volume.vVolume.path","title":"<code>path: str</code>  <code>property</code>","text":"<p>The path of the vVolume.</p>"},{"location":"api/virtual_entity/v_volume/#PyCloudSim.entity.v_volume.vVolume.retain","title":"<code>retain: bool</code>  <code>property</code>","text":"<p>Return true if the vVolume is retained.</p>"},{"location":"api/virtual_entity/v_volume/#PyCloudSim.entity.v_volume.vVolume.size","title":"<code>size: Union[int, float]</code>  <code>property</code>","text":"<p>The size of the vVolume in MiB.</p>"},{"location":"api/virtual_entity/v_volume/#PyCloudSim.entity.v_volume.vVolume.tag","title":"<code>tag: str</code>  <code>property</code>","text":"<p>The tag of the vVolume.</p>"},{"location":"api/virtual_entity/v_volume/#PyCloudSim.entity.v_volume.vVolume.taint","title":"<code>taint: str</code>  <code>property</code>","text":"<p>The taint of the vVolume.</p>"},{"location":"api/virtual_entity/v_volume/#PyCloudSim.entity.v_volume.vVolume.__init__","title":"<code>__init__(tag=None, path=None, size=100, retain=False, taint=None, at=simulation.now, after=None, label=None)</code>","text":"<p>Create a vVolume.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>Optional[str]</code> <p>the tag of the vVolume. Defaults to None.</p> <code>None</code> <code>path</code> <code>Optional[str]</code> <p>the path of the vVolume. Defaults to None.</p> <code>None</code> <code>size</code> <code>int</code> <p>the sime of the vVolume in MiB. Defaults to 100.</p> <code>100</code> <code>retain</code> <code>bool</code> <p>set true if the vVolume will be retained. Defaults to False.</p> <code>False</code> <code>taint</code> <code>Optional[str]</code> <p>the taint of the vVolume. Defaults to None.</p> <code>None</code> <code>at</code> <code>Union[int, float, Callable]</code> <p>same as entity. Defaults to simulation.now.</p> <code>simulation.now</code> <code>after</code> <code>Optional[Entity | List[Entity]]</code> <p>same as entity. Defaults to None.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>same as entity. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_volume.py</code> <pre><code>def __init__(\nself,\ntag: Optional[str] = None,\npath: Optional[str] = None,\nsize: int = 100,\nretain: bool = False,\ntaint: Optional[str] = None,\nat: Union[int, float, Callable] = simulation.now,\nafter: Optional[Entity | List[Entity]] = None,\nlabel: Optional[str] = None,\n):\n\"\"\"Create a vVolume.\n    Args:\n        tag (Optional[str], optional): the tag of the vVolume. Defaults to None.\n        path (Optional[str], optional): the path of the vVolume. Defaults to None.\n        size (int, optional): the sime of the vVolume in MiB. Defaults to 100.\n        retain (bool, optional): set true if the vVolume will be retained. Defaults to False.\n        taint (Optional[str], optional): the taint of the vVolume. Defaults to None.\n        at (Union[int, float, Callable], optional): same as entity. Defaults to simulation.now.\n        after (Optional[Entity  |  List[Entity]], optional): same as entity. Defaults to None.\n        label (Optional[str], optional): same as entity. Defaults to None.\n    \"\"\"        \nsuper().__init__(at, after, label)\nself._container_id = int()\nself._host_id = int()\nself._tag = tag or str()\nself._path = path or str()\nself._size = MiB(size)\nself._retain = retain\nself._taint = taint or str()\nself._attached = False\nself._allocated = False\nself._on_creation = simulation.volume_allocator.allocate\nsimulation.VOLUMES.append(self)\n</code></pre>"},{"location":"api/virtual_entity/v_volume/#PyCloudSim.entity.v_volume.vVolume.attach","title":"<code>attach(container)</code>","text":"<p>Attach the vVolume to a vContainer.</p> Source code in <code>PyCloudSim\\entity\\v_volume.py</code> <pre><code>def attach(self, container: vContainer):\n\"\"\"Attach the vVolume to a vContainer.\"\"\"\ndef _attach():\nself._container_id = container.id\nself._attached = True\nLOGGER.info(f\"{simulation.now:0.2f}:\\tVirtual Volume {self.label} is attached to vContainer {container.label}.\")\nActor(\naction=_attach,\nat=simulation.now,\nlabel=f\"vVolume {self.label} Attach\",\npriority=VOLUME_ATACH,\n)\n</code></pre>"},{"location":"api/virtual_entity/v_volume/#PyCloudSim.entity.v_volume.vVolume.detach","title":"<code>detach()</code>","text":"<p>Detach the vVolume from a vContainer.</p> Source code in <code>PyCloudSim\\entity\\v_volume.py</code> <pre><code>def detach(self):\n\"\"\"Detach the vVolume from a vContainer.\"\"\"\ndef _detach():\nLOGGER.info(f\"{simulation.now:0.2f}:\\tVirtual Volume {self.label} is detached from vContainer {self.container.label}.\")\nself._container_id = int()\nself._attached = False\nActor(\naction=_detach,\nat=simulation.now,\nlabel=f\"vVolume {self.label} Detach\",\npriority=VOLUME_DETACH,\n)\n</code></pre>"},{"location":"api/virtual_entity/v_volume/#PyCloudSim.entity.v_volume.vVolume.termination","title":"<code>termination()</code>","text":"<p>The termination of a vVolume.</p> Source code in <code>PyCloudSim\\entity\\v_volume.py</code> <pre><code>def termination(self):\n\"\"\"The termination of a vVolume.\"\"\"\nsuper().termination()\nif self.allocated:\nself.host.rom.release(self)\nsimulation.volume_allocator.allocate()\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/","title":"Index","text":"<p>The \"vProcess\" class represents a simulated computation task similar to a \"Cloudlet\" in CloudSim (Plus). It contains a randomly generated set of instructions, measured in bytes, and the RAM usage is determined by the total length of the instruction set. The \"vCPU\" distributes the \"vProcess\" onto the available \"vCPUCore\" instances, where the instructions of the \"vProcess\" are consumed. Once all instructions have been executed, the \"vProcess\" is considered completed, and a termination process is initiated to release the computational resources. However, the \"vProcess\" may also be terminated abruptly by other events during the simulation. In such cases, if not all instructions have been executed, the \"vProcess\" is considered failed, and the termination process is still triggered.</p> <p>On the other hand, the \"vPacket\" class represents simulated packets for network traffic. Similar to the \"vProcess\", the content of the \"vPacket\" is randomly generated bytes. The \"vPacket\" is transferred between different entities such as \"vSwitch\", \"vRouter\", \"vHost\", and \"vGateway\" using their respective \"vNIC\" instances.</p> <p>The \"vRequest\" class is the implementation of a simulated API call, which creates a sequence of \"vProcess\" and \"vPacket\" instances to simulate the usage of network services. A \"vRequest\" requires a source and a target, which can be a simulated container or a simulated user. If a simulated user is a source or target, the \"vPacket\" will be sent from or received by a \"vGateway\". The type of \"vRequest\" includes GET, POST, DELETE, and LIST, which determine the order and number of \"vProcess\" and \"vPacket\" creations. When a simulated user engages with a simulated Service Function Chain (SFC), a series of requests will be generated and scheduled to interact with the network services. The success of a \"vRequest\" depends on the completion of all associated \"vProcess\" and \"vPacket\" executions or transmissions. If any of them fail, the \"vRequest\" is considered failed and may be retried after a specified delay.</p> <p>The \"vUser\" class represents simulated users who engage with the \"vSFC\" during the simulation. Each user's interaction is modelled as a \"Workflow\" that contains a series of \"vRequest\" instances required to complete a specific \"vSFC\". If any \"vRequest\" fails, the \"Workflow\" is reset, clearing all remaining \"vRequest\" that have not started, and the entire set of \"vRequest\" is recreated to be rescheduled and executed. Simulated users can request to engage with multiple \"vSFC\" instances simultaneously, and each \"Workflow\" is created independently. Users can also request \"vSFC\" in order, where the corresponding \"Workflow\" is executed sequentially. If any \"Workflow\" fails, subsequent \"Workflow\" instances will be terminated immediately.</p> <p>By modelling these classes, the simulation environment can simulate user interactions, the execution of computational tasks, and the transmission of network packets within a simulated cloud environment, allowing for the evaluation of system performance and behaviour.</p>"},{"location":"api/virtual_entity/process_packet_request/v_packet/","title":"vPacket","text":"<p>         Bases: <code>VirtualEntity</code></p> Source code in <code>PyCloudSim\\entity\\v_packet.py</code> <pre><code>class vPacket(VirtualEntity):\ndef __init__(\nself,\nsource: Union[vHost, vGateway],\ndestination: Union[vHost, vGateway],\nsize: int = 65536,\nrequest: Optional[vRequest] = None,\nat: Union[int, float, Callable] = simulation.now,\nafter: Optional[Entity | List[Entity]] = None,\nlabel: Optional[str] = None,\n):\n\"\"\"Create a vPacket\n        Args:\n            source (Union[vHost, vGateway]): the source of the vPacket.\n            destination (Union[vHost, vGateway]): the destination of the vPacket.\n            size (int, optional): the size of the vPacket in bytes. Defaults to 65536.\n            request (Optional[vRequest], optional): the assoicated vRequest. Defaults to None.\n            at (Union[int, float, Callable], optional): same as entity. Defaults to simulation.now.\n            after (Optional[Entity  |  List[Entity]], optional): same as entity. Defaults to None.\n            label (Optional[str], optional): same as entity. Defaults to None.\n        Raises:\n            AttributeError: _description_\n        \"\"\"\nsuper().__init__(at, after, label)\nself._source = source\nself._destination = destination\nif source is destination:\nself._loopback = True\nself._path = [source]\nself._current_hop = self.path[0]\nelse:\npath = nx.shortest_path(simulation.topology, source, destination)\nif len(path) != 0:\nself._path = path\nself._current_hop = path[0]\nelse:\nraise AttributeError(\nf\"No path found between {source.__class__.__name__} {source.label} and {destination.__class__.__name__} {destination.label}\"\n)\nself._request_id = request.id if request is not None else None\nself._nic_id = int()\nself._content = randbytes(size)\nself._size = len(self.content) * simulation.packet_size_amplifier\nself._on_creation = lambda: self.source.cache_packet(self)\ndef creation(self):\n\"\"\"The creation process of the vPacket.\"\"\"\nif self.request:\nif self.request.failed:\nLOGGER.debug(f\"{simulation.now:0.2f}:\\tvPacket {self.label} creation cancelled due to vRequest {self.request.label} failed.\")\nreturn\nsimulation.PACKETS.append(self)\nreturn super().creation()\ndef termination(self):\n\"\"\"The termination process of the vPacket.\"\"\"\nsuper().termination()\nif self.completed:\n# release the ram of the current hop\nif self.current_hop.__class__.__name__ != \"vGateway\":\nself.current_hop.ram.release(self)\nself.current_hop.packets.remove(self)\nif self.dropped:\n# fail the associated request\nif self.request is not None:\nself.request.fail()\ndef complete(self):\n\"\"\"Complete the vPacket.\"\"\"\nif not self.completed:\nif self.request is not None:\nif not self.request.failed:\nself.status.append(COMPLETED)\nelse:\nself.status.append(COMPLETED)\nself.terminate()\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\tvPacket {self.label} reached destination {self.current_hop.__class__.__name__} {self.current_hop.label}.\"\n)\ndef drop(self):\n\"\"\"Drop the vPacket.\"\"\"\nif not self.dropped:\nself.status.append(DROPPED)\nself.terminate()\n@property\ndef source(self) -&gt; Union[vHost, vGateway]:\n\"\"\"Return the source of the vPacket.\"\"\"\nreturn self._source\n@property\ndef destination(self) -&gt; Union[vHost, vGateway]:\n\"\"\"Return the destination of the vPacket.\"\"\"\nreturn self._destination\n@property\ndef path(self) -&gt; List[PhysicalEntity]:\n\"\"\"Return the path of the vPacket.\"\"\"\nreturn self._path  # type: ignore\n@property\ndef content(self) -&gt; bytes:\n\"\"\"The content of the vPacket.\"\"\"\nreturn self._content\n@property\ndef size(self) -&gt; int:\n\"\"\"The size of the vPacket in bytes.\"\"\"\nreturn self._size\n@property\ndef loopback(self) -&gt; bool:\n\"\"\"return true if the source and destination is on the same host.\"\"\"\nreturn self._loopback\n@property\ndef request_id(self) -&gt; Optional[int]:\n\"\"\"The id of the associated vRequest.\"\"\"\nreturn self._request_id\n@property\ndef request(self) -&gt; Optional[vRequest]:\n\"\"\"The associated vRequest.\"\"\"\nif self.request_id is None:\nreturn None\nelse:\nfor request in simulation.REQUESTS:\nif request.id == self.request_id:\nreturn request\nraise RuntimeError(\nf\"vPacket {self.label} can not find its associated request.\"\n)\n@property\ndef current_hop(self) -&gt; Union[vHost, vRouter, vSwitch, vGateway]:\n\"\"\"The current hop of the vPacket.\"\"\"\nreturn self._current_hop  # type: ignore\n@property\ndef next_hop(self) -&gt; Union[vHost, vRouter, vSwitch, vGateway]:\n\"\"\"The next hop of the vPacket.\"\"\"\nif self.current_hop == self.destination:\nreturn self.destination\nelse:\nreturn self.path[self.path.index(self.current_hop) + 1]  # type: ignore\n@property\ndef nic_id(self) -&gt; int:\n\"\"\"The id of the associated vNIC.\"\"\"\nreturn self._nic_id\n@property\ndef nic(self) -&gt; vNIC:\n\"\"\"The associated vNIC.\"\"\"\nfor nic in simulation.NICS:\nif nic.id == self.nic_id:\nreturn nic\nraise RuntimeError(f\"vPacket {self.label} can not find its associated NIC.\")\n@property\ndef transmitting(self) -&gt; bool:\n\"\"\"Return true if the vPacket is transmitting.\"\"\"\nreturn TRANSMITTING in self.status\n@property\ndef priority(self) -&gt; int:\n\"\"\"Return the priority of the vPacket.\"\"\"\nif self.request is None:\nreturn 0\nelse:\nreturn self.request.priority\n@property\ndef dropped(self) -&gt; bool:\n\"\"\"Return true if the vPacket is dropped.\"\"\"\nreturn DROPPED in self.status\n@property\ndef queued(self) -&gt; bool:\n\"\"\"Return true if the vPacket is queued.\"\"\"\nreturn QUEUED in self.status\n@property\ndef decoded(self) -&gt; bool:\n\"\"\"Return true if the vPacket is decoded.\"\"\"\nreturn DECODED in self.status\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_packet/#PyCloudSim.entity.v_packet.vPacket.content","title":"<code>content: bytes</code>  <code>property</code>","text":"<p>The content of the vPacket.</p>"},{"location":"api/virtual_entity/process_packet_request/v_packet/#PyCloudSim.entity.v_packet.vPacket.current_hop","title":"<code>current_hop: Union[vHost, vRouter, vSwitch, vGateway]</code>  <code>property</code>","text":"<p>The current hop of the vPacket.</p>"},{"location":"api/virtual_entity/process_packet_request/v_packet/#PyCloudSim.entity.v_packet.vPacket.decoded","title":"<code>decoded: bool</code>  <code>property</code>","text":"<p>Return true if the vPacket is decoded.</p>"},{"location":"api/virtual_entity/process_packet_request/v_packet/#PyCloudSim.entity.v_packet.vPacket.destination","title":"<code>destination: Union[vHost, vGateway]</code>  <code>property</code>","text":"<p>Return the destination of the vPacket.</p>"},{"location":"api/virtual_entity/process_packet_request/v_packet/#PyCloudSim.entity.v_packet.vPacket.dropped","title":"<code>dropped: bool</code>  <code>property</code>","text":"<p>Return true if the vPacket is dropped.</p>"},{"location":"api/virtual_entity/process_packet_request/v_packet/#PyCloudSim.entity.v_packet.vPacket.loopback","title":"<code>loopback: bool</code>  <code>property</code>","text":"<p>return true if the source and destination is on the same host.</p>"},{"location":"api/virtual_entity/process_packet_request/v_packet/#PyCloudSim.entity.v_packet.vPacket.next_hop","title":"<code>next_hop: Union[vHost, vRouter, vSwitch, vGateway]</code>  <code>property</code>","text":"<p>The next hop of the vPacket.</p>"},{"location":"api/virtual_entity/process_packet_request/v_packet/#PyCloudSim.entity.v_packet.vPacket.nic","title":"<code>nic: vNIC</code>  <code>property</code>","text":"<p>The associated vNIC.</p>"},{"location":"api/virtual_entity/process_packet_request/v_packet/#PyCloudSim.entity.v_packet.vPacket.nic_id","title":"<code>nic_id: int</code>  <code>property</code>","text":"<p>The id of the associated vNIC.</p>"},{"location":"api/virtual_entity/process_packet_request/v_packet/#PyCloudSim.entity.v_packet.vPacket.path","title":"<code>path: List[PhysicalEntity]</code>  <code>property</code>","text":"<p>Return the path of the vPacket.</p>"},{"location":"api/virtual_entity/process_packet_request/v_packet/#PyCloudSim.entity.v_packet.vPacket.priority","title":"<code>priority: int</code>  <code>property</code>","text":"<p>Return the priority of the vPacket.</p>"},{"location":"api/virtual_entity/process_packet_request/v_packet/#PyCloudSim.entity.v_packet.vPacket.queued","title":"<code>queued: bool</code>  <code>property</code>","text":"<p>Return true if the vPacket is queued.</p>"},{"location":"api/virtual_entity/process_packet_request/v_packet/#PyCloudSim.entity.v_packet.vPacket.request","title":"<code>request: Optional[vRequest]</code>  <code>property</code>","text":"<p>The associated vRequest.</p>"},{"location":"api/virtual_entity/process_packet_request/v_packet/#PyCloudSim.entity.v_packet.vPacket.request_id","title":"<code>request_id: Optional[int]</code>  <code>property</code>","text":"<p>The id of the associated vRequest.</p>"},{"location":"api/virtual_entity/process_packet_request/v_packet/#PyCloudSim.entity.v_packet.vPacket.size","title":"<code>size: int</code>  <code>property</code>","text":"<p>The size of the vPacket in bytes.</p>"},{"location":"api/virtual_entity/process_packet_request/v_packet/#PyCloudSim.entity.v_packet.vPacket.source","title":"<code>source: Union[vHost, vGateway]</code>  <code>property</code>","text":"<p>Return the source of the vPacket.</p>"},{"location":"api/virtual_entity/process_packet_request/v_packet/#PyCloudSim.entity.v_packet.vPacket.transmitting","title":"<code>transmitting: bool</code>  <code>property</code>","text":"<p>Return true if the vPacket is transmitting.</p>"},{"location":"api/virtual_entity/process_packet_request/v_packet/#PyCloudSim.entity.v_packet.vPacket.__init__","title":"<code>__init__(source, destination, size=65536, request=None, at=simulation.now, after=None, label=None)</code>","text":"<p>Create a vPacket</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Union[vHost, vGateway]</code> <p>the source of the vPacket.</p> required <code>destination</code> <code>Union[vHost, vGateway]</code> <p>the destination of the vPacket.</p> required <code>size</code> <code>int</code> <p>the size of the vPacket in bytes. Defaults to 65536.</p> <code>65536</code> <code>request</code> <code>Optional[vRequest]</code> <p>the assoicated vRequest. Defaults to None.</p> <code>None</code> <code>at</code> <code>Union[int, float, Callable]</code> <p>same as entity. Defaults to simulation.now.</p> <code>simulation.now</code> <code>after</code> <code>Optional[Entity | List[Entity]]</code> <p>same as entity. Defaults to None.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>same as entity. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>AttributeError</code> <p>description</p> Source code in <code>PyCloudSim\\entity\\v_packet.py</code> <pre><code>def __init__(\nself,\nsource: Union[vHost, vGateway],\ndestination: Union[vHost, vGateway],\nsize: int = 65536,\nrequest: Optional[vRequest] = None,\nat: Union[int, float, Callable] = simulation.now,\nafter: Optional[Entity | List[Entity]] = None,\nlabel: Optional[str] = None,\n):\n\"\"\"Create a vPacket\n    Args:\n        source (Union[vHost, vGateway]): the source of the vPacket.\n        destination (Union[vHost, vGateway]): the destination of the vPacket.\n        size (int, optional): the size of the vPacket in bytes. Defaults to 65536.\n        request (Optional[vRequest], optional): the assoicated vRequest. Defaults to None.\n        at (Union[int, float, Callable], optional): same as entity. Defaults to simulation.now.\n        after (Optional[Entity  |  List[Entity]], optional): same as entity. Defaults to None.\n        label (Optional[str], optional): same as entity. Defaults to None.\n    Raises:\n        AttributeError: _description_\n    \"\"\"\nsuper().__init__(at, after, label)\nself._source = source\nself._destination = destination\nif source is destination:\nself._loopback = True\nself._path = [source]\nself._current_hop = self.path[0]\nelse:\npath = nx.shortest_path(simulation.topology, source, destination)\nif len(path) != 0:\nself._path = path\nself._current_hop = path[0]\nelse:\nraise AttributeError(\nf\"No path found between {source.__class__.__name__} {source.label} and {destination.__class__.__name__} {destination.label}\"\n)\nself._request_id = request.id if request is not None else None\nself._nic_id = int()\nself._content = randbytes(size)\nself._size = len(self.content) * simulation.packet_size_amplifier\nself._on_creation = lambda: self.source.cache_packet(self)\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_packet/#PyCloudSim.entity.v_packet.vPacket.complete","title":"<code>complete()</code>","text":"<p>Complete the vPacket.</p> Source code in <code>PyCloudSim\\entity\\v_packet.py</code> <pre><code>def complete(self):\n\"\"\"Complete the vPacket.\"\"\"\nif not self.completed:\nif self.request is not None:\nif not self.request.failed:\nself.status.append(COMPLETED)\nelse:\nself.status.append(COMPLETED)\nself.terminate()\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\tvPacket {self.label} reached destination {self.current_hop.__class__.__name__} {self.current_hop.label}.\"\n)\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_packet/#PyCloudSim.entity.v_packet.vPacket.creation","title":"<code>creation()</code>","text":"<p>The creation process of the vPacket.</p> Source code in <code>PyCloudSim\\entity\\v_packet.py</code> <pre><code>def creation(self):\n\"\"\"The creation process of the vPacket.\"\"\"\nif self.request:\nif self.request.failed:\nLOGGER.debug(f\"{simulation.now:0.2f}:\\tvPacket {self.label} creation cancelled due to vRequest {self.request.label} failed.\")\nreturn\nsimulation.PACKETS.append(self)\nreturn super().creation()\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_packet/#PyCloudSim.entity.v_packet.vPacket.drop","title":"<code>drop()</code>","text":"<p>Drop the vPacket.</p> Source code in <code>PyCloudSim\\entity\\v_packet.py</code> <pre><code>def drop(self):\n\"\"\"Drop the vPacket.\"\"\"\nif not self.dropped:\nself.status.append(DROPPED)\nself.terminate()\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_packet/#PyCloudSim.entity.v_packet.vPacket.termination","title":"<code>termination()</code>","text":"<p>The termination process of the vPacket.</p> Source code in <code>PyCloudSim\\entity\\v_packet.py</code> <pre><code>def termination(self):\n\"\"\"The termination process of the vPacket.\"\"\"\nsuper().termination()\nif self.completed:\n# release the ram of the current hop\nif self.current_hop.__class__.__name__ != \"vGateway\":\nself.current_hop.ram.release(self)\nself.current_hop.packets.remove(self)\nif self.dropped:\n# fail the associated request\nif self.request is not None:\nself.request.fail()\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_process/","title":"vInstruction","text":"<p>         Bases: <code>ABC</code></p> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>class vInstruction(ABC):\ndef __init__(self) -&gt; None:\n\"\"\"Create a vInstruction.\n        \"\"\"\nsuper().__init__()\nself._content = bytes()\n@property\ndef content(self) -&gt; bytes:\n\"\"\"Return the content of the vInstruction.\"\"\"\nreturn self._content\n@property\ndef length(self) -&gt; int:\n\"\"\"Return the length of the vInstruction.\"\"\"\nreturn len(self.content)\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vInstruction.content","title":"<code>content: bytes</code>  <code>property</code>","text":"<p>Return the content of the vInstruction.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vInstruction.length","title":"<code>length: int</code>  <code>property</code>","text":"<p>Return the length of the vInstruction.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vInstruction.__init__","title":"<code>__init__()</code>","text":"<p>Create a vInstruction.</p> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"Create a vInstruction.\n    \"\"\"\nsuper().__init__()\nself._content = bytes()\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_process/#vx86instruction","title":"vX86Instruction","text":"<p>         Bases: <code>vInstruction</code></p> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>class vX86Instruction(vInstruction):\ndef __init__(self) -&gt; None:\n\"\"\"Create a vX86Instruction.\"\"\"\nsuper().__init__()\nself._content = randbytes(randint(1, 16))\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vX86Instruction.__init__","title":"<code>__init__()</code>","text":"<p>Create a vX86Instruction.</p> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"Create a vX86Instruction.\"\"\"\nsuper().__init__()\nself._content = randbytes(randint(1, 16))\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_process/#varminstruction","title":"vARMInstruction","text":"<p>         Bases: <code>vInstruction</code></p> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>class vARMInstruction(vInstruction):\ndef __init__(self) -&gt; None:\n\"\"\"Create a vARMInstruction.\"\"\"\nsuper().__init__()\nself._content = randbytes(4)\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vARMInstruction.__init__","title":"<code>__init__()</code>","text":"<p>Create a vARMInstruction.</p> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"Create a vARMInstruction.\"\"\"\nsuper().__init__()\nself._content = randbytes(4)\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_process/#vprocess","title":"vProcess","text":"<p>         Bases: <code>VirtualEntity</code></p> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>class vProcess(VirtualEntity):\ndef __init__(\nself,\nlength: int,\npriority: Union[int, float],\nrequest: Optional[vRequest] = None,\ncontainer: Optional[vContainer] = None,\nat: Union[int, float, Callable] = simulation.now,\nafter: Optional[Entity | List[Entity]] = None,\nlabel: Optional[str] = None,\n):\n\"\"\"Create a vProcess.\n        Args:\n            length (int): the length in terms of instructions.\n            priority (Union[int, float]): the priority of the vProcess.\n            request (Optional[vRequest], optional): the request that the vProcess is associated with. Defaults to None.\n            container (Optional[vContainer], optional): the container that the vProcess is on. Defaults to None.\n            at (Union[int, float, Callable], optional): same as entity. Defaults to simulation.now.\n            after (Optional[Entity  |  List[Entity]], optional): same as entity. Defaults to None.\n            label (Optional[str], optional): same as entity. Defaults to None.\n        \"\"\"\nsuper().__init__(at, after, label)\nself._length = length\nself._priority = priority\nself._instructions = list()\nself._request_id = request.id if request else None\nself._container_id = container.id if container else None\nself._host_id = int()\nself._cpu_id = int()\nself._cpu_core_id = int()\nself._progress = 0\nself._current_scheduled_length = 0\nself._executing_cores: List[vCPUCore] = list()\nif self.request is not None:\nself.request.processes.append(self)\nself.on_creation = lambda: self.container.accept_process(self) if self.container else None\ndef creation(self):\n\"\"\"The creation process of a vProcess.\"\"\"\nif self.request:\nif self.request.failed:\nLOGGER.debug(f\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} creation cancelled due to vRequest {self.request.label} failed.\")\nreturn\n# generate instructions and wrap them as priority items\nself._instructions = list()\nfor _ in range(self.length):\nif simulation.platform == X86_64:\ninstruction = vX86Instruction()\nself.instructions.append(instruction)\nif simulation.platform == ARM:\ninstruction = vARMInstruction()\nself.instructions.append(instruction)\nsimulation.PROCESSES.append(self)\nreturn super().creation()\ndef termination(self):\n\"\"\"The termination process of a vProcess.\"\"\"\nsuper().terminate()\nself.release_resources()\nif self.cached:\nself.cpu.schedule_process()\ndef release_resources(self):\n\"\"\"Release the resources that the vProcess is holding.\"\"\"\nif self.scheduled and self.container:\nself.container.processes.remove(self)\nself.container.ram.release(self)\nself.container.cpu.release(self)\nfor claim in self.container.cpu.claims:\nif claim.user is self:\nLOGGER.error(\nf\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} failed to release CPU resources from vContainer {self.container.label}, remaining {claim.quantity} CPU\"\n)\nraise RuntimeError()\nLOGGER.debug(\nf\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} release resources from vContainer {self.container.label}\"\n)\nLOGGER.debug(\nf\"{simulation.now:0.2f}:\\tvContainer {self.container.label}: {self.container.cpu.available_quantity} CPU, {self.container.ram.available_quantity} RAM, {len(self.container.processes)} Processes.\"\n)\nif self.cached:\nself.host.processes.remove(self)\nself.host.ram.release(self)\nself.cpu.processes.remove(self)\nif self.executing:\nfor core in self.executing_cores:\ncore.processes.remove(self)\ncore.computational_power.release(self)\nLOGGER.debug(\nf\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} release resources from vHost {self.host.label}\"\n)\nLOGGER.debug(\nf\"{simulation.now:0.2f}:\\tvHost {self.host.label}: {self.host.cpu.availablity} CPU, {self.host.ram.available_quantity} RAM\"\n)\ndef crash(self):\n\"\"\"Crash the vProcess.\"\"\"\nif not self.failed:\nself.status.append(FAILED)\nself.terminate()\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} failed\"\n)\nif self.request:\nif not self.request.failed:\nself.request.fail()\ndef complete(self):\n\"\"\"Complete the vProcess.\"\"\"\nif not self.completed and not self.failed and not self.terminated:\nif self.remaining &lt;= 0:\nself.status.append(COMPLETED)\nself.terminate()\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} completed\"\n)\n@property\ndef length(self) -&gt; int:\n\"\"\"Return the length of the vProcess.\"\"\"\nreturn self._length\n@property\ndef priority(self) -&gt; Union[int, float]:\n\"\"\"Return the priority of the vProcess.\"\"\"\nreturn self._priority\n@property\ndef instructions(self) -&gt; List[vInstruction]:\n\"\"\"Return the instructions of the vProcess.\"\"\"\nreturn self._instructions\n@property\ndef ram_usage(self) -&gt; int:\n\"\"\"Return the RAM usage of the vProcess.\"\"\"\nreturn (\nsum([instruction.length for instruction in self.instructions])\n* simulation.ram_amplifier\n)\n@property\ndef container_id(self) -&gt; int | None:\n\"\"\"Return the container id of the vProcess.\"\"\"\nreturn self._container_id\n@property\ndef host_id(self) -&gt; int:\n\"\"\"Return the host id of the vProcess.\"\"\"\nreturn self._host_id\n@property\ndef request_id(self) -&gt; Optional[int]:\n\"\"\"Return the request id of the vProcess.\"\"\"\nreturn self._request_id\n@property\ndef container(self) -&gt; vContainer | None:\n\"\"\"Return the container of the vProcess.\"\"\"\nif self.container_id is None:\nreturn None\nelse:\nfor container in simulation.CONTAINERS:\nif container.id == self.container_id:\nreturn container\nraise RuntimeError(\nf\"{self.__class__.__name__} {self.label} is not associated with any vContainer.\"\n)\n@property\ndef host(self) -&gt; vHost:\n\"\"\"Return the host of the vProcess.\"\"\"\nfor host in simulation.HOSTS:\nif host.id == self.host_id:\nreturn host\nraise RuntimeError(\nf\"{self.__class__.__name__} {self.label} is not found on any vHost.\"\n)\n@property\ndef request(self) -&gt; Optional[vRequest]:\n\"\"\"Return the request of the vProcess.\"\"\"\nif self.request_id is None:\nreturn None\nelse:\nfor request in simulation.REQUESTS:\nif request.id == self.request_id:\nreturn request\nraise RuntimeError(\nf\"{self.__class__.__name__} {self.label} is not associated with any vRequest.\"\n)\n@property\ndef cpu_id(self) -&gt; int:\n\"\"\"Return the cpu id of the vProcess.\"\"\"\nreturn self._cpu_id\n@property\ndef cpu(self) -&gt; vCPU:\n\"\"\"Return the cpu of the vProcess.\"\"\"\nfor cpu in simulation.CPUS:\nif cpu.id == self.cpu_id:\nreturn cpu\nraise RuntimeError(\nf\"{self.__class__.__name__} {self.label} is not associated with any vCPU.\"\n)\n@property\ndef cpu_core_id(self) -&gt; int:\n\"\"\"Return the cpu core id of the vProcess.\"\"\"\nreturn self._cpu_core_id\n@property\ndef cpu_core(self) -&gt; vCPUCore:\n\"\"\"Return the cpu core of the vProcess.\"\"\"\nfor cpu_core in simulation.CPU_CORES:\nif cpu_core.id == self.cpu_core_id:\nreturn cpu_core\nraise RuntimeError(\nf\"{self.__class__.__name__} {self.label} is not associated with any vCPU Core.\"\n)\n@property\ndef cached(self) -&gt; bool:\n\"\"\"Return whether the vProcess is cached or not.\"\"\"\nreturn CACHED in self.status\n@property\ndef executing(self) -&gt; bool:\n\"\"\"Return whether the vProcess is executing or not.\"\"\"\nreturn EXECUTING in self.status\n@property\ndef progress(self) -&gt; int:\n\"\"\"Return the progress of the vProcess.\"\"\"\nreturn self._progress\n@property\ndef remaining(self) -&gt; int:\n\"\"\"Return the remaining length of the vProcess.\"\"\"\nreturn self.length - self.progress\n@property\ndef current_scheduled_length(self) -&gt; int:\n\"\"\"Return the current scheduled length of the vProcess.\"\"\"\nreturn self._current_scheduled_length\n@property\ndef executing_cores(self) -&gt; List[vCPUCore]:\n\"\"\"Return the executing cores of the vProcess.\"\"\"\nreturn self._executing_cores\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.cached","title":"<code>cached: bool</code>  <code>property</code>","text":"<p>Return whether the vProcess is cached or not.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.container","title":"<code>container: vContainer | None</code>  <code>property</code>","text":"<p>Return the container of the vProcess.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.container_id","title":"<code>container_id: int | None</code>  <code>property</code>","text":"<p>Return the container id of the vProcess.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.cpu","title":"<code>cpu: vCPU</code>  <code>property</code>","text":"<p>Return the cpu of the vProcess.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.cpu_core","title":"<code>cpu_core: vCPUCore</code>  <code>property</code>","text":"<p>Return the cpu core of the vProcess.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.cpu_core_id","title":"<code>cpu_core_id: int</code>  <code>property</code>","text":"<p>Return the cpu core id of the vProcess.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.cpu_id","title":"<code>cpu_id: int</code>  <code>property</code>","text":"<p>Return the cpu id of the vProcess.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.current_scheduled_length","title":"<code>current_scheduled_length: int</code>  <code>property</code>","text":"<p>Return the current scheduled length of the vProcess.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.executing","title":"<code>executing: bool</code>  <code>property</code>","text":"<p>Return whether the vProcess is executing or not.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.executing_cores","title":"<code>executing_cores: List[vCPUCore]</code>  <code>property</code>","text":"<p>Return the executing cores of the vProcess.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.host","title":"<code>host: vHost</code>  <code>property</code>","text":"<p>Return the host of the vProcess.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.host_id","title":"<code>host_id: int</code>  <code>property</code>","text":"<p>Return the host id of the vProcess.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.instructions","title":"<code>instructions: List[vInstruction]</code>  <code>property</code>","text":"<p>Return the instructions of the vProcess.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.length","title":"<code>length: int</code>  <code>property</code>","text":"<p>Return the length of the vProcess.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.priority","title":"<code>priority: Union[int, float]</code>  <code>property</code>","text":"<p>Return the priority of the vProcess.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.progress","title":"<code>progress: int</code>  <code>property</code>","text":"<p>Return the progress of the vProcess.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.ram_usage","title":"<code>ram_usage: int</code>  <code>property</code>","text":"<p>Return the RAM usage of the vProcess.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.remaining","title":"<code>remaining: int</code>  <code>property</code>","text":"<p>Return the remaining length of the vProcess.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.request","title":"<code>request: Optional[vRequest]</code>  <code>property</code>","text":"<p>Return the request of the vProcess.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.request_id","title":"<code>request_id: Optional[int]</code>  <code>property</code>","text":"<p>Return the request id of the vProcess.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.__init__","title":"<code>__init__(length, priority, request=None, container=None, at=simulation.now, after=None, label=None)</code>","text":"<p>Create a vProcess.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>the length in terms of instructions.</p> required <code>priority</code> <code>Union[int, float]</code> <p>the priority of the vProcess.</p> required <code>request</code> <code>Optional[vRequest]</code> <p>the request that the vProcess is associated with. Defaults to None.</p> <code>None</code> <code>container</code> <code>Optional[vContainer]</code> <p>the container that the vProcess is on. Defaults to None.</p> <code>None</code> <code>at</code> <code>Union[int, float, Callable]</code> <p>same as entity. Defaults to simulation.now.</p> <code>simulation.now</code> <code>after</code> <code>Optional[Entity | List[Entity]]</code> <p>same as entity. Defaults to None.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>same as entity. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>def __init__(\nself,\nlength: int,\npriority: Union[int, float],\nrequest: Optional[vRequest] = None,\ncontainer: Optional[vContainer] = None,\nat: Union[int, float, Callable] = simulation.now,\nafter: Optional[Entity | List[Entity]] = None,\nlabel: Optional[str] = None,\n):\n\"\"\"Create a vProcess.\n    Args:\n        length (int): the length in terms of instructions.\n        priority (Union[int, float]): the priority of the vProcess.\n        request (Optional[vRequest], optional): the request that the vProcess is associated with. Defaults to None.\n        container (Optional[vContainer], optional): the container that the vProcess is on. Defaults to None.\n        at (Union[int, float, Callable], optional): same as entity. Defaults to simulation.now.\n        after (Optional[Entity  |  List[Entity]], optional): same as entity. Defaults to None.\n        label (Optional[str], optional): same as entity. Defaults to None.\n    \"\"\"\nsuper().__init__(at, after, label)\nself._length = length\nself._priority = priority\nself._instructions = list()\nself._request_id = request.id if request else None\nself._container_id = container.id if container else None\nself._host_id = int()\nself._cpu_id = int()\nself._cpu_core_id = int()\nself._progress = 0\nself._current_scheduled_length = 0\nself._executing_cores: List[vCPUCore] = list()\nif self.request is not None:\nself.request.processes.append(self)\nself.on_creation = lambda: self.container.accept_process(self) if self.container else None\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.complete","title":"<code>complete()</code>","text":"<p>Complete the vProcess.</p> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>def complete(self):\n\"\"\"Complete the vProcess.\"\"\"\nif not self.completed and not self.failed and not self.terminated:\nif self.remaining &lt;= 0:\nself.status.append(COMPLETED)\nself.terminate()\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} completed\"\n)\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.crash","title":"<code>crash()</code>","text":"<p>Crash the vProcess.</p> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>def crash(self):\n\"\"\"Crash the vProcess.\"\"\"\nif not self.failed:\nself.status.append(FAILED)\nself.terminate()\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} failed\"\n)\nif self.request:\nif not self.request.failed:\nself.request.fail()\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.creation","title":"<code>creation()</code>","text":"<p>The creation process of a vProcess.</p> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>def creation(self):\n\"\"\"The creation process of a vProcess.\"\"\"\nif self.request:\nif self.request.failed:\nLOGGER.debug(f\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} creation cancelled due to vRequest {self.request.label} failed.\")\nreturn\n# generate instructions and wrap them as priority items\nself._instructions = list()\nfor _ in range(self.length):\nif simulation.platform == X86_64:\ninstruction = vX86Instruction()\nself.instructions.append(instruction)\nif simulation.platform == ARM:\ninstruction = vARMInstruction()\nself.instructions.append(instruction)\nsimulation.PROCESSES.append(self)\nreturn super().creation()\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.release_resources","title":"<code>release_resources()</code>","text":"<p>Release the resources that the vProcess is holding.</p> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>def release_resources(self):\n\"\"\"Release the resources that the vProcess is holding.\"\"\"\nif self.scheduled and self.container:\nself.container.processes.remove(self)\nself.container.ram.release(self)\nself.container.cpu.release(self)\nfor claim in self.container.cpu.claims:\nif claim.user is self:\nLOGGER.error(\nf\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} failed to release CPU resources from vContainer {self.container.label}, remaining {claim.quantity} CPU\"\n)\nraise RuntimeError()\nLOGGER.debug(\nf\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} release resources from vContainer {self.container.label}\"\n)\nLOGGER.debug(\nf\"{simulation.now:0.2f}:\\tvContainer {self.container.label}: {self.container.cpu.available_quantity} CPU, {self.container.ram.available_quantity} RAM, {len(self.container.processes)} Processes.\"\n)\nif self.cached:\nself.host.processes.remove(self)\nself.host.ram.release(self)\nself.cpu.processes.remove(self)\nif self.executing:\nfor core in self.executing_cores:\ncore.processes.remove(self)\ncore.computational_power.release(self)\nLOGGER.debug(\nf\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} release resources from vHost {self.host.label}\"\n)\nLOGGER.debug(\nf\"{simulation.now:0.2f}:\\tvHost {self.host.label}: {self.host.cpu.availablity} CPU, {self.host.ram.available_quantity} RAM\"\n)\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.termination","title":"<code>termination()</code>","text":"<p>The termination process of a vProcess.</p> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>def termination(self):\n\"\"\"The termination process of a vProcess.\"\"\"\nsuper().terminate()\nself.release_resources()\nif self.cached:\nself.cpu.schedule_process()\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_process/#vdeamonprocess","title":"vDeamonProcess","text":"<p>         Bases: <code>vProcess</code></p> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>class vDeamonProcess(vProcess):\ndef __init__(\nself,\nlength: int,\ncontainer: vContainer,\nat: Union[int, float, Callable] = simulation.now,\nafter: Optional[Entity | List[Entity]] = None,\nlabel: Optional[str] = None,\n):\n\"\"\"Create a vDeamonProcess.\n        Args:\n            length (int): the length in terms of instructions.\n            container (vContainer): the cache that the vDeamonProcess is on.\n            at (Union[int, float, Callable], optional): same as entity. Defaults to simulation.now.\n            after (Optional[Entity  |  List[Entity]], optional): same as entity. Defaults to None.\n            label (Optional[str], optional): same as entity. Defaults to None.\n        \"\"\"\nsuper().__init__(length=length, priority=-inf, at=at, after=after, label=label)\nself._container_id = container.id\ndef creation(self):\n\"\"\"Creation process of a vDeamonProcess.\"\"\"\nsuper().creation()\nself.container.accept_process(self)\ndef termination(self):\n\"\"\"Termination process of a vDeamonProcess.\"\"\"\nsuper(vProcess, self).termination()\nif not self.failed:\nself.release_resources()\nself.container.init_deamon()\nelse:\nself.release_resources()\n@property\ndef container_id(self) -&gt; int:\n\"\"\"The container id of the vDeamonProcess.\"\"\"\nreturn self._container_id\n@property\ndef container(self) -&gt; vContainer:\n\"\"\"The container of the vDeamonProcess.\"\"\"\nfor container in simulation.CONTAINERS:\nif container.id == self.container_id:\nreturn container\nraise RuntimeError(\nf\"{self.__class__.__name__} {self.label} is not associated with any vContainer.\"\n)\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vDeamonProcess.container","title":"<code>container: vContainer</code>  <code>property</code>","text":"<p>The container of the vDeamonProcess.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vDeamonProcess.container_id","title":"<code>container_id: int</code>  <code>property</code>","text":"<p>The container id of the vDeamonProcess.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vDeamonProcess.__init__","title":"<code>__init__(length, container, at=simulation.now, after=None, label=None)</code>","text":"<p>Create a vDeamonProcess.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>the length in terms of instructions.</p> required <code>container</code> <code>vContainer</code> <p>the cache that the vDeamonProcess is on.</p> required <code>at</code> <code>Union[int, float, Callable]</code> <p>same as entity. Defaults to simulation.now.</p> <code>simulation.now</code> <code>after</code> <code>Optional[Entity | List[Entity]]</code> <p>same as entity. Defaults to None.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>same as entity. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>def __init__(\nself,\nlength: int,\ncontainer: vContainer,\nat: Union[int, float, Callable] = simulation.now,\nafter: Optional[Entity | List[Entity]] = None,\nlabel: Optional[str] = None,\n):\n\"\"\"Create a vDeamonProcess.\n    Args:\n        length (int): the length in terms of instructions.\n        container (vContainer): the cache that the vDeamonProcess is on.\n        at (Union[int, float, Callable], optional): same as entity. Defaults to simulation.now.\n        after (Optional[Entity  |  List[Entity]], optional): same as entity. Defaults to None.\n        label (Optional[str], optional): same as entity. Defaults to None.\n    \"\"\"\nsuper().__init__(length=length, priority=-inf, at=at, after=after, label=label)\nself._container_id = container.id\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vDeamonProcess.creation","title":"<code>creation()</code>","text":"<p>Creation process of a vDeamonProcess.</p> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>def creation(self):\n\"\"\"Creation process of a vDeamonProcess.\"\"\"\nsuper().creation()\nself.container.accept_process(self)\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vDeamonProcess.termination","title":"<code>termination()</code>","text":"<p>Termination process of a vDeamonProcess.</p> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>def termination(self):\n\"\"\"Termination process of a vDeamonProcess.\"\"\"\nsuper(vProcess, self).termination()\nif not self.failed:\nself.release_resources()\nself.container.init_deamon()\nelse:\nself.release_resources()\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_process/#vpackethandler","title":"vPacketHandler","text":"<p>         Bases: <code>vProcess</code></p> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>class vPacketHandler(vProcess):\ndef __init__(\nself,\nlength: int,\npacket: vPacket,\nhost: Union[vHost, vSwitch, vRouter],\nat: Union[int, float, Callable] = simulation.now,\nafter: Optional[Entity | List[Entity]] = None,\nlabel: Optional[str] = None,\n):\n\"\"\"Create a vPacketHandler.\n        Args:\n            length (int): the length of the vPacketHandler, will be determined by processing delay.\n            packet (vPacket): the assoicated vPacket.\n            host (Union[vHost, vSwitch, vRouter]): the host that the vPacketHandler is on.\n            at (Union[int, float, Callable], optional): same as entity. Defaults to simulation.now.\n            after (Optional[Entity  |  List[Entity]], optional): same as entity. Defaults to None.\n            label (Optional[str], optional): same as entity. Defaults to None.\n        \"\"\"\nsuper().__init__(\nlength=length,\npriority=packet.request.priority if packet.request else 0,\nat=at,\nafter=after,\nlabel=label,\n)\nself._packet_id = packet.id\nself._host = host\ndef creation(self):\n\"\"\"The creation process of a vPacketHandler.\"\"\"\nsuper().creation()\ndef termination(self):\n\"\"\"The termination process of a vPacketHandler.\"\"\"\nsuper(vProcess, self).termination()\nself.release_resources()\nself.packet.status.append(DECODED)\nLOGGER.debug(f\"{simulation.now:0.2f}:\\tvPacket {self.packet.label} is decoded.\")\nself.packet.current_hop.send_packets()\ndef complete(self):\n\"\"\"Complete the vPacketHandler.\"\"\"\nif not self.completed and not self.failed and not self.terminated:\nif self.remaining &lt;= 0:\nself.status.append(COMPLETED)\nself.terminate()\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} completed\"\n)\nif self.packet.path[-1] is self.packet.current_hop:\nself.packet.complete()\n@property\ndef packet_id(self) -&gt; int:\n\"\"\"The id of the associated vPacket.\"\"\"\nreturn self._packet_id\n@property\ndef packet(self) -&gt; vPacket:\n\"\"\"The associated vPacket.\"\"\"\nfor packet in simulation.PACKETS:\nif packet.id == self.packet_id:\nreturn packet\nraise RuntimeError(\nf\"vPacketHandler {self.label} is not associated with any vPacket.\"\n)\n@property\ndef host(self) -&gt; Union[vHost, vSwitch, vRouter]:\n\"\"\"The host that the vPacketHandler is on.\"\"\"\nreturn self._host\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vPacketHandler.host","title":"<code>host: Union[vHost, vSwitch, vRouter]</code>  <code>property</code>","text":"<p>The host that the vPacketHandler is on.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vPacketHandler.packet","title":"<code>packet: vPacket</code>  <code>property</code>","text":"<p>The associated vPacket.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vPacketHandler.packet_id","title":"<code>packet_id: int</code>  <code>property</code>","text":"<p>The id of the associated vPacket.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vPacketHandler.__init__","title":"<code>__init__(length, packet, host, at=simulation.now, after=None, label=None)</code>","text":"<p>Create a vPacketHandler.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>the length of the vPacketHandler, will be determined by processing delay.</p> required <code>packet</code> <code>vPacket</code> <p>the assoicated vPacket.</p> required <code>host</code> <code>Union[vHost, vSwitch, vRouter]</code> <p>the host that the vPacketHandler is on.</p> required <code>at</code> <code>Union[int, float, Callable]</code> <p>same as entity. Defaults to simulation.now.</p> <code>simulation.now</code> <code>after</code> <code>Optional[Entity | List[Entity]]</code> <p>same as entity. Defaults to None.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>same as entity. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>def __init__(\nself,\nlength: int,\npacket: vPacket,\nhost: Union[vHost, vSwitch, vRouter],\nat: Union[int, float, Callable] = simulation.now,\nafter: Optional[Entity | List[Entity]] = None,\nlabel: Optional[str] = None,\n):\n\"\"\"Create a vPacketHandler.\n    Args:\n        length (int): the length of the vPacketHandler, will be determined by processing delay.\n        packet (vPacket): the assoicated vPacket.\n        host (Union[vHost, vSwitch, vRouter]): the host that the vPacketHandler is on.\n        at (Union[int, float, Callable], optional): same as entity. Defaults to simulation.now.\n        after (Optional[Entity  |  List[Entity]], optional): same as entity. Defaults to None.\n        label (Optional[str], optional): same as entity. Defaults to None.\n    \"\"\"\nsuper().__init__(\nlength=length,\npriority=packet.request.priority if packet.request else 0,\nat=at,\nafter=after,\nlabel=label,\n)\nself._packet_id = packet.id\nself._host = host\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vPacketHandler.complete","title":"<code>complete()</code>","text":"<p>Complete the vPacketHandler.</p> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>def complete(self):\n\"\"\"Complete the vPacketHandler.\"\"\"\nif not self.completed and not self.failed and not self.terminated:\nif self.remaining &lt;= 0:\nself.status.append(COMPLETED)\nself.terminate()\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} completed\"\n)\nif self.packet.path[-1] is self.packet.current_hop:\nself.packet.complete()\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vPacketHandler.creation","title":"<code>creation()</code>","text":"<p>The creation process of a vPacketHandler.</p> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>def creation(self):\n\"\"\"The creation process of a vPacketHandler.\"\"\"\nsuper().creation()\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vPacketHandler.termination","title":"<code>termination()</code>","text":"<p>The termination process of a vPacketHandler.</p> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>def termination(self):\n\"\"\"The termination process of a vPacketHandler.\"\"\"\nsuper(vProcess, self).termination()\nself.release_resources()\nself.packet.status.append(DECODED)\nLOGGER.debug(f\"{simulation.now:0.2f}:\\tvPacket {self.packet.label} is decoded.\")\nself.packet.current_hop.send_packets()\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_request/","title":"vRequest","text":"<p>         Bases: <code>VirtualEntity</code></p> Source code in <code>PyCloudSim\\entity\\v_request.py</code> <pre><code>class vRequest(VirtualEntity):\ndef __init__(\nself,\nsource: Union[vUser, vMicroservice],\ntarget: Union[vUser, vMicroservice],\nflow: Optional[WorkFlow] = None,\ntype: str = GET,\nat: Union[int, float, Callable] = simulation.now,\nafter: Optional[Entity | List[Entity]] = None,\nlabel: Optional[str] = None,\n):\n\"\"\"Create a request.\n        Args:\n            source (Union[vUser, vMicroservice]): the source of this request, can be vUser or vMicroservice.\n            target (Union[vUser, vMicroservice]): the target of this request, can be vUser or vMicroservice.\n            flow (Optional[WorkFlow], optional): the workflow of this request. Defaults to None.\n            type (str, optional): type of the request, GET, POST, LIST, DELETE. Defaults to GET.\n            at (Union[int, float, Callable], optional): when the request should be created. Defaults to simulation.now.\n            after (Optional[Entity  |  List[Entity]], optional): the entity that this request must be created after. Defaults to None.\n            label (Optional[str], optional): short description of the request. Defaults to None.\n        \"\"\"\nsuper().__init__(at, after, label)\nself._source = source\nself._target = target\nself._flow = flow if flow else None\nif self.flow:\nif callable(self.flow.priority):\nself._priority = self.flow.priority()\nelse:\nself._priority = self.flow.priority\nelse:\nself._priority = 0\nself._processes = list()\nself._packets = list()\nself._source_endpoint: vContainer = None  # type: ignore\nself._target_endpoint: vContainer = None  # type: ignore\nself._type = type\nself._on_creation = simulation.request_scheduler.schedule\ndef creation(self):\nif self.flow:\nif self.flow.failed:\nLOGGER.debug(f\"{simulation.now:0.2f}:\\tvRequest {self.label} creation cancelled due to Workflow {self.flow.label} failed.\")\nreturn\nsimulation.REQUESTS.append(self)\nreturn super().creation()\ndef execute(self):\n\"\"\"Exceute the request by initiating the processes and packets according to the request type.\n        Raises:\n            RuntimeError: raise if the request is not scheduled.\n        \"\"\"\nif self.scheduled:\nLOGGER.info(f\"{simulation.now:0.2f}:\\tvRequest {self.label} is executing.\")\nif self.flow is not None:\nif callable(self.flow.process_length):\nprocess_length = self.flow.process_length()\nelse:\nprocess_length = self.flow.process_length\nelse:\nprocess_length = 100\nif self.flow is not None:\nif callable(self.flow.packet_size):\npacket_size = self.flow.packet_size()\nelse:\npacket_size = self.flow.packet_size\nelse:\npacket_size = 65536\nif self.flow is not None:\nif callable(self.flow.num_packets):\nnum_packets = self.flow.num_packets()\nelse:\nnum_packets = self.flow.num_packets\nelse:\nnum_packets = 1\nif self.type == GET:\nself.execute_get(process_length, packet_size, num_packets)\nelif self.type == POST:\nself.execute_post(process_length, packet_size, num_packets)\nelif self.type == LIST:\nself.execute_list(process_length, packet_size, num_packets)\nelse:\nraise RuntimeError(f\"vRequest {self.label} is not scheduled.\")\ndef execute_get(self, process_length: int, packet_size: int, num_packets: int):\n\"\"\"Execute the get type request.\n        Args:\n            process_length (int): the length of the process, given by the workflow.\n            packet_size (int): the size of the packet, given by the workflow.\n            num_packets (int): the number of packets, given by the workflow.\n        \"\"\"\nphysical_source = (\nself.source_endpoint.host\nif self.source_endpoint is not None\nelse simulation.gateway\n)\nphysical_destination = (\nself.target_endpoint.host\nif self.target_endpoint is not None\nelse simulation.gateway\n)\nif self.source.__class__.__name__ != \"vUser\":\nprocess = vProcess(\nprocess_length,\npriority=self.priority,\nrequest=self,\ncontainer=self.source_endpoint,\nat=simulation.now,\nlabel=f\"{self.label}-get\",\n)\nelse:\nprocess = None\npackets = list()\npacket = vPacket(\nsource=physical_source,\ndestination=physical_destination,\nrequest=self,\nsize=packet_size,\nat=simulation.now,\nafter=process,\nlabel=f\"{self.label}-get\",\n)\nself.packets.append(packet)\npackets.append(packet)\nif self.target.__class__.__name__ != \"vUser\":\nprocess = vProcess(\nprocess_length,\npriority=self.priority,\nrequest=self,\ncontainer=self.target_endpoint,\nat=simulation.now,\nlabel=f\"{self.label}-reply\",\nafter=packets,\n)\nelse:\nprocess = None\npackets.clear()\nfor _ in range(num_packets):\npacket = vPacket(\nsource=physical_destination,\ndestination=physical_source,\nrequest=self,\nsize=packet_size,\nat=simulation.now,\nafter=process,\nlabel=f\"{self.label}-reply\",\n)\nself.packets.append(packet)\npackets.append(packet)\nif self.source.__class__.__name__ != \"vUser\":\nprocess = vProcess(\nprocess_length,\npriority=self.priority,\nrequest=self,\ncontainer=self.source_endpoint,\nat=simulation.now,\nlabel=f\"{self.label}-ack\",\nafter=packets,\n)\nelse:\nprocess = None\npacket = vPacket(\nsource=physical_destination,\ndestination=physical_source,\nrequest=self,\nsize=packet_size,\nat=simulation.now,\nafter=process if process is not None else packets,\nlabel=f\"{self.label}-ack\",\n)\npacket._on_termination = (\nlambda: self.complete() if packet.completed and not self.failed else None\n)\nself.packets.append(packet)\npackets.append(packet)\ndef execute_post(self, process_length: int, packet_size: int, num_packets: int):\n\"\"\"Execute the post type request.\n        Args:\n            process_length (int): the length of the process, given by the workflow.\n            packet_size (int): the size of the packet, given by the workflow.\n            num_packets (int): the number of packets, given by the workflow.\n        \"\"\"\nphysical_source = (\nself.source_endpoint.host\nif self.source_endpoint is not None\nelse simulation.gateway\n)\nphysical_destination = (\nself.target_endpoint.host\nif self.target_endpoint is not None\nelse simulation.gateway\n)\nif self.source.__class__.__name__ != \"vUser\":\nprocess = vProcess(\nprocess_length,\npriority=self.priority,\nrequest=self,\ncontainer=self.source_endpoint,\nat=simulation.now,\nlabel=f\"{self.label}-post\",\n)\nelse:\nprocess = None\npackets = list()\nfor _ in range(num_packets):\npacket = vPacket(\nsource=physical_source,\ndestination=physical_destination,\nrequest=self,\nsize=packet_size,\nat=simulation.now,\nafter=process,\nlabel=f\"{self.label}-post\",\n)\nself.packets.append(packet)\npackets.append(packet)\nif self.target.__class__.__name__ != \"vUser\":\nprocess = vProcess(\nprocess_length,\npriority=self.priority,\nrequest=self,\ncontainer=self.target_endpoint,\nat=simulation.now,\nlabel=f\"{self.label}-ack\",\nafter=packets,\n)\nelse:\nprocess = None\npackets.clear()\nfor _ in range(num_packets):\npacket = vPacket(\nsource=physical_destination,\ndestination=physical_source,\nrequest=self,\nsize=packet_size,\nat=simulation.now,\nafter=process,\nlabel=f\"{self.label}-ack\",\n)\nself.packets.append(packet)\npackets.append(packet)\nif self.source.__class__.__name__ != \"vUser\":\nprocess = vProcess(\nprocess_length,\npriority=self.priority,\nrequest=self,\ncontainer=self.source_endpoint,\nat=simulation.now,\nlabel=f\"{self.label}-ack\",\nafter=packets,\n)\nprocess._on_termination = (\nlambda: self.complete()\nif process and process.completed and not self.failed\nelse None\n)\nelse:\nprocess = None\npackets[-1].on_termination = (\nlambda: self.complete()\nif packets[-1].completed and not self.failed\nelse None\n)\ndef execute_list(self, process_length: int, packet_size: int, num_packets: int):\n\"\"\"Execute the list type request.\n        Args:\n            process_length (int): the length of the process, given by the workflow.\n            packet_size (int): the size of the packet, given by the workflow.\n            num_packets (int): the number of packets, given by the workflow.\n        \"\"\"\nphysical_source = (\nself.source_endpoint.host\nif self.source_endpoint is not None\nelse simulation.gateway\n)\nphysical_destination = (\nself.target_endpoint.host\nif self.target_endpoint is not None\nelse simulation.gateway\n)\nif self.source.__class__.__name__ != \"vUser\":\nprocess = vProcess(\nprocess_length,\npriority=self.priority,\nrequest=self,\ncontainer=self.source_endpoint,\nat=simulation.now,\nlabel=f\"{self.label}-get\",\n)\nelse:\nprocess = None\npackets = list()\npacket = vPacket(\nsource=physical_source,\ndestination=physical_destination,\nrequest=self,\nsize=packet_size,\nat=simulation.now,\nafter=process,\nlabel=f\"{self.label}-get\",\n)\nself.packets.append(packet)\npackets.append(packet)\nif self.target.__class__.__name__ != \"vUser\":\nprocess = vProcess(\nprocess_length,\npriority=self.priority,\nrequest=self,\ncontainer=self.target_endpoint,\nat=simulation.now,\nlabel=f\"{self.label}-reply\",\nafter=packets,\n)\nelse:\nprocess = None\npackets.clear()\nfor _ in range(num_packets):\npacket = vPacket(\nsource=physical_destination,\ndestination=physical_source,\nrequest=self,\nsize=packet_size,\nat=simulation.now,\nafter=process,\nlabel=f\"{self.label}-reply\",\n)\nself.packets.append(packet)\npackets.append(packet)\nif self.source.__class__.__name__ != \"vUser\":\nprocess = vProcess(\nprocess_length,\npriority=self.priority,\nrequest=self,\ncontainer=self.source_endpoint,\nat=simulation.now,\nlabel=f\"{self.label}-ack\",\nafter=packets,\n)\nelse:\nprocess = None\npacket = vPacket(\nsource=physical_destination,\ndestination=physical_source,\nrequest=self,\nsize=packet_size,\nat=simulation.now,\nafter=process if process is not None else packets,\nlabel=f\"{self.label}-ack\",\n)\npacket._on_termination = (\nlambda: self.complete() if packet.completed and not self.failed else None\n)\nself.packets.append(packet)\npackets.append(packet)\ndef termination(self):\n\"\"\"Terminate the request by terminating all the processes, and remove the request from the source and target endpoints.\"\"\"\nsuper().termination()\nif self.scheduled:\nif self.source_endpoint is not None:\nself.source_endpoint.requests.remove(self)\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\tvRequest {self.label} removed from {self.source_endpoint.label}.\"\n)\nif self.target_endpoint is not None:\nself.target_endpoint.requests.remove(self)\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\tvRequest {self.label} removed from {self.target_endpoint.label}.\"\n)\nsimulation.request_scheduler.schedule()\ndef complete(self):\n\"\"\"Complete the request and engage the termination of the request.\"\"\"\nif not self.completed:\nself.status.append(COMPLETED)\nself.terminate()\nLOGGER.info(f\"{simulation.now:0.2f}:\\tvRequest {self.label} completed.\")\ndef fail(self):\n\"\"\"Fail the request and engage the termination of the request.\"\"\"\nif not self.failed:\nself.status.append(FAILED)\nself.terminate()\nLOGGER.info(f\"{simulation.now:0.2f}:\\tvRequest {self.label} failed.\")\nif self.flow is not None:\nself.flow.fail()\n@property\ndef source(self) -&gt; Union[vUser, vMicroservice]:\nreturn self._source\n@property\ndef source_endpoint(self) -&gt; vContainer:\nreturn self._source_endpoint\n@property\ndef target(self) -&gt; Union[vUser, vMicroservice]:\nreturn self._target\n@property\ndef target_endpoint(self) -&gt; vContainer:\nreturn self._target_endpoint\n@property\ndef processes(self) -&gt; List[vProcess]:\nreturn self._processes\n@property\ndef user(self) -&gt; Optional[vUser]:\nif self.flow:\nreturn self.flow.user\nelse:\nreturn None\n@property\ndef flow(self):\nreturn self._flow\n@property\ndef priority(self) -&gt; int:\nreturn self._priority\n@property\ndef ram_usage(self) -&gt; int:\nreturn sum([process.ram_usage for process in self.processes])\n@property\ndef packets(self) -&gt; List[vPacket]:\nreturn self._packets\n@property\ndef type(self) -&gt; str:\nreturn self._type\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_request/#PyCloudSim.entity.v_request.vRequest.__init__","title":"<code>__init__(source, target, flow=None, type=GET, at=simulation.now, after=None, label=None)</code>","text":"<p>Create a request.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Union[vUser, vMicroservice]</code> <p>the source of this request, can be vUser or vMicroservice.</p> required <code>target</code> <code>Union[vUser, vMicroservice]</code> <p>the target of this request, can be vUser or vMicroservice.</p> required <code>flow</code> <code>Optional[WorkFlow]</code> <p>the workflow of this request. Defaults to None.</p> <code>None</code> <code>type</code> <code>str</code> <p>type of the request, GET, POST, LIST, DELETE. Defaults to GET.</p> <code>GET</code> <code>at</code> <code>Union[int, float, Callable]</code> <p>when the request should be created. Defaults to simulation.now.</p> <code>simulation.now</code> <code>after</code> <code>Optional[Entity | List[Entity]]</code> <p>the entity that this request must be created after. Defaults to None.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>short description of the request. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_request.py</code> <pre><code>def __init__(\nself,\nsource: Union[vUser, vMicroservice],\ntarget: Union[vUser, vMicroservice],\nflow: Optional[WorkFlow] = None,\ntype: str = GET,\nat: Union[int, float, Callable] = simulation.now,\nafter: Optional[Entity | List[Entity]] = None,\nlabel: Optional[str] = None,\n):\n\"\"\"Create a request.\n    Args:\n        source (Union[vUser, vMicroservice]): the source of this request, can be vUser or vMicroservice.\n        target (Union[vUser, vMicroservice]): the target of this request, can be vUser or vMicroservice.\n        flow (Optional[WorkFlow], optional): the workflow of this request. Defaults to None.\n        type (str, optional): type of the request, GET, POST, LIST, DELETE. Defaults to GET.\n        at (Union[int, float, Callable], optional): when the request should be created. Defaults to simulation.now.\n        after (Optional[Entity  |  List[Entity]], optional): the entity that this request must be created after. Defaults to None.\n        label (Optional[str], optional): short description of the request. Defaults to None.\n    \"\"\"\nsuper().__init__(at, after, label)\nself._source = source\nself._target = target\nself._flow = flow if flow else None\nif self.flow:\nif callable(self.flow.priority):\nself._priority = self.flow.priority()\nelse:\nself._priority = self.flow.priority\nelse:\nself._priority = 0\nself._processes = list()\nself._packets = list()\nself._source_endpoint: vContainer = None  # type: ignore\nself._target_endpoint: vContainer = None  # type: ignore\nself._type = type\nself._on_creation = simulation.request_scheduler.schedule\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_request/#PyCloudSim.entity.v_request.vRequest.complete","title":"<code>complete()</code>","text":"<p>Complete the request and engage the termination of the request.</p> Source code in <code>PyCloudSim\\entity\\v_request.py</code> <pre><code>def complete(self):\n\"\"\"Complete the request and engage the termination of the request.\"\"\"\nif not self.completed:\nself.status.append(COMPLETED)\nself.terminate()\nLOGGER.info(f\"{simulation.now:0.2f}:\\tvRequest {self.label} completed.\")\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_request/#PyCloudSim.entity.v_request.vRequest.execute","title":"<code>execute()</code>","text":"<p>Exceute the request by initiating the processes and packets according to the request type.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>raise if the request is not scheduled.</p> Source code in <code>PyCloudSim\\entity\\v_request.py</code> <pre><code>def execute(self):\n\"\"\"Exceute the request by initiating the processes and packets according to the request type.\n    Raises:\n        RuntimeError: raise if the request is not scheduled.\n    \"\"\"\nif self.scheduled:\nLOGGER.info(f\"{simulation.now:0.2f}:\\tvRequest {self.label} is executing.\")\nif self.flow is not None:\nif callable(self.flow.process_length):\nprocess_length = self.flow.process_length()\nelse:\nprocess_length = self.flow.process_length\nelse:\nprocess_length = 100\nif self.flow is not None:\nif callable(self.flow.packet_size):\npacket_size = self.flow.packet_size()\nelse:\npacket_size = self.flow.packet_size\nelse:\npacket_size = 65536\nif self.flow is not None:\nif callable(self.flow.num_packets):\nnum_packets = self.flow.num_packets()\nelse:\nnum_packets = self.flow.num_packets\nelse:\nnum_packets = 1\nif self.type == GET:\nself.execute_get(process_length, packet_size, num_packets)\nelif self.type == POST:\nself.execute_post(process_length, packet_size, num_packets)\nelif self.type == LIST:\nself.execute_list(process_length, packet_size, num_packets)\nelse:\nraise RuntimeError(f\"vRequest {self.label} is not scheduled.\")\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_request/#PyCloudSim.entity.v_request.vRequest.execute_get","title":"<code>execute_get(process_length, packet_size, num_packets)</code>","text":"<p>Execute the get type request.</p> <p>Parameters:</p> Name Type Description Default <code>process_length</code> <code>int</code> <p>the length of the process, given by the workflow.</p> required <code>packet_size</code> <code>int</code> <p>the size of the packet, given by the workflow.</p> required <code>num_packets</code> <code>int</code> <p>the number of packets, given by the workflow.</p> required Source code in <code>PyCloudSim\\entity\\v_request.py</code> <pre><code>def execute_get(self, process_length: int, packet_size: int, num_packets: int):\n\"\"\"Execute the get type request.\n    Args:\n        process_length (int): the length of the process, given by the workflow.\n        packet_size (int): the size of the packet, given by the workflow.\n        num_packets (int): the number of packets, given by the workflow.\n    \"\"\"\nphysical_source = (\nself.source_endpoint.host\nif self.source_endpoint is not None\nelse simulation.gateway\n)\nphysical_destination = (\nself.target_endpoint.host\nif self.target_endpoint is not None\nelse simulation.gateway\n)\nif self.source.__class__.__name__ != \"vUser\":\nprocess = vProcess(\nprocess_length,\npriority=self.priority,\nrequest=self,\ncontainer=self.source_endpoint,\nat=simulation.now,\nlabel=f\"{self.label}-get\",\n)\nelse:\nprocess = None\npackets = list()\npacket = vPacket(\nsource=physical_source,\ndestination=physical_destination,\nrequest=self,\nsize=packet_size,\nat=simulation.now,\nafter=process,\nlabel=f\"{self.label}-get\",\n)\nself.packets.append(packet)\npackets.append(packet)\nif self.target.__class__.__name__ != \"vUser\":\nprocess = vProcess(\nprocess_length,\npriority=self.priority,\nrequest=self,\ncontainer=self.target_endpoint,\nat=simulation.now,\nlabel=f\"{self.label}-reply\",\nafter=packets,\n)\nelse:\nprocess = None\npackets.clear()\nfor _ in range(num_packets):\npacket = vPacket(\nsource=physical_destination,\ndestination=physical_source,\nrequest=self,\nsize=packet_size,\nat=simulation.now,\nafter=process,\nlabel=f\"{self.label}-reply\",\n)\nself.packets.append(packet)\npackets.append(packet)\nif self.source.__class__.__name__ != \"vUser\":\nprocess = vProcess(\nprocess_length,\npriority=self.priority,\nrequest=self,\ncontainer=self.source_endpoint,\nat=simulation.now,\nlabel=f\"{self.label}-ack\",\nafter=packets,\n)\nelse:\nprocess = None\npacket = vPacket(\nsource=physical_destination,\ndestination=physical_source,\nrequest=self,\nsize=packet_size,\nat=simulation.now,\nafter=process if process is not None else packets,\nlabel=f\"{self.label}-ack\",\n)\npacket._on_termination = (\nlambda: self.complete() if packet.completed and not self.failed else None\n)\nself.packets.append(packet)\npackets.append(packet)\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_request/#PyCloudSim.entity.v_request.vRequest.execute_list","title":"<code>execute_list(process_length, packet_size, num_packets)</code>","text":"<p>Execute the list type request.</p> <p>Parameters:</p> Name Type Description Default <code>process_length</code> <code>int</code> <p>the length of the process, given by the workflow.</p> required <code>packet_size</code> <code>int</code> <p>the size of the packet, given by the workflow.</p> required <code>num_packets</code> <code>int</code> <p>the number of packets, given by the workflow.</p> required Source code in <code>PyCloudSim\\entity\\v_request.py</code> <pre><code>def execute_list(self, process_length: int, packet_size: int, num_packets: int):\n\"\"\"Execute the list type request.\n    Args:\n        process_length (int): the length of the process, given by the workflow.\n        packet_size (int): the size of the packet, given by the workflow.\n        num_packets (int): the number of packets, given by the workflow.\n    \"\"\"\nphysical_source = (\nself.source_endpoint.host\nif self.source_endpoint is not None\nelse simulation.gateway\n)\nphysical_destination = (\nself.target_endpoint.host\nif self.target_endpoint is not None\nelse simulation.gateway\n)\nif self.source.__class__.__name__ != \"vUser\":\nprocess = vProcess(\nprocess_length,\npriority=self.priority,\nrequest=self,\ncontainer=self.source_endpoint,\nat=simulation.now,\nlabel=f\"{self.label}-get\",\n)\nelse:\nprocess = None\npackets = list()\npacket = vPacket(\nsource=physical_source,\ndestination=physical_destination,\nrequest=self,\nsize=packet_size,\nat=simulation.now,\nafter=process,\nlabel=f\"{self.label}-get\",\n)\nself.packets.append(packet)\npackets.append(packet)\nif self.target.__class__.__name__ != \"vUser\":\nprocess = vProcess(\nprocess_length,\npriority=self.priority,\nrequest=self,\ncontainer=self.target_endpoint,\nat=simulation.now,\nlabel=f\"{self.label}-reply\",\nafter=packets,\n)\nelse:\nprocess = None\npackets.clear()\nfor _ in range(num_packets):\npacket = vPacket(\nsource=physical_destination,\ndestination=physical_source,\nrequest=self,\nsize=packet_size,\nat=simulation.now,\nafter=process,\nlabel=f\"{self.label}-reply\",\n)\nself.packets.append(packet)\npackets.append(packet)\nif self.source.__class__.__name__ != \"vUser\":\nprocess = vProcess(\nprocess_length,\npriority=self.priority,\nrequest=self,\ncontainer=self.source_endpoint,\nat=simulation.now,\nlabel=f\"{self.label}-ack\",\nafter=packets,\n)\nelse:\nprocess = None\npacket = vPacket(\nsource=physical_destination,\ndestination=physical_source,\nrequest=self,\nsize=packet_size,\nat=simulation.now,\nafter=process if process is not None else packets,\nlabel=f\"{self.label}-ack\",\n)\npacket._on_termination = (\nlambda: self.complete() if packet.completed and not self.failed else None\n)\nself.packets.append(packet)\npackets.append(packet)\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_request/#PyCloudSim.entity.v_request.vRequest.execute_post","title":"<code>execute_post(process_length, packet_size, num_packets)</code>","text":"<p>Execute the post type request.</p> <p>Parameters:</p> Name Type Description Default <code>process_length</code> <code>int</code> <p>the length of the process, given by the workflow.</p> required <code>packet_size</code> <code>int</code> <p>the size of the packet, given by the workflow.</p> required <code>num_packets</code> <code>int</code> <p>the number of packets, given by the workflow.</p> required Source code in <code>PyCloudSim\\entity\\v_request.py</code> <pre><code>def execute_post(self, process_length: int, packet_size: int, num_packets: int):\n\"\"\"Execute the post type request.\n    Args:\n        process_length (int): the length of the process, given by the workflow.\n        packet_size (int): the size of the packet, given by the workflow.\n        num_packets (int): the number of packets, given by the workflow.\n    \"\"\"\nphysical_source = (\nself.source_endpoint.host\nif self.source_endpoint is not None\nelse simulation.gateway\n)\nphysical_destination = (\nself.target_endpoint.host\nif self.target_endpoint is not None\nelse simulation.gateway\n)\nif self.source.__class__.__name__ != \"vUser\":\nprocess = vProcess(\nprocess_length,\npriority=self.priority,\nrequest=self,\ncontainer=self.source_endpoint,\nat=simulation.now,\nlabel=f\"{self.label}-post\",\n)\nelse:\nprocess = None\npackets = list()\nfor _ in range(num_packets):\npacket = vPacket(\nsource=physical_source,\ndestination=physical_destination,\nrequest=self,\nsize=packet_size,\nat=simulation.now,\nafter=process,\nlabel=f\"{self.label}-post\",\n)\nself.packets.append(packet)\npackets.append(packet)\nif self.target.__class__.__name__ != \"vUser\":\nprocess = vProcess(\nprocess_length,\npriority=self.priority,\nrequest=self,\ncontainer=self.target_endpoint,\nat=simulation.now,\nlabel=f\"{self.label}-ack\",\nafter=packets,\n)\nelse:\nprocess = None\npackets.clear()\nfor _ in range(num_packets):\npacket = vPacket(\nsource=physical_destination,\ndestination=physical_source,\nrequest=self,\nsize=packet_size,\nat=simulation.now,\nafter=process,\nlabel=f\"{self.label}-ack\",\n)\nself.packets.append(packet)\npackets.append(packet)\nif self.source.__class__.__name__ != \"vUser\":\nprocess = vProcess(\nprocess_length,\npriority=self.priority,\nrequest=self,\ncontainer=self.source_endpoint,\nat=simulation.now,\nlabel=f\"{self.label}-ack\",\nafter=packets,\n)\nprocess._on_termination = (\nlambda: self.complete()\nif process and process.completed and not self.failed\nelse None\n)\nelse:\nprocess = None\npackets[-1].on_termination = (\nlambda: self.complete()\nif packets[-1].completed and not self.failed\nelse None\n)\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_request/#PyCloudSim.entity.v_request.vRequest.fail","title":"<code>fail()</code>","text":"<p>Fail the request and engage the termination of the request.</p> Source code in <code>PyCloudSim\\entity\\v_request.py</code> <pre><code>def fail(self):\n\"\"\"Fail the request and engage the termination of the request.\"\"\"\nif not self.failed:\nself.status.append(FAILED)\nself.terminate()\nLOGGER.info(f\"{simulation.now:0.2f}:\\tvRequest {self.label} failed.\")\nif self.flow is not None:\nself.flow.fail()\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_request/#PyCloudSim.entity.v_request.vRequest.termination","title":"<code>termination()</code>","text":"<p>Terminate the request by terminating all the processes, and remove the request from the source and target endpoints.</p> Source code in <code>PyCloudSim\\entity\\v_request.py</code> <pre><code>def termination(self):\n\"\"\"Terminate the request by terminating all the processes, and remove the request from the source and target endpoints.\"\"\"\nsuper().termination()\nif self.scheduled:\nif self.source_endpoint is not None:\nself.source_endpoint.requests.remove(self)\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\tvRequest {self.label} removed from {self.source_endpoint.label}.\"\n)\nif self.target_endpoint is not None:\nself.target_endpoint.requests.remove(self)\nLOGGER.info(\nf\"{simulation.now:0.2f}:\\tvRequest {self.label} removed from {self.target_endpoint.label}.\"\n)\nsimulation.request_scheduler.schedule()\n</code></pre>"},{"location":"api/virtual_entity/sfc_networkservice/","title":"Index","text":"<p>The class \"vSFC\" represents the simulated Service Function Chain, which is comprised of one or more instances of the \"vMicroservice\" class. The topology of the \"vMicroservice\" instances within the \"vSFC\" determines the order and type of simulated API calls when the \"vSFC\" is engaged by a simulated user.</p> <p>The directional links between \"vMicroservice\" instances within the \"vSFC\" define the sequence of API calls that will occur. This topology simulates the flow of requests and interactions between the different microservices within the Service Function Chain.</p> <p>On the other hand, the class \"vNetworkService\" serves as a collection of \"vMicroservice\" instances and their associated topology. Multiple instances of the \"vSFC\" class can be derived from a single \"vNetworkService\". For example, a \"vNetworkService\" representing the 5G SA core could contain one \"vSFC\" for user device authentication and another \"vSFC\" for internet access.</p> <p>Both the \"vSFC\" and \"vNetworkService\" classes are considered ready only when all their associated \"vMicroservice\" instances have reached a ready state. The readiness of a \"vMicroservice\" is determined by various factors, such as the completion of initialization and the fulfilment of resource requirements.</p> <p>When a \"vSFC\" is ready, it can be engaged by a simulated user. However, if the \"vSFC\" is not yet ready, the engagement will be put on hold until all the necessary components are in a ready state.</p> <p>Overall, the \"vSFC\" and \"vNetworkService\" classes enable the modelling and simulation of Service Function Chains and their associated network services, ensuring readiness and proper sequencing of simulated API calls within the simulated cloud environment.</p>"},{"location":"api/virtual_entity/sfc_networkservice/v_networkservice/","title":"vNetworkService","text":"<p>         Bases: <code>VirtualEntity</code></p> Source code in <code>PyCloudSim\\entity\\v_networkservice.py</code> <pre><code>class vNetworkService(VirtualEntity):\ndef __init__(\nself,\nmicroservices: List[vMicroservice],\nlinks: List[Tuple[vMicroservice, vMicroservice]],\nentry: Optional[vMicroservice | List[vMicroservice]],\nexit: Optional[vMicroservice | List[vMicroservice]],\nat: Union[int, float, Callable] = simulation.now,\nafter: Optional[Entity | List[Entity]] = None,\nlabel: Optional[str] = None,\n):\n\"\"\"Create a vNetworkService\n        Args:\n            microservices (List[vMicroservice]): the list of engaged microservices.\n            links (List[Tuple[vMicroservice, vMicroservice]]): the links of the microservices.\n            entry (Optional[vMicroservice  |  List[vMicroservice]]): the entry point of the network service, aka the microservice that will accept user's request at the beginning.\n            exit (Optional[vMicroservice  |  List[vMicroservice]]): _description_\n            at (Union[int, float, Callable], optional): _description_. Defaults to simulation.now.\n            after (Optional[Entity  |  List[Entity]], optional): _description_. Defaults to None.\n            label (Optional[str], optional): _description_. Defaults to None.\n        \"\"\"\nsuper().__init__(at=at, after=after, label=label)\nself._microservices = microservices\nself._links = links\nself._graph = nx.DiGraph()\nself.graph.add_nodes_from(self.microservices)\nfor link in self.links:\nself.graph.add_edge(link[0], link[1])\nself.graph.add_edge(link[1], link[0])\nif isinstance(entry, list):\nself._entry = list()\nfor e in entry:\nif e in self.graph.nodes:\nself._entry.append(e)\nelse:\nraise ValueError(\nf\"vMicroservice {e.label} is not in the topology of vNetworkService {self.label}\"\n)\nelif isinstance(entry, vMicroservice):\nif entry in self.graph.nodes:\nself._entry = entry\nelse:\nraise ValueError(\nf\"vMicroservice {entry.label} is not in the topology of vNetworkService {self.label}\"\n)\nif isinstance(exit, list):\nself._exit = list()\nfor e in exit:\nif e in self.graph.nodes:\nself._exit.append(e)\nelse:\nraise ValueError(\nf\"vMicroservice {e.label} is not in the topology of vNetworkService {self.label}\"\n)\nelif isinstance(exit, vMicroservice):\nif exit in self.graph.nodes:\nself._exit = exit\nelse:\nraise ValueError(\nf\"vMicroservice {exit.label} is not in the topology of vNetworkService {self.label}\"\n)\nsimulation.NETWORKSERVICES.append(self)\ndef termination(self):\n\"\"\"Terminate the vNetworkService and all its microservices and SFCS\"\"\"\nsuper().termination()\nfor ms in self.microservices:\nms.terminate()\nfor sfc in simulation.SFCS:\nif sfc.network_service is self:\nsfc.terminate()\ndef draw(self, save: bool = False):\n\"\"\"Plot the topology of the vNetworkService\"\"\"\nfig, ax = plt.subplots()\nlabel_mapping = dict()\nfor ms in self.microservices:\nlabel_mapping[ms] = ms.label\npos = spring_layout(self.graph)\nfor node in self.graph.nodes:\ndraw_networkx_nodes(\nself.graph, pos, ax=ax, nodelist=[node], node_color=\"tab:green\"\n)\nfor edge in self.graph.edges:\ndraw_networkx_edges(\nself.graph, pos, ax=ax, edgelist=[edge], edge_color=\"tab:gray\"\n)\nif isinstance(self.entry, list):\ndraw_networkx_nodes(\nself.graph, pos, ax=ax, nodelist=self.entry, node_color=\"tab:red\"\n)\nelif isinstance(self.entry, vMicroservice):\ndraw_networkx_nodes(\nself.graph, pos, ax=ax, nodelist=[self.entry], node_color=\"tab:red\"\n)\nif isinstance(self.exit, list):\ndraw_networkx_nodes(\nself.graph, pos, ax=ax, nodelist=self.exit, node_color=\"tab:blue\"\n)\nelif isinstance(self.exit, vMicroservice):\ndraw_networkx_nodes(\nself.graph, pos, ax=ax, nodelist=[self.exit], node_color=\"tab:blue\"\n)\ndraw_networkx_labels(self.graph, pos, labels=label_mapping, ax=ax)\nplt.show()\nif save:\nfig.savefig(f\"{self.label}.png\")\n@property\ndef microservices(self) -&gt; List[vMicroservice]:\n\"\"\"The list of microservices engaged in the vNetworkService\"\"\"\nreturn self._microservices\n@property\ndef links(self) -&gt; List[Tuple[vMicroservice, vMicroservice]]:\n\"\"\"The links of the microservices\"\"\"\nreturn self._links\n@property\ndef graph(self) -&gt; nx.DiGraph:\n\"\"\"The topology of the vNetworkService\"\"\"\nreturn self._graph\n@property\ndef entry(self) -&gt; Optional[vMicroservice | List[vMicroservice]]:\n\"\"\"The entry point of the vNetworkService\"\"\"\nreturn self._entry\n@property\ndef exit(self) -&gt; Optional[vMicroservice | List[vMicroservice]]:\n\"\"\"The exit point of the vNetworkService\"\"\"\nreturn self._exit\n</code></pre>"},{"location":"api/virtual_entity/sfc_networkservice/v_networkservice/#PyCloudSim.entity.v_networkservice.vNetworkService.entry","title":"<code>entry: Optional[vMicroservice | List[vMicroservice]]</code>  <code>property</code>","text":"<p>The entry point of the vNetworkService</p>"},{"location":"api/virtual_entity/sfc_networkservice/v_networkservice/#PyCloudSim.entity.v_networkservice.vNetworkService.exit","title":"<code>exit: Optional[vMicroservice | List[vMicroservice]]</code>  <code>property</code>","text":"<p>The exit point of the vNetworkService</p>"},{"location":"api/virtual_entity/sfc_networkservice/v_networkservice/#PyCloudSim.entity.v_networkservice.vNetworkService.graph","title":"<code>graph: nx.DiGraph</code>  <code>property</code>","text":"<p>The topology of the vNetworkService</p>"},{"location":"api/virtual_entity/sfc_networkservice/v_networkservice/#PyCloudSim.entity.v_networkservice.vNetworkService.links","title":"<code>links: List[Tuple[vMicroservice, vMicroservice]]</code>  <code>property</code>","text":"<p>The links of the microservices</p>"},{"location":"api/virtual_entity/sfc_networkservice/v_networkservice/#PyCloudSim.entity.v_networkservice.vNetworkService.microservices","title":"<code>microservices: List[vMicroservice]</code>  <code>property</code>","text":"<p>The list of microservices engaged in the vNetworkService</p>"},{"location":"api/virtual_entity/sfc_networkservice/v_networkservice/#PyCloudSim.entity.v_networkservice.vNetworkService.__init__","title":"<code>__init__(microservices, links, entry, exit, at=simulation.now, after=None, label=None)</code>","text":"<p>Create a vNetworkService</p> <p>Parameters:</p> Name Type Description Default <code>microservices</code> <code>List[vMicroservice]</code> <p>the list of engaged microservices.</p> required <code>links</code> <code>List[Tuple[vMicroservice, vMicroservice]]</code> <p>the links of the microservices.</p> required <code>entry</code> <code>Optional[vMicroservice | List[vMicroservice]]</code> <p>the entry point of the network service, aka the microservice that will accept user's request at the beginning.</p> required <code>exit</code> <code>Optional[vMicroservice | List[vMicroservice]]</code> <p>description</p> required <code>at</code> <code>Union[int, float, Callable]</code> <p>description. Defaults to simulation.now.</p> <code>simulation.now</code> <code>after</code> <code>Optional[Entity | List[Entity]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>description. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_networkservice.py</code> <pre><code>def __init__(\nself,\nmicroservices: List[vMicroservice],\nlinks: List[Tuple[vMicroservice, vMicroservice]],\nentry: Optional[vMicroservice | List[vMicroservice]],\nexit: Optional[vMicroservice | List[vMicroservice]],\nat: Union[int, float, Callable] = simulation.now,\nafter: Optional[Entity | List[Entity]] = None,\nlabel: Optional[str] = None,\n):\n\"\"\"Create a vNetworkService\n    Args:\n        microservices (List[vMicroservice]): the list of engaged microservices.\n        links (List[Tuple[vMicroservice, vMicroservice]]): the links of the microservices.\n        entry (Optional[vMicroservice  |  List[vMicroservice]]): the entry point of the network service, aka the microservice that will accept user's request at the beginning.\n        exit (Optional[vMicroservice  |  List[vMicroservice]]): _description_\n        at (Union[int, float, Callable], optional): _description_. Defaults to simulation.now.\n        after (Optional[Entity  |  List[Entity]], optional): _description_. Defaults to None.\n        label (Optional[str], optional): _description_. Defaults to None.\n    \"\"\"\nsuper().__init__(at=at, after=after, label=label)\nself._microservices = microservices\nself._links = links\nself._graph = nx.DiGraph()\nself.graph.add_nodes_from(self.microservices)\nfor link in self.links:\nself.graph.add_edge(link[0], link[1])\nself.graph.add_edge(link[1], link[0])\nif isinstance(entry, list):\nself._entry = list()\nfor e in entry:\nif e in self.graph.nodes:\nself._entry.append(e)\nelse:\nraise ValueError(\nf\"vMicroservice {e.label} is not in the topology of vNetworkService {self.label}\"\n)\nelif isinstance(entry, vMicroservice):\nif entry in self.graph.nodes:\nself._entry = entry\nelse:\nraise ValueError(\nf\"vMicroservice {entry.label} is not in the topology of vNetworkService {self.label}\"\n)\nif isinstance(exit, list):\nself._exit = list()\nfor e in exit:\nif e in self.graph.nodes:\nself._exit.append(e)\nelse:\nraise ValueError(\nf\"vMicroservice {e.label} is not in the topology of vNetworkService {self.label}\"\n)\nelif isinstance(exit, vMicroservice):\nif exit in self.graph.nodes:\nself._exit = exit\nelse:\nraise ValueError(\nf\"vMicroservice {exit.label} is not in the topology of vNetworkService {self.label}\"\n)\nsimulation.NETWORKSERVICES.append(self)\n</code></pre>"},{"location":"api/virtual_entity/sfc_networkservice/v_networkservice/#PyCloudSim.entity.v_networkservice.vNetworkService.draw","title":"<code>draw(save=False)</code>","text":"<p>Plot the topology of the vNetworkService</p> Source code in <code>PyCloudSim\\entity\\v_networkservice.py</code> <pre><code>def draw(self, save: bool = False):\n\"\"\"Plot the topology of the vNetworkService\"\"\"\nfig, ax = plt.subplots()\nlabel_mapping = dict()\nfor ms in self.microservices:\nlabel_mapping[ms] = ms.label\npos = spring_layout(self.graph)\nfor node in self.graph.nodes:\ndraw_networkx_nodes(\nself.graph, pos, ax=ax, nodelist=[node], node_color=\"tab:green\"\n)\nfor edge in self.graph.edges:\ndraw_networkx_edges(\nself.graph, pos, ax=ax, edgelist=[edge], edge_color=\"tab:gray\"\n)\nif isinstance(self.entry, list):\ndraw_networkx_nodes(\nself.graph, pos, ax=ax, nodelist=self.entry, node_color=\"tab:red\"\n)\nelif isinstance(self.entry, vMicroservice):\ndraw_networkx_nodes(\nself.graph, pos, ax=ax, nodelist=[self.entry], node_color=\"tab:red\"\n)\nif isinstance(self.exit, list):\ndraw_networkx_nodes(\nself.graph, pos, ax=ax, nodelist=self.exit, node_color=\"tab:blue\"\n)\nelif isinstance(self.exit, vMicroservice):\ndraw_networkx_nodes(\nself.graph, pos, ax=ax, nodelist=[self.exit], node_color=\"tab:blue\"\n)\ndraw_networkx_labels(self.graph, pos, labels=label_mapping, ax=ax)\nplt.show()\nif save:\nfig.savefig(f\"{self.label}.png\")\n</code></pre>"},{"location":"api/virtual_entity/sfc_networkservice/v_networkservice/#PyCloudSim.entity.v_networkservice.vNetworkService.termination","title":"<code>termination()</code>","text":"<p>Terminate the vNetworkService and all its microservices and SFCS</p> Source code in <code>PyCloudSim\\entity\\v_networkservice.py</code> <pre><code>def termination(self):\n\"\"\"Terminate the vNetworkService and all its microservices and SFCS\"\"\"\nsuper().termination()\nfor ms in self.microservices:\nms.terminate()\nfor sfc in simulation.SFCS:\nif sfc.network_service is self:\nsfc.terminate()\n</code></pre>"},{"location":"api/virtual_entity/sfc_networkservice/v_sfc/","title":"vSFC","text":"<p>         Bases: <code>VirtualEntity</code></p> Source code in <code>PyCloudSim\\entity\\v_sfc.py</code> <pre><code>class vSFC(VirtualEntity):\ndef __init__(\nself,\nentry: Optional[Tuple[vMicroservice, str]] = None,\nexit: Optional[Tuple[vMicroservice, str]] = None,\npath: Optional[List[Tuple[vMicroservice, vMicroservice, str]]] = None,\nnetwork_service: Optional[vNetworkService] = None,\ninternal: bool = False,\nat: Union[int, float, Callable] = simulation.now,\nafter: Optional[Entity | List[Entity]] = None,\nlabel: Optional[str] = None,\n):\n\"\"\"Create a vSFC (with respective of a network service)\n        Args:\n            entry (Optional[vMicroservice], optional): the entry point of the SFC, aka the microservice that will accept user's request at the beginning. Defaults to None, must be set if the sfc is not internal.\n            exit (Optional[vMicroservice], optional): the exit point of the SFC, aka the microservice that will return user's request at the last. Defaults to None.\n            path (Optional[List[Tuple[vMicroservice, vMicroservice]]], optional): the path of the engaged microservices, must be a list of tuple of two microservice. Defaults to None.\n            network_service (Optional[vNetworkService], optional): the associated network service. Defaults to None.\n            process_length (Union[int, Callable], optional): the process length of each request. Defaults to 100, can alse be a callable function.\n            packet_size (Union[int, Callable], optional): the packet size of each packet. Defaults to 65536, can alse be a callable function.\n            num_packets (Union[int, Callable], optional): the number of packets per request. Defaults to 1, can alse be a callable function.\n            priority (int, optional): the priority of the SFC. Defaults to 0.\n            num_users (int, optional): the number of users. Defaults to 1.\n            internal (bool, optional): set true for internal SFC, aka the engaged microservices does not need to communicate with the user. Defaults to False.\n            retry (bool, optional): if true, failed user will have its request being re-initialized. Defaults to False.\n            at (Union[int, float, Callable], optional): when the SFC will be created. Defaults to simulation.now.\n            after (Optional[Entity  |  List[Entity]], optional): the other SFCs that must complete before this SFC. Defaults to None.\n            label (Optional[str], optional): short description of this SFC. Defaults to None.\n        \"\"\"\nsuper().__init__(at, after, label)\n# check if the vSFC is valid\nself._entry = entry\nself._exit = exit\nself._path = path if path is not None else list()\nif path is not None:\nif self.entry is not None:\nif self.entry[0] is not path[0][0]:\nraise ValueError(\nf\"Start vMicroservice {self.entry[0].label} is not the same as the first node {path[0][0].label} in the path\"\n)\nif self.exit is not None:\nif self.exit[0] is not path[-1][1]:\nraise ValueError(\nf\"End vMicroservice {self.exit[0].label} is not the same as the last node {path[-1][1].label} in the path\"\n)\n# check if the vSFC is valid with respect to the vNetworkService\nself._ns_id = network_service.id if network_service is not None else None\nif self.network_service is not None:\nif self.entry is not None:\nif isinstance(self.network_service.entry, list):\nif self.entry[0] not in self.network_service.entry:\nraise ValueError(\nf\"vSFC {self.label} Start vMicroservice {self.entry[0].label} is not one of the entries vNetworkService {self.network_service.label}\"\n)\nelse:\nif self.entry[0] is not self.network_service.entry:\nraise ValueError(\nf\"vSFC {self.label} Start vMicroservice {self.entry[0].label} is not the entry vNetworkService {self.network_service.label}\"\n)\nif self.exit is not None:\nif isinstance(self.network_service.exit, list):\nif self.exit[0] not in self.network_service.exit:\nraise ValueError(\nf\"vSFC {self.label} End vMicroservice {self.exit[0].label} is not one of the exits vNetworkService {self.network_service.label}\"\n)\nelse:\nif self.exit[0] is not self.network_service.exit:\nraise ValueError(\nf\"vSFC {self.label} End vMicroservice {self.exit[0].label} is not the exit vNetworkService {self.network_service.label}\"\n)\nself._microservices: List[vMicroservice] = list()\nfor link in self.path:\nif link[0] not in self.microservices:\nself.microservices.append(link[0])\nif link[1] not in self.microservices:\nself.microservices.append(link[1])\nself._users = list()\nself._internal = internal\nself._after: Union[vSFC, List[vSFC]] = after  # type: ignore\nsimulation.SFCS.append(self)\ndef termination(self):\n\"\"\"Terminate the vSFC and all its microservices.\"\"\"\nsuper().termination()\nfor ms in self.microservices:\nif not ms.terminated:\nms.terminate()\ndef evaluate(self):\n\"\"\"Evaluate the vSFC and all its microservices. Change the status of the vSFC to READY if all its microservices are ready.\"\"\"\nif all(ms.ready for ms in self.microservices):\nself.status.append(READY)\nLOGGER.info(f\"{simulation.now:0.2f}:\\tvSFC {self.label} is ready.\")\nelse:\nif self.ready:\nself.status.remove(READY)\n@property\ndef entry(self):\n\"\"\"The entry point of the SFC, aka the microservice that will accept user's request at the beginning.\"\"\"\nreturn self._entry\n@property\ndef exit(self):\n\"\"\"The exit point of the SFC, aka the microservice that will return user's request at the last.\"\"\"\nreturn self._exit\n@property\ndef path(self):\n\"\"\"The path of the engaged microservices, must be a list of tuple of two microservice and request type.\"\"\"\nreturn self._path\n@property\ndef users(self):\n\"\"\"The users of the vSFC.\"\"\"\nreturn self._users\n@property\ndef microservices(self):\n\"\"\"The microservices of the vSFC.\"\"\"\nreturn self._microservices\n@property\ndef network_service(self) -&gt; Optional[vNetworkService]:\n\"\"\"The associated network service.\"\"\"\nif self._ns_id is not None:\nfor ns in simulation.NETWORKSERVICES:\nif ns.id == self._ns_id:\nreturn ns\nraise RuntimeError(\nf\"vSFC {self.label} cannot find its associated network service\"\n)\nelse:\nreturn None\n@property\ndef internal(self):\n\"\"\"Return true if the vSFC is internal, aka the engaged microservices does not need to communicate with the user.\"\"\"\"\"\nreturn self._internal\n@property\ndef after(self):\n\"\"\"Same as entity.\"\"\"\nreturn self._after\n@property\ndef ready(self):\n\"\"\"Return true if the vSFC is ready, aka all its microservices are ready.\"\"\"\nreturn READY in self.status\n</code></pre>"},{"location":"api/virtual_entity/sfc_networkservice/v_sfc/#PyCloudSim.entity.v_sfc.vSFC.after","title":"<code>after</code>  <code>property</code>","text":"<p>Same as entity.</p>"},{"location":"api/virtual_entity/sfc_networkservice/v_sfc/#PyCloudSim.entity.v_sfc.vSFC.entry","title":"<code>entry</code>  <code>property</code>","text":"<p>The entry point of the SFC, aka the microservice that will accept user's request at the beginning.</p>"},{"location":"api/virtual_entity/sfc_networkservice/v_sfc/#PyCloudSim.entity.v_sfc.vSFC.exit","title":"<code>exit</code>  <code>property</code>","text":"<p>The exit point of the SFC, aka the microservice that will return user's request at the last.</p>"},{"location":"api/virtual_entity/sfc_networkservice/v_sfc/#PyCloudSim.entity.v_sfc.vSFC.internal","title":"<code>internal</code>  <code>property</code>","text":"<p>Return true if the vSFC is internal, aka the engaged microservices does not need to communicate with the user.</p>"},{"location":"api/virtual_entity/sfc_networkservice/v_sfc/#PyCloudSim.entity.v_sfc.vSFC.microservices","title":"<code>microservices</code>  <code>property</code>","text":"<p>The microservices of the vSFC.</p>"},{"location":"api/virtual_entity/sfc_networkservice/v_sfc/#PyCloudSim.entity.v_sfc.vSFC.network_service","title":"<code>network_service: Optional[vNetworkService]</code>  <code>property</code>","text":"<p>The associated network service.</p>"},{"location":"api/virtual_entity/sfc_networkservice/v_sfc/#PyCloudSim.entity.v_sfc.vSFC.path","title":"<code>path</code>  <code>property</code>","text":"<p>The path of the engaged microservices, must be a list of tuple of two microservice and request type.</p>"},{"location":"api/virtual_entity/sfc_networkservice/v_sfc/#PyCloudSim.entity.v_sfc.vSFC.ready","title":"<code>ready</code>  <code>property</code>","text":"<p>Return true if the vSFC is ready, aka all its microservices are ready.</p>"},{"location":"api/virtual_entity/sfc_networkservice/v_sfc/#PyCloudSim.entity.v_sfc.vSFC.users","title":"<code>users</code>  <code>property</code>","text":"<p>The users of the vSFC.</p>"},{"location":"api/virtual_entity/sfc_networkservice/v_sfc/#PyCloudSim.entity.v_sfc.vSFC.__init__","title":"<code>__init__(entry=None, exit=None, path=None, network_service=None, internal=False, at=simulation.now, after=None, label=None)</code>","text":"<p>Create a vSFC (with respective of a network service)</p> <p>Parameters:</p> Name Type Description Default <code>entry</code> <code>Optional[vMicroservice]</code> <p>the entry point of the SFC, aka the microservice that will accept user's request at the beginning. Defaults to None, must be set if the sfc is not internal.</p> <code>None</code> <code>exit</code> <code>Optional[vMicroservice]</code> <p>the exit point of the SFC, aka the microservice that will return user's request at the last. Defaults to None.</p> <code>None</code> <code>path</code> <code>Optional[List[Tuple[vMicroservice, vMicroservice]]]</code> <p>the path of the engaged microservices, must be a list of tuple of two microservice. Defaults to None.</p> <code>None</code> <code>network_service</code> <code>Optional[vNetworkService]</code> <p>the associated network service. Defaults to None.</p> <code>None</code> <code>process_length</code> <code>Union[int, Callable]</code> <p>the process length of each request. Defaults to 100, can alse be a callable function.</p> required <code>packet_size</code> <code>Union[int, Callable]</code> <p>the packet size of each packet. Defaults to 65536, can alse be a callable function.</p> required <code>num_packets</code> <code>Union[int, Callable]</code> <p>the number of packets per request. Defaults to 1, can alse be a callable function.</p> required <code>priority</code> <code>int</code> <p>the priority of the SFC. Defaults to 0.</p> required <code>num_users</code> <code>int</code> <p>the number of users. Defaults to 1.</p> required <code>internal</code> <code>bool</code> <p>set true for internal SFC, aka the engaged microservices does not need to communicate with the user. Defaults to False.</p> <code>False</code> <code>retry</code> <code>bool</code> <p>if true, failed user will have its request being re-initialized. Defaults to False.</p> required <code>at</code> <code>Union[int, float, Callable]</code> <p>when the SFC will be created. Defaults to simulation.now.</p> <code>simulation.now</code> <code>after</code> <code>Optional[Entity | List[Entity]]</code> <p>the other SFCs that must complete before this SFC. Defaults to None.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>short description of this SFC. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_sfc.py</code> <pre><code>def __init__(\nself,\nentry: Optional[Tuple[vMicroservice, str]] = None,\nexit: Optional[Tuple[vMicroservice, str]] = None,\npath: Optional[List[Tuple[vMicroservice, vMicroservice, str]]] = None,\nnetwork_service: Optional[vNetworkService] = None,\ninternal: bool = False,\nat: Union[int, float, Callable] = simulation.now,\nafter: Optional[Entity | List[Entity]] = None,\nlabel: Optional[str] = None,\n):\n\"\"\"Create a vSFC (with respective of a network service)\n    Args:\n        entry (Optional[vMicroservice], optional): the entry point of the SFC, aka the microservice that will accept user's request at the beginning. Defaults to None, must be set if the sfc is not internal.\n        exit (Optional[vMicroservice], optional): the exit point of the SFC, aka the microservice that will return user's request at the last. Defaults to None.\n        path (Optional[List[Tuple[vMicroservice, vMicroservice]]], optional): the path of the engaged microservices, must be a list of tuple of two microservice. Defaults to None.\n        network_service (Optional[vNetworkService], optional): the associated network service. Defaults to None.\n        process_length (Union[int, Callable], optional): the process length of each request. Defaults to 100, can alse be a callable function.\n        packet_size (Union[int, Callable], optional): the packet size of each packet. Defaults to 65536, can alse be a callable function.\n        num_packets (Union[int, Callable], optional): the number of packets per request. Defaults to 1, can alse be a callable function.\n        priority (int, optional): the priority of the SFC. Defaults to 0.\n        num_users (int, optional): the number of users. Defaults to 1.\n        internal (bool, optional): set true for internal SFC, aka the engaged microservices does not need to communicate with the user. Defaults to False.\n        retry (bool, optional): if true, failed user will have its request being re-initialized. Defaults to False.\n        at (Union[int, float, Callable], optional): when the SFC will be created. Defaults to simulation.now.\n        after (Optional[Entity  |  List[Entity]], optional): the other SFCs that must complete before this SFC. Defaults to None.\n        label (Optional[str], optional): short description of this SFC. Defaults to None.\n    \"\"\"\nsuper().__init__(at, after, label)\n# check if the vSFC is valid\nself._entry = entry\nself._exit = exit\nself._path = path if path is not None else list()\nif path is not None:\nif self.entry is not None:\nif self.entry[0] is not path[0][0]:\nraise ValueError(\nf\"Start vMicroservice {self.entry[0].label} is not the same as the first node {path[0][0].label} in the path\"\n)\nif self.exit is not None:\nif self.exit[0] is not path[-1][1]:\nraise ValueError(\nf\"End vMicroservice {self.exit[0].label} is not the same as the last node {path[-1][1].label} in the path\"\n)\n# check if the vSFC is valid with respect to the vNetworkService\nself._ns_id = network_service.id if network_service is not None else None\nif self.network_service is not None:\nif self.entry is not None:\nif isinstance(self.network_service.entry, list):\nif self.entry[0] not in self.network_service.entry:\nraise ValueError(\nf\"vSFC {self.label} Start vMicroservice {self.entry[0].label} is not one of the entries vNetworkService {self.network_service.label}\"\n)\nelse:\nif self.entry[0] is not self.network_service.entry:\nraise ValueError(\nf\"vSFC {self.label} Start vMicroservice {self.entry[0].label} is not the entry vNetworkService {self.network_service.label}\"\n)\nif self.exit is not None:\nif isinstance(self.network_service.exit, list):\nif self.exit[0] not in self.network_service.exit:\nraise ValueError(\nf\"vSFC {self.label} End vMicroservice {self.exit[0].label} is not one of the exits vNetworkService {self.network_service.label}\"\n)\nelse:\nif self.exit[0] is not self.network_service.exit:\nraise ValueError(\nf\"vSFC {self.label} End vMicroservice {self.exit[0].label} is not the exit vNetworkService {self.network_service.label}\"\n)\nself._microservices: List[vMicroservice] = list()\nfor link in self.path:\nif link[0] not in self.microservices:\nself.microservices.append(link[0])\nif link[1] not in self.microservices:\nself.microservices.append(link[1])\nself._users = list()\nself._internal = internal\nself._after: Union[vSFC, List[vSFC]] = after  # type: ignore\nsimulation.SFCS.append(self)\n</code></pre>"},{"location":"api/virtual_entity/sfc_networkservice/v_sfc/#PyCloudSim.entity.v_sfc.vSFC.evaluate","title":"<code>evaluate()</code>","text":"<p>Evaluate the vSFC and all its microservices. Change the status of the vSFC to READY if all its microservices are ready.</p> Source code in <code>PyCloudSim\\entity\\v_sfc.py</code> <pre><code>def evaluate(self):\n\"\"\"Evaluate the vSFC and all its microservices. Change the status of the vSFC to READY if all its microservices are ready.\"\"\"\nif all(ms.ready for ms in self.microservices):\nself.status.append(READY)\nLOGGER.info(f\"{simulation.now:0.2f}:\\tvSFC {self.label} is ready.\")\nelse:\nif self.ready:\nself.status.remove(READY)\n</code></pre>"},{"location":"api/virtual_entity/sfc_networkservice/v_sfc/#PyCloudSim.entity.v_sfc.vSFC.termination","title":"<code>termination()</code>","text":"<p>Terminate the vSFC and all its microservices.</p> Source code in <code>PyCloudSim\\entity\\v_sfc.py</code> <pre><code>def termination(self):\n\"\"\"Terminate the vSFC and all its microservices.\"\"\"\nsuper().termination()\nfor ms in self.microservices:\nif not ms.terminated:\nms.terminate()\n</code></pre>"}]}