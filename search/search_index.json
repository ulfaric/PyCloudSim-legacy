{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to PyCloudSim Docs (This version is no longer maintained!)","text":""},{"location":"#please-go-to-httpsulfaricgithubiopycloudsim","title":"Please go to https://ulfaric.github.io/PyCloudSim/","text":"<p>PyCloudSim is a simulation toolkit written in python to simulate cloud computing with incorporation of Network Service and Service Funtion Chain. It is based a light-weighted discrete event simulation library Akatosh. PyCloudSim is inspired by CloudSim and CloudSim Plus. However, PyCloudSim simulates the computation fundamentally differently. </p> <p>In CloudSim, a computing work is defined as a Cloudlet with a given length. Then, the Cloudlet is scheduled onto VM. The Cloudlet included two functions defined for CPU usage and RAM usage. Hence, the actual resource usages are just random numbers generated from a predefined function.</p> <p>In PyCloudSim, a computing work is defined as vProcess which has a instruction length. Then a set of random bytes are generated as \"instructons\" to determine the RAM usage for this vProcess. Then, PyCloudSim simulates the CPU for scheduling process on multiple core for execution. Hence, vProcess could occupiy one or more vCPUCore at the same time. Each vCPUCore consumes the \"insrtuctions\" according to schedule from vCPU. While vCPUCore is executing \"instructions\", its computational power ( defined by frequency and instructions per cycle ) is considered as been used. After executing, the vCPUCore will regain the used computational power. When a vProcess has its \"instructions\" all been executed, then it is complete. Therefore, the CPU and RAM usage patterns simulated by PyCloudSim are not merely random numbers, they are more realistic to how a real computer should behave.</p> <p>In addtion, PyCloudSim also simulates the network traffic. That is, vPackets will be created along vProcess. Then, vNIC will queue and transmit them! So you can simulate a API call between vContainers! The API call is simulated as vRequest and only when its associated vProcess is complete and all its associated vPackets have reached the destination, the vRequest is complete! This is impossible within CloudSim or CloudSim Plus.</p>"},{"location":"demo/","title":"Demo","text":"<pre><code>from PyCloudSim.entity import vMicroserviceDeafult, vHost, vNetworkService, vSFC, vUser\nfrom PyCloudSim.monitor import (\n    HostMonitor,\n    PacketMonitor,\n    MSMonitor,\n    WorkFlowMonitor,\n    RequestMonitor,\n)\nfrom PyCloudSim.core import simulation\nfrom PyCloudSim.util import *\nimport random\nfrom Akatosh import event\n\ndefault_settings()\ninitiate_topology()\nfor i in range(2):\n    vHost(num_cpu_cores=2, ipc=1, frequency=2000, ram=16, rom=32, label=f\"Host {i}\")\n\nms1 = vMicroserviceDeafult(\n    cpu=40,\n    cpu_limit=80,\n    ram=512,\n    ram_limit=1024,\n    image_size=100,\n    volumes=[(\"test\", \"test\", 100, False), (\"test2\", \"test\", 100, True)],\n    min_num_containers=4,\n    max_num_containers=5,\n    label=\"Microservice 1\",\n    deamon=False,\n)\n\nms2 = vMicroserviceDeafult(\n    cpu=40,\n    cpu_limit=80,\n    ram=512,\n    ram_limit=1024,\n    image_size=100,\n    volumes=[(\"test\", \"test\", 100, False), (\"test2\", \"test\", 100, True)],\n    min_num_containers=3,\n    max_num_containers=5,\n    label=\"Microservice 2\",\n    deamon=False,\n)\n\nms3 = vMicroserviceDeafult(\n    cpu=40,\n    cpu_limit=80,\n    ram=512,\n    ram_limit=1024,\n    image_size=100,\n    volumes=[(\"test\", \"test\", 100, False), (\"test2\", \"test\", 100, True)],\n    min_num_containers=3,\n    max_num_containers=5,\n    label=\"Microservice 3\",\n    deamon=False,\n)\n\nns = vNetworkService(\n    microservices=[ms1, ms2, ms3],\n    links=[(ms1, ms2), (ms2, ms3)],\n    entry=ms1,\n    exit=ms3,\n    label=\"Network Service 1\",\n)\n\n\ndef random_process_length():\n    return random.randint(10, 50)\n\n\ndef random_packet_size():\n    return random.randint(100, 65536)\n\n\ndef random_num_packets():\n    return random.randint(5, 10)\n\n\nsfc = vSFC(\n    entry=(ms1, GET),\n    exit=(ms3, POST),\n    path=[(ms1, ms2, GET), (ms2, ms3, GET)],\n    network_service=ns,\n    label=f\"test\",\n)\n\nuser = vUser()\nfor i in range(20):\n    user.request_sfc(sfc, priority=i, retry=True, backoff=lambda: random.random())\n\nhost_monitor = HostMonitor()\nworkflow_monitor = WorkFlowMonitor()\npacket_monitor = PacketMonitor()\nms_monitor = MSMonitor()\nreq_monitor = RequestMonitor()\n\nsimulation.run(10)\n\nhost_monitor.df.to_csv(\"./test_result/host.csv\")\npacket_monitor.df.to_csv(\"./test_result/packet.csv\")\nms_monitor.df.to_csv(\"./test_result/ms.csv\")\nworkflow_monitor.df.to_csv(\"./test_result/workflow.csv\")\nreq_monitor.df.to_csv(\"./test_result/req.csv\")\n</code></pre>"},{"location":"open5gs/","title":"Simulate Open5gs","text":"<pre><code>from PyCloudSim.entity import vMicroserviceDeafult, vHost, vNetworkService, vSFC, vUser\nfrom PyCloudSim.monitor import (\n    HostMonitor,\n    PacketMonitor,\n    MSMonitor,\n    WorkFlowMonitor,\n    RequestMonitor,\n    UserRequestMonitor,\n)\nfrom PyCloudSim.core import simulation\nfrom PyCloudSim.util import *\nimport random\nfrom Akatosh import event\n\ndefault_settings()\ninitiate_topology()\namf = vMicroserviceDeafult(\n    cpu=50,\n    cpu_limit=100,\n    ram=128,\n    ram_limit=256,\n    image_size=100,\n    label=\"AMF\",\n    min_num_containers=1,\n    max_num_containers=1,\n)\n\nausf = vMicroserviceDeafult(\n    label=\"AUSF\",\n    cpu=50,\n    cpu_limit=100,\n    ram=128,\n    ram_limit=256,\n    image_size=100,\n    min_num_containers=1,\n    max_num_containers=1,\n)\n\nudm = vMicroserviceDeafult(\n    label=\"UDM\",\n    cpu=50,\n    cpu_limit=100,\n    ram=128,\n    ram_limit=256,\n    image_size=100,\n    min_num_containers=1,\n    max_num_containers=1,\n)\n\nsmf = vMicroserviceDeafult(\n    label=\"SMF\",\n    cpu=50,\n    cpu_limit=100,\n    ram=128,\n    ram_limit=256,\n    image_size=100,\n    min_num_containers=1,\n    max_num_containers=1,\n)\n\nudr = vMicroserviceDeafult(\n    label=\"UDR\",\n    cpu=50,\n    cpu_limit=100,\n    ram=128,\n    ram_limit=256,\n    image_size=100,\n    min_num_containers=1,\n    max_num_containers=1,\n)\n\n\npcf = vMicroserviceDeafult(\n    label=\"PCF\",\n    cpu=50,\n    cpu_limit=100,\n    ram=128,\n    ram_limit=256,\n    image_size=100,\n    min_num_containers=1,\n    max_num_containers=1,\n)\n\nupf = vMicroserviceDeafult(\n    label=\"UPF\",\n    cpu=50,\n    cpu_limit=100,\n    ram=128,\n    ram_limit=256,\n    image_size=100,\n    min_num_containers=1,\n    max_num_containers=3,\n)\n\nsfc_1 = vSFC(\n    label=\"request_access\",\n    entry=(amf, POST),\n    path=[(amf, ausf, POST)],\n    at=0,\n)\n\nsfc_2 = vSFC(\n    label=\"notice_udm\",\n    path=[(ausf, udm, POST)],\n    internal=True,\n)\n\nsfc_3 = vSFC(\n    label=\"config_pcf\",\n    path=[(udm, udr, POST), (udr, pcf, POST)],\n    internal=True,\n)\n\nsfc_4 = vSFC(\n    label=\"config_smf\",\n    path=[(udm, smf, POST)],\n    internal=True,\n)\n\nsfc_5 = vSFC(\n    label=\"notice_ausf\",\n    path=[(udm, ausf, POST)],\n    internal=True,\n)\n\nsfc_6 = vSFC(\n    label=\"grant_access\",\n    exit=(amf, POST),\n    path=[(ausf, amf, POST)],\n)\n\nsfc_7 = vSFC(\n    label=\"access_internet\",\n    entry=(upf, GET),\n    exit=(upf, POST),\n)\n\nfor i in range(2):\n    vHost(\n        ram=4,\n        rom=1024,\n        ipc=1,\n        frequency=4000,\n        num_cpu_cores=1,\n        at=0,\n        label=f\"Host {i}\",\n    )\n\nfor _ in range(10):\n    user = vUser()\n    flow1 = user.request_sfc(sfc_1)\n    flow2 = user.request_sfc(sfc_2,after=flow1)\n    flow3 = user.request_sfc(sfc_3,after=flow2)\n    flow4 = user.request_sfc(sfc_4,after=flow3)\n    flow5 = user.request_sfc(sfc_5,after=flow4)\n    flow6 = user.request_sfc(sfc_6,after=flow5)\n    flow7 = user.request_sfc(sfc_7,after=flow6, num_packets=100, packet_size=lambda: random.randint(100, 65536))\n\nhost_monitor = HostMonitor()\nworkflow_monitor = WorkFlowMonitor()\npacket_monitor = PacketMonitor()\nms_monitor = MSMonitor()\nreq_monitor = RequestMonitor()\nuser_request_monitor = UserRequestMonitor()\n\nsimulation.run(10)\n\nhost_monitor.df.to_csv(\"./test_result/host.csv\")\npacket_monitor.df.to_csv(\"./test_result/packet.csv\")\nms_monitor.df.to_csv(\"./test_result/ms.csv\")\nworkflow_monitor.df.to_csv(\"./test_result/workflow.csv\")\nreq_monitor.df.to_csv(\"./test_result/req.csv\")\nuser_request_monitor.df.to_csv(\"./test_result/user_req.csv\")\n</code></pre>"},{"location":"api/","title":"Index","text":"<p>The <code>Entity</code> class is the base for all simulated entity.</p> <p>             Bases: <code>ABC</code></p> Source code in <code>PyCloudSim\\entity\\v_entity.py</code> <pre><code>class Entity(ABC):\n    _label: str\n    _created_at: float\n    _started_at: float\n    _terminated_at: float\n    _status: List[str]\n\n    def __init__(\n        self,\n        label: Optional[str] = None,\n        at: Union[int, float, Callable] = simulation.now,\n        after: Optional[Entity | List[Entity]] = None,\n    ):\n        \"\"\"The base class for all simulated entity\n\n        Args:\n            label (Optional[str], optional): short description of the entity. Defaults to None.\n            at (Union[int, float, Callable], optional): when the entity should be created. Defaults to simulation.now.\n            after (Optional[Entity  |  List[Entity]], optional): the entity must be created after. Defaults to None.\n        \"\"\"\n        self._id = uuid4().int\n        self._label = label if label else get_name()\n        self._created_at = float()\n        self._started_at = float()\n        self._terminated_at = float()\n        self._status = list()\n\n        self._on_creation: Callable = lambda: None\n        self._on_termination: Callable = lambda: None\n\n        self._after = None\n        if isinstance(after, list):\n            self._after = [entity.terminator for entity in after]\n        elif after is not None:\n            self._after = after.terminator\n\n        self._creator = Actor(\n            at=at,\n            after=self.after,\n            action=self.creation,\n            label=f\"{self.__class__.__name__} {self.label} creation\",\n            priority=CREATION,\n        )\n\n        self._terminator = Actor(\n            at=inf,\n            action=self.__terminate,\n            label=f\"{self.__class__.__name__} {self.label} termination\",\n            active=False,\n            priority=TERMINATION,\n        )\n\n    @abstractmethod\n    def creation(self):\n        \"\"\"Creatation process of the entity.\"\"\"\n        self._created_at = simulation.now\n        self.status.append(CREATED)\n        LOGGER.info(\n            f\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} is created.\"\n        )\n        self.on_creation()\n\n    @abstractmethod\n    def termination(self):\n        \"\"\"Termination process of the entity.\"\"\"\n        pass\n\n    def __terminate(self):\n        if self.terminated:\n            return\n        LOGGER.info(\n            f\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} is terminated.\"\n        )\n        self._terminated_at = simulation.now\n        self.status.append(TERMINATED)\n        self.termination()\n        self.on_termination()\n\n    def terminate(self):\n        \"\"\"Terminate the entity.\"\"\"\n        if not self.created:\n            raise RuntimeError(\n                f\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} is not created yet.\"\n            )\n        self.terminator.activate()\n\n    @property\n    def id(self) -&gt; int:\n        \"\"\"The id of the entity.\"\"\"\n        return self._id\n\n    @property\n    def label(self) -&gt; str:\n        \"\"\"The label of the entity.\"\"\"\n        return self._label\n\n    @property\n    def created_at(self) -&gt; float:\n        \"\"\"The time when the entity is created.\"\"\"\n        return self._created_at\n\n    @property\n    def started_at(self) -&gt; float:\n        \"\"\"The time when the entity is started.\"\"\"\n        return self._started_at\n\n    @property\n    def terminated_at(self) -&gt; float:\n        \"\"\"The time when the entity is terminated.\"\"\"\n        return self._terminated_at\n\n    @property\n    def status(self) -&gt; List[str]:\n        \"\"\"The status of the entity.\"\"\"\n        return self._status\n\n    @property\n    def created(self) -&gt; bool:\n        \"\"\"Return True if the entity is created.\"\"\"\n        return CREATED in self._status\n\n    @property\n    def started(self) -&gt; bool:\n        \"\"\"Return True if the entity is started.\"\"\"\n        return STARTED in self._status\n\n    @property\n    def terminated(self) -&gt; bool:\n        \"\"\"Return True if the entity is terminated.\"\"\"\n        return TERMINATED in self._status\n\n    @property\n    def creator(self) -&gt; Actor:\n        \"\"\"The creator of the entity.\"\"\"\n        return self._creator\n\n    @property\n    def terminator(self) -&gt; Actor:\n        \"\"\"The terminator of the entity.\"\"\"\n        return self._terminator\n\n    @property\n    def after(self) -&gt; Actor | List[Actor] | None:\n        \"\"\"The other enity that this entity must be created after.\"\"\"\n        return self._after\n\n    @property\n    def on_creation(self) -&gt; Callable:\n        \"\"\"Callback function on creation process\"\"\"\n        return self._on_creation\n\n    @on_creation.setter\n    def on_creation(self, func: Callable):\n        self._on_creation = func\n\n    @property\n    def on_termination(self) -&gt; Callable:\n        \"\"\"Callback function on termination process\"\"\"\n        return self._on_termination\n\n    @on_termination.setter\n    def on_termination(self, func: Callable):\n        self._on_termination = func\n</code></pre>"},{"location":"api/#PyCloudSim.entity.v_entity.Entity.after","title":"<code>after: Actor | List[Actor] | None</code>  <code>property</code>","text":"<p>The other enity that this entity must be created after.</p>"},{"location":"api/#PyCloudSim.entity.v_entity.Entity.created","title":"<code>created: bool</code>  <code>property</code>","text":"<p>Return True if the entity is created.</p>"},{"location":"api/#PyCloudSim.entity.v_entity.Entity.created_at","title":"<code>created_at: float</code>  <code>property</code>","text":"<p>The time when the entity is created.</p>"},{"location":"api/#PyCloudSim.entity.v_entity.Entity.creator","title":"<code>creator: Actor</code>  <code>property</code>","text":"<p>The creator of the entity.</p>"},{"location":"api/#PyCloudSim.entity.v_entity.Entity.id","title":"<code>id: int</code>  <code>property</code>","text":"<p>The id of the entity.</p>"},{"location":"api/#PyCloudSim.entity.v_entity.Entity.label","title":"<code>label: str</code>  <code>property</code>","text":"<p>The label of the entity.</p>"},{"location":"api/#PyCloudSim.entity.v_entity.Entity.on_creation","title":"<code>on_creation: Callable</code>  <code>property</code> <code>writable</code>","text":"<p>Callback function on creation process</p>"},{"location":"api/#PyCloudSim.entity.v_entity.Entity.on_termination","title":"<code>on_termination: Callable</code>  <code>property</code> <code>writable</code>","text":"<p>Callback function on termination process</p>"},{"location":"api/#PyCloudSim.entity.v_entity.Entity.started","title":"<code>started: bool</code>  <code>property</code>","text":"<p>Return True if the entity is started.</p>"},{"location":"api/#PyCloudSim.entity.v_entity.Entity.started_at","title":"<code>started_at: float</code>  <code>property</code>","text":"<p>The time when the entity is started.</p>"},{"location":"api/#PyCloudSim.entity.v_entity.Entity.status","title":"<code>status: List[str]</code>  <code>property</code>","text":"<p>The status of the entity.</p>"},{"location":"api/#PyCloudSim.entity.v_entity.Entity.terminated","title":"<code>terminated: bool</code>  <code>property</code>","text":"<p>Return True if the entity is terminated.</p>"},{"location":"api/#PyCloudSim.entity.v_entity.Entity.terminated_at","title":"<code>terminated_at: float</code>  <code>property</code>","text":"<p>The time when the entity is terminated.</p>"},{"location":"api/#PyCloudSim.entity.v_entity.Entity.terminator","title":"<code>terminator: Actor</code>  <code>property</code>","text":"<p>The terminator of the entity.</p>"},{"location":"api/#PyCloudSim.entity.v_entity.Entity.__init__","title":"<code>__init__(label=None, at=simulation.now, after=None)</code>","text":"<p>The base class for all simulated entity</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>Optional[str]</code> <p>short description of the entity. Defaults to None.</p> <code>None</code> <code>at</code> <code>Union[int, float, Callable]</code> <p>when the entity should be created. Defaults to simulation.now.</p> <code>now</code> <code>after</code> <code>Optional[Entity | List[Entity]]</code> <p>the entity must be created after. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_entity.py</code> <pre><code>def __init__(\n    self,\n    label: Optional[str] = None,\n    at: Union[int, float, Callable] = simulation.now,\n    after: Optional[Entity | List[Entity]] = None,\n):\n    \"\"\"The base class for all simulated entity\n\n    Args:\n        label (Optional[str], optional): short description of the entity. Defaults to None.\n        at (Union[int, float, Callable], optional): when the entity should be created. Defaults to simulation.now.\n        after (Optional[Entity  |  List[Entity]], optional): the entity must be created after. Defaults to None.\n    \"\"\"\n    self._id = uuid4().int\n    self._label = label if label else get_name()\n    self._created_at = float()\n    self._started_at = float()\n    self._terminated_at = float()\n    self._status = list()\n\n    self._on_creation: Callable = lambda: None\n    self._on_termination: Callable = lambda: None\n\n    self._after = None\n    if isinstance(after, list):\n        self._after = [entity.terminator for entity in after]\n    elif after is not None:\n        self._after = after.terminator\n\n    self._creator = Actor(\n        at=at,\n        after=self.after,\n        action=self.creation,\n        label=f\"{self.__class__.__name__} {self.label} creation\",\n        priority=CREATION,\n    )\n\n    self._terminator = Actor(\n        at=inf,\n        action=self.__terminate,\n        label=f\"{self.__class__.__name__} {self.label} termination\",\n        active=False,\n        priority=TERMINATION,\n    )\n</code></pre>"},{"location":"api/#PyCloudSim.entity.v_entity.Entity.creation","title":"<code>creation()</code>  <code>abstractmethod</code>","text":"<p>Creatation process of the entity.</p> Source code in <code>PyCloudSim\\entity\\v_entity.py</code> <pre><code>@abstractmethod\ndef creation(self):\n    \"\"\"Creatation process of the entity.\"\"\"\n    self._created_at = simulation.now\n    self.status.append(CREATED)\n    LOGGER.info(\n        f\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} is created.\"\n    )\n    self.on_creation()\n</code></pre>"},{"location":"api/#PyCloudSim.entity.v_entity.Entity.terminate","title":"<code>terminate()</code>","text":"<p>Terminate the entity.</p> Source code in <code>PyCloudSim\\entity\\v_entity.py</code> <pre><code>def terminate(self):\n    \"\"\"Terminate the entity.\"\"\"\n    if not self.created:\n        raise RuntimeError(\n            f\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} is not created yet.\"\n        )\n    self.terminator.activate()\n</code></pre>"},{"location":"api/#PyCloudSim.entity.v_entity.Entity.termination","title":"<code>termination()</code>  <code>abstractmethod</code>","text":"<p>Termination process of the entity.</p> Source code in <code>PyCloudSim\\entity\\v_entity.py</code> <pre><code>@abstractmethod\ndef termination(self):\n    \"\"\"Termination process of the entity.\"\"\"\n    pass\n</code></pre>"},{"location":"api/monitor/host_monitor/","title":"Host Monitor","text":"<p>This class collects CPU, RAM, ROM, and bandwidth usage metrics at a predefined interval for each \"vHost\" in the simulation. It enables you to monitor the resource utilization of individual hosts over time.</p>"},{"location":"api/monitor/host_monitor/#PyCloudSim.monitor.host_monitor.HostMonitor","title":"<code>HostMonitor</code>","text":"Source code in <code>PyCloudSim\\monitor\\host_monitor.py</code> <pre><code>class HostMonitor:\n    _monitored_hosts: Union[PhysicalEntity, List[PhysicalEntity]]\n    _df: pd.DataFrame\n\n    def __init__(\n        self,\n        monitored_host: Optional[PhysicalEntity | List[PhysicalEntity]] = None,\n        monitor_interval: Union[int, float] = 0.01,\n    ) -&gt; None:\n        \"\"\"Host monitor.\n\n        Args:\n            monitored_host (Optional[PhysicalEntity  |  List[PhysicalEntity]], optional): if none, all simulated physical entity will be monitored. Defaults to None.\n            monitor_interval (Union[int, float], optional): the sampling interval. Defaults to 0.01.\n        \"\"\"        \n        if monitored_host is None:\n            self._monitored_hosts = []\n            self._monitored_hosts.extend(simulation.HOSTS)\n            self._monitored_hosts.extend(simulation.SWITCHES)\n            self._monitored_hosts.extend(simulation.ROUTERS)\n        else:\n            self._monitored_hosts = monitored_host\n        self._monitor_interval = monitor_interval\n\n        self._df = pd.DataFrame(\n            {\n                \"host_id\": pd.Series(dtype=\"str\"),\n                \"host_label\": pd.Series(dtype=\"str\"),\n                \"time\": pd.Series(dtype=\"float\"),\n                \"cpu_util\": pd.Series(dtype=\"float\"),\n                \"ram_util\": pd.Series(dtype=\"float\"),\n                \"rom_util\": pd.Series(dtype=\"float\"),\n                \"bw_in_util\": pd.Series(dtype=\"float\"),\n                \"bw_out_util\": pd.Series(dtype=\"float\"),\n                \"num_containers\": pd.Series(dtype=\"int\"),\n                \"num_processes\": pd.Series(dtype=\"int\"),\n                \"power_usage\": pd.Series(dtype=\"float\"),\n            }\n        )\n\n        self._process = Actor(\n            at=0,\n            step=self.monitor_interval,\n            action=self.action,\n            priority=MONITOR_PRIORITY,\n            label=\"Host Monitor\",\n        )\n\n    def action(self):\n        \"\"\"Telemetries collection.\n        \"\"\"\n        if isinstance(self._monitored_hosts, list):\n            for host in self._monitored_hosts:\n                if host.created:\n                    host_telemetry = pd.DataFrame(\n                        {\n                            \"host_id\": str(host.id),\n                            \"host_label\": host.label,\n                            \"time\": float(simulation.now),\n                            \"cpu_util\": host.cpu.utilization_in_past(\n                                self.monitor_interval\n                            ),\n                            \"ram_util\": host.ram.utilization_in_past(\n                                self.monitor_interval\n                            ),\n                            \"rom_util\": host.rom.utilization_in_past(\n                                self.monitor_interval\n                            ),\n                            \"bw_in_util\": host.uplink_utilization(\n                                self.monitor_interval\n                            ),\n                            \"bw_out_util\": host.downlink_utilization(\n                                self.monitor_interval\n                            ),\n                            \"num_containers\": len(host.containers)\n                            if type(host) == vHost\n                            else 0,\n                            \"num_processes\": len(host.processes),\n                            \"power_usage\": host.power_usage(self.monitor_interval),\n                        },\n                        index=[0],\n                    )\n                    self._df = pd.concat([self._df, host_telemetry], ignore_index=True)\n        elif isinstance(self.monitored_hosts, vHost):\n            if self.monitored_hosts.created:\n                host_telemetry = pd.DataFrame(\n                    {\n                        \"host_id\": str(self.monitored_hosts.id),\n                        \"host_label\": self.monitored_hosts.label,\n                        \"time\": float(simulation.now),\n                        \"cpu_util\": self.monitored_hosts.cpu.utilization_in_past(\n                            self.monitor_interval\n                        ),\n                        \"ram_util\": self.monitored_hosts.ram.utilization_in_past(\n                            self.monitor_interval\n                        ),\n                        \"rom_util\": self.monitored_hosts.rom.utilization_in_past(\n                            self.monitor_interval\n                        ),\n                        \"bw_in_util\": self.monitored_hosts.uplink_utilization(\n                            self.monitor_interval\n                        ),\n                        \"bw_out_util\": self.monitored_hosts.downlink_utilization(\n                            self.monitor_interval\n                        ),\n                        \"num_containers\": len(self.monitored_hosts.containers)\n                        if type(self.monitored_hosts) == vHost\n                        else 0,\n                        \"num_processes\": len(self.monitored_hosts.processes),\n                        \"power_usage\": self.monitored_hosts.power_usage(\n                            self.monitor_interval\n                        ),\n                    },\n                    index=[0],\n                )\n                self._df = pd.concat([self._df, host_telemetry], ignore_index=True)\n\n    @property\n    def df(self):\n        \"\"\"The pandas dataframe containing the telemetry data.\"\"\"\n        return self._df\n\n    @property\n    def monitored_hosts(self):\n        \"\"\"The monitored hosts.\"\"\"\n        return self._monitored_hosts\n\n    @property\n    def monitor_interval(self) -&gt; Union[int, float]:\n        \"\"\"The sampling interval.\"\"\"\n        return self._monitor_interval\n</code></pre>"},{"location":"api/monitor/host_monitor/#PyCloudSim.monitor.host_monitor.HostMonitor.df","title":"<code>df</code>  <code>property</code>","text":"<p>The pandas dataframe containing the telemetry data.</p>"},{"location":"api/monitor/host_monitor/#PyCloudSim.monitor.host_monitor.HostMonitor.monitor_interval","title":"<code>monitor_interval: Union[int, float]</code>  <code>property</code>","text":"<p>The sampling interval.</p>"},{"location":"api/monitor/host_monitor/#PyCloudSim.monitor.host_monitor.HostMonitor.monitored_hosts","title":"<code>monitored_hosts</code>  <code>property</code>","text":"<p>The monitored hosts.</p>"},{"location":"api/monitor/host_monitor/#PyCloudSim.monitor.host_monitor.HostMonitor.__init__","title":"<code>__init__(monitored_host=None, monitor_interval=0.01)</code>","text":"<p>Host monitor.</p> <p>Parameters:</p> Name Type Description Default <code>monitored_host</code> <code>Optional[PhysicalEntity | List[PhysicalEntity]]</code> <p>if none, all simulated physical entity will be monitored. Defaults to None.</p> <code>None</code> <code>monitor_interval</code> <code>Union[int, float]</code> <p>the sampling interval. Defaults to 0.01.</p> <code>0.01</code> Source code in <code>PyCloudSim\\monitor\\host_monitor.py</code> <pre><code>def __init__(\n    self,\n    monitored_host: Optional[PhysicalEntity | List[PhysicalEntity]] = None,\n    monitor_interval: Union[int, float] = 0.01,\n) -&gt; None:\n    \"\"\"Host monitor.\n\n    Args:\n        monitored_host (Optional[PhysicalEntity  |  List[PhysicalEntity]], optional): if none, all simulated physical entity will be monitored. Defaults to None.\n        monitor_interval (Union[int, float], optional): the sampling interval. Defaults to 0.01.\n    \"\"\"        \n    if monitored_host is None:\n        self._monitored_hosts = []\n        self._monitored_hosts.extend(simulation.HOSTS)\n        self._monitored_hosts.extend(simulation.SWITCHES)\n        self._monitored_hosts.extend(simulation.ROUTERS)\n    else:\n        self._monitored_hosts = monitored_host\n    self._monitor_interval = monitor_interval\n\n    self._df = pd.DataFrame(\n        {\n            \"host_id\": pd.Series(dtype=\"str\"),\n            \"host_label\": pd.Series(dtype=\"str\"),\n            \"time\": pd.Series(dtype=\"float\"),\n            \"cpu_util\": pd.Series(dtype=\"float\"),\n            \"ram_util\": pd.Series(dtype=\"float\"),\n            \"rom_util\": pd.Series(dtype=\"float\"),\n            \"bw_in_util\": pd.Series(dtype=\"float\"),\n            \"bw_out_util\": pd.Series(dtype=\"float\"),\n            \"num_containers\": pd.Series(dtype=\"int\"),\n            \"num_processes\": pd.Series(dtype=\"int\"),\n            \"power_usage\": pd.Series(dtype=\"float\"),\n        }\n    )\n\n    self._process = Actor(\n        at=0,\n        step=self.monitor_interval,\n        action=self.action,\n        priority=MONITOR_PRIORITY,\n        label=\"Host Monitor\",\n    )\n</code></pre>"},{"location":"api/monitor/host_monitor/#PyCloudSim.monitor.host_monitor.HostMonitor.action","title":"<code>action()</code>","text":"<p>Telemetries collection.</p> Source code in <code>PyCloudSim\\monitor\\host_monitor.py</code> <pre><code>def action(self):\n    \"\"\"Telemetries collection.\n    \"\"\"\n    if isinstance(self._monitored_hosts, list):\n        for host in self._monitored_hosts:\n            if host.created:\n                host_telemetry = pd.DataFrame(\n                    {\n                        \"host_id\": str(host.id),\n                        \"host_label\": host.label,\n                        \"time\": float(simulation.now),\n                        \"cpu_util\": host.cpu.utilization_in_past(\n                            self.monitor_interval\n                        ),\n                        \"ram_util\": host.ram.utilization_in_past(\n                            self.monitor_interval\n                        ),\n                        \"rom_util\": host.rom.utilization_in_past(\n                            self.monitor_interval\n                        ),\n                        \"bw_in_util\": host.uplink_utilization(\n                            self.monitor_interval\n                        ),\n                        \"bw_out_util\": host.downlink_utilization(\n                            self.monitor_interval\n                        ),\n                        \"num_containers\": len(host.containers)\n                        if type(host) == vHost\n                        else 0,\n                        \"num_processes\": len(host.processes),\n                        \"power_usage\": host.power_usage(self.monitor_interval),\n                    },\n                    index=[0],\n                )\n                self._df = pd.concat([self._df, host_telemetry], ignore_index=True)\n    elif isinstance(self.monitored_hosts, vHost):\n        if self.monitored_hosts.created:\n            host_telemetry = pd.DataFrame(\n                {\n                    \"host_id\": str(self.monitored_hosts.id),\n                    \"host_label\": self.monitored_hosts.label,\n                    \"time\": float(simulation.now),\n                    \"cpu_util\": self.monitored_hosts.cpu.utilization_in_past(\n                        self.monitor_interval\n                    ),\n                    \"ram_util\": self.monitored_hosts.ram.utilization_in_past(\n                        self.monitor_interval\n                    ),\n                    \"rom_util\": self.monitored_hosts.rom.utilization_in_past(\n                        self.monitor_interval\n                    ),\n                    \"bw_in_util\": self.monitored_hosts.uplink_utilization(\n                        self.monitor_interval\n                    ),\n                    \"bw_out_util\": self.monitored_hosts.downlink_utilization(\n                        self.monitor_interval\n                    ),\n                    \"num_containers\": len(self.monitored_hosts.containers)\n                    if type(self.monitored_hosts) == vHost\n                    else 0,\n                    \"num_processes\": len(self.monitored_hosts.processes),\n                    \"power_usage\": self.monitored_hosts.power_usage(\n                        self.monitor_interval\n                    ),\n                },\n                index=[0],\n            )\n            self._df = pd.concat([self._df, host_telemetry], ignore_index=True)\n</code></pre>"},{"location":"api/monitor/microservice_monitor/","title":"Microservice Monitor","text":"<p>The MicroserviceMonitor class collects CPU, RAM, and bandwidth usage metrics at a predefined interval for each \"vMicroservice\" in the simulation. It allows you to track the resource consumption of microservices and analyze their performance.</p>"},{"location":"api/monitor/microservice_monitor/#PyCloudSim.monitor.ms_monitor.MSMonitor","title":"<code>MSMonitor</code>","text":"Source code in <code>PyCloudSim\\monitor\\ms_monitor.py</code> <pre><code>class MSMonitor:\n    _monitored_ms: Union[vMicroservice, List[vMicroservice]]\n    _df: pd.DataFrame\n\n    def __init__(\n        self,\n        monitored_host: Optional[vMicroservice | List[vMicroservice]] = None,\n        monitor_interval: Union[int, float] = 0.01,\n    ) -&gt; None:\n        \"\"\"vMicroservice Monitor.\n\n        Args:\n            monitored_host (Optional[vMicroservice  |  List[vMicroservice]], optional): if one, all microservices will be monitored. Defaults to None.\n            monitor_interval (Union[int, float], optional): the sampling interval. Defaults to 0.01.\n        \"\"\"        \n        if monitored_host is None:\n            self._monitored_ms = simulation.MICROSERVICES\n        else:\n            self._monitored_ms = monitored_host\n        self._monitor_interval = monitor_interval\n\n        self._df = pd.DataFrame(\n            {\n                \"ms\": pd.Series(dtype=\"str\"),\n                \"ms_id\": pd.Series(dtype=\"str\"),\n                \"time\": pd.Series(dtype=\"float\"),\n                \"cpu_util\": pd.Series(dtype=\"float\"),\n                \"ram_util\": pd.Series(dtype=\"float\"),\n                \"num_containers\": pd.Series(dtype=\"int\"),\n                \"num_scheduled_containers\": pd.Series(dtype=\"int\"),\n                \"num_non_scheduled_containers\": pd.Series(dtype=\"int\"),\n            }\n        )\n\n        self._process = Actor(\n            at=0,\n            step=self.monitor_interval,\n            action=self.action,\n            priority=MONITOR_PRIORITY,\n            label=\"Host Monitor\",\n        )\n\n    def action(self):\n        \"\"\"Telemetries collection.\"\"\"\n        if isinstance(self._monitored_ms, list):\n            for ms in self._monitored_ms:\n                if not ms.terminated:\n                    host_telemetry = pd.DataFrame(\n                        {\n                            \"ms\": ms.label,\n                            \"ms_id\": str(ms.id),\n                            \"time\": float(simulation.now),\n                            \"cpu_util\": ms.cpu_usage_in_past(self.monitor_interval),\n                            \"ram_util\": ms.ram_usage_in_past(self.monitor_interval),\n                            \"num_containers\": len(ms.containers),\n                            \"num_scheduled_containers\": len(\n                                [\n                                    container\n                                    for container in ms.containers\n                                    if container.scheduled\n                                ]\n                            ),\n                            \"num_non_scheduled_containers\": len(\n                                [\n                                    container\n                                    for container in ms.containers\n                                    if not container.scheduled\n                                ]\n                            ),\n                        },\n                        index=[0],\n                    )\n                    self._df = pd.concat([self._df, host_telemetry], ignore_index=True)\n        elif isinstance(self.monitored_ms, vMicroservice):\n            host_telemetry = pd.DataFrame(\n                {\n                    \"ms\": self.monitored_ms.label,\n                    \"ms_id\": str(self.monitored_ms.id),\n                    \"time\": float(simulation.now),\n                    \"cpu_util\": self.monitored_ms.cpu_usage_in_past(self.monitor_interval),\n                    \"ram_util\": self.monitored_ms.cpu_usage_in_past(self.monitor_interval),\n                    \"num_containers\": len(self.monitored_ms.containers),\n                    \"num_scheduled_containers\": len(\n                        [\n                            container\n                            for container in self.monitored_ms.containers\n                            if container.scheduled\n                        ]\n                    ),\n                    \"num_non_scheduled_containers\": len(\n                        [\n                            container\n                            for container in self.monitored_ms.containers\n                            if not container.scheduled\n                        ]\n                    ),\n                },\n                index=[0],\n            )\n            self._df = pd.concat([self._df, host_telemetry], ignore_index=True)\n\n    @property\n    def df(self):\n        \"\"\"The pandas dataframe of the host monitor.\"\"\"\n        return self._df\n\n    @property\n    def monitored_ms(self) -&gt; Union[vMicroservice, List[vMicroservice]]:\n        \"\"\"The monitored microservices.\"\"\"\n        return self._monitored_ms\n\n    @property\n    def monitor_interval(self) -&gt; Union[int, float]:\n        \"\"\"The sampling interval.\"\"\"\n        return self._monitor_interval\n</code></pre>"},{"location":"api/monitor/microservice_monitor/#PyCloudSim.monitor.ms_monitor.MSMonitor.df","title":"<code>df</code>  <code>property</code>","text":"<p>The pandas dataframe of the host monitor.</p>"},{"location":"api/monitor/microservice_monitor/#PyCloudSim.monitor.ms_monitor.MSMonitor.monitor_interval","title":"<code>monitor_interval: Union[int, float]</code>  <code>property</code>","text":"<p>The sampling interval.</p>"},{"location":"api/monitor/microservice_monitor/#PyCloudSim.monitor.ms_monitor.MSMonitor.monitored_ms","title":"<code>monitored_ms: Union[vMicroservice, List[vMicroservice]]</code>  <code>property</code>","text":"<p>The monitored microservices.</p>"},{"location":"api/monitor/microservice_monitor/#PyCloudSim.monitor.ms_monitor.MSMonitor.__init__","title":"<code>__init__(monitored_host=None, monitor_interval=0.01)</code>","text":"<p>vMicroservice Monitor.</p> <p>Parameters:</p> Name Type Description Default <code>monitored_host</code> <code>Optional[vMicroservice | List[vMicroservice]]</code> <p>if one, all microservices will be monitored. Defaults to None.</p> <code>None</code> <code>monitor_interval</code> <code>Union[int, float]</code> <p>the sampling interval. Defaults to 0.01.</p> <code>0.01</code> Source code in <code>PyCloudSim\\monitor\\ms_monitor.py</code> <pre><code>def __init__(\n    self,\n    monitored_host: Optional[vMicroservice | List[vMicroservice]] = None,\n    monitor_interval: Union[int, float] = 0.01,\n) -&gt; None:\n    \"\"\"vMicroservice Monitor.\n\n    Args:\n        monitored_host (Optional[vMicroservice  |  List[vMicroservice]], optional): if one, all microservices will be monitored. Defaults to None.\n        monitor_interval (Union[int, float], optional): the sampling interval. Defaults to 0.01.\n    \"\"\"        \n    if monitored_host is None:\n        self._monitored_ms = simulation.MICROSERVICES\n    else:\n        self._monitored_ms = monitored_host\n    self._monitor_interval = monitor_interval\n\n    self._df = pd.DataFrame(\n        {\n            \"ms\": pd.Series(dtype=\"str\"),\n            \"ms_id\": pd.Series(dtype=\"str\"),\n            \"time\": pd.Series(dtype=\"float\"),\n            \"cpu_util\": pd.Series(dtype=\"float\"),\n            \"ram_util\": pd.Series(dtype=\"float\"),\n            \"num_containers\": pd.Series(dtype=\"int\"),\n            \"num_scheduled_containers\": pd.Series(dtype=\"int\"),\n            \"num_non_scheduled_containers\": pd.Series(dtype=\"int\"),\n        }\n    )\n\n    self._process = Actor(\n        at=0,\n        step=self.monitor_interval,\n        action=self.action,\n        priority=MONITOR_PRIORITY,\n        label=\"Host Monitor\",\n    )\n</code></pre>"},{"location":"api/monitor/microservice_monitor/#PyCloudSim.monitor.ms_monitor.MSMonitor.action","title":"<code>action()</code>","text":"<p>Telemetries collection.</p> Source code in <code>PyCloudSim\\monitor\\ms_monitor.py</code> <pre><code>def action(self):\n    \"\"\"Telemetries collection.\"\"\"\n    if isinstance(self._monitored_ms, list):\n        for ms in self._monitored_ms:\n            if not ms.terminated:\n                host_telemetry = pd.DataFrame(\n                    {\n                        \"ms\": ms.label,\n                        \"ms_id\": str(ms.id),\n                        \"time\": float(simulation.now),\n                        \"cpu_util\": ms.cpu_usage_in_past(self.monitor_interval),\n                        \"ram_util\": ms.ram_usage_in_past(self.monitor_interval),\n                        \"num_containers\": len(ms.containers),\n                        \"num_scheduled_containers\": len(\n                            [\n                                container\n                                for container in ms.containers\n                                if container.scheduled\n                            ]\n                        ),\n                        \"num_non_scheduled_containers\": len(\n                            [\n                                container\n                                for container in ms.containers\n                                if not container.scheduled\n                            ]\n                        ),\n                    },\n                    index=[0],\n                )\n                self._df = pd.concat([self._df, host_telemetry], ignore_index=True)\n    elif isinstance(self.monitored_ms, vMicroservice):\n        host_telemetry = pd.DataFrame(\n            {\n                \"ms\": self.monitored_ms.label,\n                \"ms_id\": str(self.monitored_ms.id),\n                \"time\": float(simulation.now),\n                \"cpu_util\": self.monitored_ms.cpu_usage_in_past(self.monitor_interval),\n                \"ram_util\": self.monitored_ms.cpu_usage_in_past(self.monitor_interval),\n                \"num_containers\": len(self.monitored_ms.containers),\n                \"num_scheduled_containers\": len(\n                    [\n                        container\n                        for container in self.monitored_ms.containers\n                        if container.scheduled\n                    ]\n                ),\n                \"num_non_scheduled_containers\": len(\n                    [\n                        container\n                        for container in self.monitored_ms.containers\n                        if not container.scheduled\n                    ]\n                ),\n            },\n            index=[0],\n        )\n        self._df = pd.concat([self._df, host_telemetry], ignore_index=True)\n</code></pre>"},{"location":"api/monitor/request_monitor/","title":"Request Monitor","text":"<p>The RequestMonitor class collects creation time, scheduled time, termination time, and retry count information for each \"vRequest\" in the simulation. It allows you to track the lifecycle of requests, including their scheduling, execution, and potential retries.</p>"},{"location":"api/monitor/request_monitor/#PyCloudSim.monitor.request_monitor.RequestMonitor","title":"<code>RequestMonitor</code>","text":"<p>Request Monitor.</p> Source code in <code>PyCloudSim\\monitor\\request_monitor.py</code> <pre><code>class RequestMonitor:\n    \"\"\"Request Monitor.\"\"\"\n    _df: pd.DataFrame\n\n    def __init__(\n        self,\n    ) -&gt; None:\n        self._df = pd.DataFrame(\n            {\n                \"request_id\": pd.Series(dtype=\"str\"),\n                \"request_label\": pd.Series(dtype=\"str\"),\n                \"user_id\": pd.Series(dtype=\"str\"),\n                \"user_label\": pd.Series(dtype=\"str\"),\n                \"created_at\": pd.Series(dtype=\"float\"),\n                \"scheduled_at\": pd.Series(dtype=\"float\"),\n                \"terminated_at\": pd.Series(dtype=\"float\"),\n                \"successful\": pd.Series(dtype=\"bool\"),\n            }\n        )\n\n        simulation._request_monitor = self\n\n    def collect(self):\n        for request in simulation.REQUESTS:\n            request_info = pd.DataFrame(\n                {\n                    \"request_id\": request.id,\n                    \"request_label\": request.label,\n                    \"user_id\": request.user.id if request.user else None,\n                    \"user_label\": request.user.label if request.user else None,\n                    \"created_at\": request.created_at,\n                    \"scheduled_at\": request.scheduled_at,\n                    \"terminated_at\": request.terminated_at,\n                    \"successful\": request.completed,\n                },\n                index=[0],\n            )\n            self._df = pd.concat([self._df, request_info], ignore_index=True)\n\n    @property\n    def df(self) -&gt; pd.DataFrame:\n        return self._df\n</code></pre>"},{"location":"api/physical_component/","title":"Index","text":"<p>The <code>PhysicalComponent</code> class is the base class for vCPU, vCPUCore and vNIC</p> <p>             Bases: <code>Entity</code>, <code>ABC</code></p> Source code in <code>PyCloudSim\\entity\\v_physical_component.py</code> <pre><code>class PhysicalComponent(Entity, ABC):\n    _privisoned_at: float\n\n    def __init__(\n        self,\n        at: Union[int, float, Callable] = simulation.now,\n        after: Optional[Entity | List[Entity]] = None,\n        label: Optional[str] = None,\n    ):\n        \"\"\"Create a physical component.\n\n        Args:\n            at (Union[int, float, Callable], optional): same as entity. Defaults to simulation.now.\n            after (Optional[Entity  |  List[Entity]], optional): same as entity. Defaults to None.\n            label (Optional[str], optional): same as entity. Defaults to None.\n        \"\"\"\n        super().__init__(at=at, after=after, label=label)\n        simulation.topology.add_node(self)\n\n    @abstractmethod\n    def _power_on(self):\n        \"\"\"Power on the physical component.\"\"\"\n        if self.powered_off:\n            self.status.append(POWERED_ON)\n            self.on_power_on()\n            LOGGER.info(\n                f\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} is powered on.\"\n            )\n\n    def power_on(self):\n        \"\"\"Power on the physical component.\"\"\"\n        if self.powered_off:\n            Actor(\n                at=simulation.now,\n                action=self._power_on,\n                label=f\"{self.__class__.__name__} {self.label} Power On.\",\n                priority=POWERING,\n            )\n\n    def on_power_on(self):\n        \"\"\"Callback function for when the physical component is powered on.\"\"\"\n        pass\n\n    @abstractmethod\n    def _power_off(self):\n        \"\"\"Power off the physical component.\"\"\"\n        if self.powered_on:\n            self.status.remove(POWERED_ON)\n            self.status.append(POWERED_OFF)\n            self.on_power_off()\n            LOGGER.info(\n                f\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} is powered off.\"\n            )\n\n    def power_off(self):\n        \"\"\"Power off the physical component.\"\"\"\n        if self.powered_on:\n            Actor(\n                at=simulation.now,\n                action=self._power_off,\n                label=f\"{self.__class__.__name__} {self.label} Power Off.\",\n                priority=POWERING,\n            )\n\n    def on_power_off(self):\n        \"\"\"Callback function for when the physical component is powered off.\"\"\"\n        pass\n\n    @property\n    def powered_on(self) -&gt; bool:\n        \"\"\"returns True if the physical component is powered on, False otherwise.\"\"\"\n        return POWERED_ON in self._status\n\n    @property\n    def powered_off(self) -&gt; bool:\n        \"\"\"returns True if the physical component is powered off, False otherwise.\"\"\"\n        return POWERED_ON not in self._status\n</code></pre>"},{"location":"api/physical_component/#PyCloudSim.entity.v_physical_component.PhysicalComponent.powered_off","title":"<code>powered_off: bool</code>  <code>property</code>","text":"<p>returns True if the physical component is powered off, False otherwise.</p>"},{"location":"api/physical_component/#PyCloudSim.entity.v_physical_component.PhysicalComponent.powered_on","title":"<code>powered_on: bool</code>  <code>property</code>","text":"<p>returns True if the physical component is powered on, False otherwise.</p>"},{"location":"api/physical_component/#PyCloudSim.entity.v_physical_component.PhysicalComponent.__init__","title":"<code>__init__(at=simulation.now, after=None, label=None)</code>","text":"<p>Create a physical component.</p> <p>Parameters:</p> Name Type Description Default <code>at</code> <code>Union[int, float, Callable]</code> <p>same as entity. Defaults to simulation.now.</p> <code>now</code> <code>after</code> <code>Optional[Entity | List[Entity]]</code> <p>same as entity. Defaults to None.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>same as entity. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_physical_component.py</code> <pre><code>def __init__(\n    self,\n    at: Union[int, float, Callable] = simulation.now,\n    after: Optional[Entity | List[Entity]] = None,\n    label: Optional[str] = None,\n):\n    \"\"\"Create a physical component.\n\n    Args:\n        at (Union[int, float, Callable], optional): same as entity. Defaults to simulation.now.\n        after (Optional[Entity  |  List[Entity]], optional): same as entity. Defaults to None.\n        label (Optional[str], optional): same as entity. Defaults to None.\n    \"\"\"\n    super().__init__(at=at, after=after, label=label)\n    simulation.topology.add_node(self)\n</code></pre>"},{"location":"api/physical_component/#PyCloudSim.entity.v_physical_component.PhysicalComponent.on_power_off","title":"<code>on_power_off()</code>","text":"<p>Callback function for when the physical component is powered off.</p> Source code in <code>PyCloudSim\\entity\\v_physical_component.py</code> <pre><code>def on_power_off(self):\n    \"\"\"Callback function for when the physical component is powered off.\"\"\"\n    pass\n</code></pre>"},{"location":"api/physical_component/#PyCloudSim.entity.v_physical_component.PhysicalComponent.on_power_on","title":"<code>on_power_on()</code>","text":"<p>Callback function for when the physical component is powered on.</p> Source code in <code>PyCloudSim\\entity\\v_physical_component.py</code> <pre><code>def on_power_on(self):\n    \"\"\"Callback function for when the physical component is powered on.\"\"\"\n    pass\n</code></pre>"},{"location":"api/physical_component/#PyCloudSim.entity.v_physical_component.PhysicalComponent.power_off","title":"<code>power_off()</code>","text":"<p>Power off the physical component.</p> Source code in <code>PyCloudSim\\entity\\v_physical_component.py</code> <pre><code>def power_off(self):\n    \"\"\"Power off the physical component.\"\"\"\n    if self.powered_on:\n        Actor(\n            at=simulation.now,\n            action=self._power_off,\n            label=f\"{self.__class__.__name__} {self.label} Power Off.\",\n            priority=POWERING,\n        )\n</code></pre>"},{"location":"api/physical_component/#PyCloudSim.entity.v_physical_component.PhysicalComponent.power_on","title":"<code>power_on()</code>","text":"<p>Power on the physical component.</p> Source code in <code>PyCloudSim\\entity\\v_physical_component.py</code> <pre><code>def power_on(self):\n    \"\"\"Power on the physical component.\"\"\"\n    if self.powered_off:\n        Actor(\n            at=simulation.now,\n            action=self._power_on,\n            label=f\"{self.__class__.__name__} {self.label} Power On.\",\n            priority=POWERING,\n        )\n</code></pre>"},{"location":"api/physical_component/v_cpu/","title":"vCPU","text":"<p>The class \"vCPU\" is an implementation derived from the \"PhysicalComponent\" class. A \"vCPU\" object consists of multiple \"vCPUCore\" instances and a cache that serves as a pool for storing \"vProcess\" objects. Whenever a new \"vProcess\" is added to the cache or a \"vProcess\" is terminated, the \"vCPU\" class handles the assignment of \"vProcess\" objects to its corresponding \"vCPUCore\" based on several factors. These factors include the priority of the \"vProcess,\" the available computational power of each \"vCPUCore,\" and the allowed CPU time of the associated \"vContainer.\" Notably, a single \"vProcess\" can be assigned to multiple \"vCPUCore\" instances, allowing for simulated parallel execution. The scheduling of \"vProcess\" is implemented as an event with only one scheduling event being active for each \"vCPU\" at any given time.</p> <p>             Bases: <code>PhysicalComponent</code></p> Source code in <code>PyCloudSim\\entity\\v_cpu.py</code> <pre><code>class vCPU(PhysicalComponent):\n    _cpu_cores: List[vCPUCore]\n    _processes: List[vProcess]\n\n    def __init__(\n        self,\n        ipc: Union[int, float],\n        frequency: Union[int, float],\n        num_cores: int,\n        tdp: Union[int, float] = 50,\n        at: Union[int, float, Callable] = simulation.now,\n        after: Optional[Entity | List[Entity]] = None,\n        label: Optional[str] = None,\n    ):\n        \"\"\"Creates a new vCPU.\n\n        Args:\n            ipc (Union[int, float]): instructions per cycle.\n            frequency (Union[int, float]): the frequency of cpu core.\n            num_cores (int): the number of cores in the cpu.\n            tdp (Union[int, float], optional): the TDP, aka power consumption of the cpu. Defaults to 50W.\n            at (Union[int, float, Callable], optional): when the cpu should be created. Defaults to simulation.now.\n            after (Optional[Entity  |  List[Entity]], optional): the entity that must be terminated before the cpu can be created. Defaults to None.\n            label (Optional[str], optional): short description of the cpu. Defaults to None.\n        \"\"\"\n        super().__init__(at, after, label)\n        self._ipc = ipc\n        self._frequency = frequency * 1000000\n        self._num_cores = num_cores\n        cpu_cores = [\n            vCPUCore(\n                ipc=self.ipc,\n                frequency=self.frequency,\n                cpu=self,\n                label=f\"{self.label}-Core-{i}\",\n            )\n            for i in range(num_cores)\n        ]\n        self._cpu_cores = cpu_cores\n        self._tdp = tdp\n        self._processes = list()\n        self._process_scheduler: Actor = None  # type: ignore\n        simulation.CPUS.append(self)\n\n    def creation(self):\n        \"\"\"Creates the cpu.\"\"\"\n        return super().creation()\n\n    def termination(self):\n        \"\"\"Terminates the cpu.\"\"\"\n        return super().termination()\n\n    def _power_on(self):\n        \"\"\"Power on the cpu and all its cores.\"\"\"\n        super()._power_on()\n        for core in self.cpu_cores:\n            core.power_on()\n\n    def _power_off(self):\n        \"\"\"Power off the cpu and all its cores.\"\"\"\n        super()._power_off()\n        for core in self.cpu_cores:\n            core.power_off()\n\n    def cache_process(self, process: vProcess):\n        \"\"\"Cache a process in the cpu and call schedule_process().\"\"\"\n        if not process.cached:\n            self.processes.append(process)\n            process._cpu_id = self.id\n            process.status.append(CACHED)\n            self.schedule_process()\n\n    def schedule_process(self):\n        \"\"\"shcedule processes in the cpu queue.\"\"\"\n\n        def _schedule_process():\n            LOGGER.debug(\n                f\"{simulation.now:0.2f}:\\tvCPU {self.label} is scheduling ... {len(self.processes)} processes\"\n            )\n            self.processes.sort(key=lambda process: process.priority)\n            for process in self.processes:\n                # if not process.executing and not process.terminated:\n                for core in self.cpu_cores:\n                    remaining_to_schedule_instruction_length = (\n                        process.remaining - process.current_scheduled_length\n                    )\n                    if process.__class__.__name__ == \"vPacketHandler\":\n                        container_allowed_instruction_length = inf\n                    else:\n                        container_allowed_instruction_length = (\n                            process.container.cpu.available_quantity  # type: ignore\n                            / 1000\n                            * core.capacity\n                        )\n                    schedulable_instruction_length = int(\n                        min(\n                            [\n                                remaining_to_schedule_instruction_length,\n                                container_allowed_instruction_length,\n                                core.availablity,\n                            ]\n                        )\n                    )\n                    if schedulable_instruction_length &gt; 0:\n                        core.execute_process(process, schedulable_instruction_length)\n                        process._current_scheduled_length += (\n                            schedulable_instruction_length\n                        )\n                        scheduled_cpu_time = (\n                            schedulable_instruction_length / core.capacity\n                        ) * 1000\n\n                        if process.__class__.__name__ != \"vPacketHandler\":\n                            process.container.cpu.distribute(  # type: ignore\n                                process, scheduled_cpu_time\n                            )\n\n            LOGGER.debug(\n                f\"{simulation.now:0.2f}:\\tvCPU {self.label} scheduled all process within the queue.\"\n            )\n\n            self._process_scheduler = None  # type: ignore\n\n        if self.process_scheduler is None:\n            self._process_scheduler = Actor(\n                at=simulation.now,\n                action=_schedule_process,\n                label=f\"vCPU {self.label} Schedule vProcess\",\n                priority=CPU_SCHEDULE_PROCESS,\n            )\n\n    @property\n    def ipc(self) -&gt; Union[int, float]:\n        \"\"\"return the IPC of the cpu.\"\"\"\n        return self._ipc\n\n    @property\n    def frequency(self) -&gt; Union[int, float]:\n        \"\"\"return the frequency of the cpu.\"\"\"\n        return self._frequency\n\n    @property\n    def num_cores(self) -&gt; int:\n        \"\"\"return the number of cores of the cpu.\"\"\"\n        return self._num_cores\n\n    @property\n    def single_core_capacity(self) -&gt; Union[int, float]:\n        \"\"\"return the single core capacity of the cpu.\"\"\"\n        return (self.ipc * self.frequency) / simulation.cpu_acceleration\n\n    @property\n    def cpu_cores(self) -&gt; List[vCPUCore]:\n        \"\"\"return the cpu cores of the cpu.\"\"\"\n        return self._cpu_cores\n\n    @property\n    def capacity(self) -&gt; Union[int, float]:\n        \"\"\"return the capacity of the cpu.\"\"\"\n        return sum([core.capacity for core in self.cpu_cores])\n\n    @property\n    def availablity(self) -&gt; Union[int, float]:\n        \"\"\"return the availablity of the cpu.\"\"\"\n        return sum([core.availablity for core in self.cpu_cores])\n\n    @property\n    def utilization(self) -&gt; Union[int, float]:\n        \"\"\"return the utilization of the cpu.\"\"\"\n        return (self.capacity - self.availablity) / self.capacity * 100\n\n    def utilization_in_past(self, interval: Union[int, float]) -&gt; Union[int, float]:\n        \"\"\"return the utilization of the cpu in the past interval.\"\"\"\n        return (\n            sum(\n                [\n                    core.computational_power.utilization_in_past(interval)\n                    for core in self.cpu_cores\n                ]\n            )\n            / self.num_cores\n        )\n\n    @property\n    def processes(self) -&gt; List[vProcess]:\n        \"\"\"return the processes of the cpu.\"\"\"\n        return self._processes\n\n    @property\n    def process_scheduler(self) -&gt; Actor:\n        \"\"\"return the process scheduler of the cpu, if it is runing at the moment.\"\"\"\n        return self._process_scheduler\n\n    @property\n    def tdp(self) -&gt; Union[int, float]:\n        \"\"\"return the TDP of the cpu.\"\"\"\n        return self._tdp\n</code></pre>"},{"location":"api/physical_component/v_cpu/#PyCloudSim.entity.v_cpu.vCPU.availablity","title":"<code>availablity: Union[int, float]</code>  <code>property</code>","text":"<p>return the availablity of the cpu.</p>"},{"location":"api/physical_component/v_cpu/#PyCloudSim.entity.v_cpu.vCPU.capacity","title":"<code>capacity: Union[int, float]</code>  <code>property</code>","text":"<p>return the capacity of the cpu.</p>"},{"location":"api/physical_component/v_cpu/#PyCloudSim.entity.v_cpu.vCPU.cpu_cores","title":"<code>cpu_cores: List[vCPUCore]</code>  <code>property</code>","text":"<p>return the cpu cores of the cpu.</p>"},{"location":"api/physical_component/v_cpu/#PyCloudSim.entity.v_cpu.vCPU.frequency","title":"<code>frequency: Union[int, float]</code>  <code>property</code>","text":"<p>return the frequency of the cpu.</p>"},{"location":"api/physical_component/v_cpu/#PyCloudSim.entity.v_cpu.vCPU.ipc","title":"<code>ipc: Union[int, float]</code>  <code>property</code>","text":"<p>return the IPC of the cpu.</p>"},{"location":"api/physical_component/v_cpu/#PyCloudSim.entity.v_cpu.vCPU.num_cores","title":"<code>num_cores: int</code>  <code>property</code>","text":"<p>return the number of cores of the cpu.</p>"},{"location":"api/physical_component/v_cpu/#PyCloudSim.entity.v_cpu.vCPU.process_scheduler","title":"<code>process_scheduler: Actor</code>  <code>property</code>","text":"<p>return the process scheduler of the cpu, if it is runing at the moment.</p>"},{"location":"api/physical_component/v_cpu/#PyCloudSim.entity.v_cpu.vCPU.processes","title":"<code>processes: List[vProcess]</code>  <code>property</code>","text":"<p>return the processes of the cpu.</p>"},{"location":"api/physical_component/v_cpu/#PyCloudSim.entity.v_cpu.vCPU.single_core_capacity","title":"<code>single_core_capacity: Union[int, float]</code>  <code>property</code>","text":"<p>return the single core capacity of the cpu.</p>"},{"location":"api/physical_component/v_cpu/#PyCloudSim.entity.v_cpu.vCPU.tdp","title":"<code>tdp: Union[int, float]</code>  <code>property</code>","text":"<p>return the TDP of the cpu.</p>"},{"location":"api/physical_component/v_cpu/#PyCloudSim.entity.v_cpu.vCPU.utilization","title":"<code>utilization: Union[int, float]</code>  <code>property</code>","text":"<p>return the utilization of the cpu.</p>"},{"location":"api/physical_component/v_cpu/#PyCloudSim.entity.v_cpu.vCPU.__init__","title":"<code>__init__(ipc, frequency, num_cores, tdp=50, at=simulation.now, after=None, label=None)</code>","text":"<p>Creates a new vCPU.</p> <p>Parameters:</p> Name Type Description Default <code>ipc</code> <code>Union[int, float]</code> <p>instructions per cycle.</p> required <code>frequency</code> <code>Union[int, float]</code> <p>the frequency of cpu core.</p> required <code>num_cores</code> <code>int</code> <p>the number of cores in the cpu.</p> required <code>tdp</code> <code>Union[int, float]</code> <p>the TDP, aka power consumption of the cpu. Defaults to 50W.</p> <code>50</code> <code>at</code> <code>Union[int, float, Callable]</code> <p>when the cpu should be created. Defaults to simulation.now.</p> <code>now</code> <code>after</code> <code>Optional[Entity | List[Entity]]</code> <p>the entity that must be terminated before the cpu can be created. Defaults to None.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>short description of the cpu. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_cpu.py</code> <pre><code>def __init__(\n    self,\n    ipc: Union[int, float],\n    frequency: Union[int, float],\n    num_cores: int,\n    tdp: Union[int, float] = 50,\n    at: Union[int, float, Callable] = simulation.now,\n    after: Optional[Entity | List[Entity]] = None,\n    label: Optional[str] = None,\n):\n    \"\"\"Creates a new vCPU.\n\n    Args:\n        ipc (Union[int, float]): instructions per cycle.\n        frequency (Union[int, float]): the frequency of cpu core.\n        num_cores (int): the number of cores in the cpu.\n        tdp (Union[int, float], optional): the TDP, aka power consumption of the cpu. Defaults to 50W.\n        at (Union[int, float, Callable], optional): when the cpu should be created. Defaults to simulation.now.\n        after (Optional[Entity  |  List[Entity]], optional): the entity that must be terminated before the cpu can be created. Defaults to None.\n        label (Optional[str], optional): short description of the cpu. Defaults to None.\n    \"\"\"\n    super().__init__(at, after, label)\n    self._ipc = ipc\n    self._frequency = frequency * 1000000\n    self._num_cores = num_cores\n    cpu_cores = [\n        vCPUCore(\n            ipc=self.ipc,\n            frequency=self.frequency,\n            cpu=self,\n            label=f\"{self.label}-Core-{i}\",\n        )\n        for i in range(num_cores)\n    ]\n    self._cpu_cores = cpu_cores\n    self._tdp = tdp\n    self._processes = list()\n    self._process_scheduler: Actor = None  # type: ignore\n    simulation.CPUS.append(self)\n</code></pre>"},{"location":"api/physical_component/v_cpu/#PyCloudSim.entity.v_cpu.vCPU.cache_process","title":"<code>cache_process(process)</code>","text":"<p>Cache a process in the cpu and call schedule_process().</p> Source code in <code>PyCloudSim\\entity\\v_cpu.py</code> <pre><code>def cache_process(self, process: vProcess):\n    \"\"\"Cache a process in the cpu and call schedule_process().\"\"\"\n    if not process.cached:\n        self.processes.append(process)\n        process._cpu_id = self.id\n        process.status.append(CACHED)\n        self.schedule_process()\n</code></pre>"},{"location":"api/physical_component/v_cpu/#PyCloudSim.entity.v_cpu.vCPU.creation","title":"<code>creation()</code>","text":"<p>Creates the cpu.</p> Source code in <code>PyCloudSim\\entity\\v_cpu.py</code> <pre><code>def creation(self):\n    \"\"\"Creates the cpu.\"\"\"\n    return super().creation()\n</code></pre>"},{"location":"api/physical_component/v_cpu/#PyCloudSim.entity.v_cpu.vCPU.schedule_process","title":"<code>schedule_process()</code>","text":"<p>shcedule processes in the cpu queue.</p> Source code in <code>PyCloudSim\\entity\\v_cpu.py</code> <pre><code>def schedule_process(self):\n    \"\"\"shcedule processes in the cpu queue.\"\"\"\n\n    def _schedule_process():\n        LOGGER.debug(\n            f\"{simulation.now:0.2f}:\\tvCPU {self.label} is scheduling ... {len(self.processes)} processes\"\n        )\n        self.processes.sort(key=lambda process: process.priority)\n        for process in self.processes:\n            # if not process.executing and not process.terminated:\n            for core in self.cpu_cores:\n                remaining_to_schedule_instruction_length = (\n                    process.remaining - process.current_scheduled_length\n                )\n                if process.__class__.__name__ == \"vPacketHandler\":\n                    container_allowed_instruction_length = inf\n                else:\n                    container_allowed_instruction_length = (\n                        process.container.cpu.available_quantity  # type: ignore\n                        / 1000\n                        * core.capacity\n                    )\n                schedulable_instruction_length = int(\n                    min(\n                        [\n                            remaining_to_schedule_instruction_length,\n                            container_allowed_instruction_length,\n                            core.availablity,\n                        ]\n                    )\n                )\n                if schedulable_instruction_length &gt; 0:\n                    core.execute_process(process, schedulable_instruction_length)\n                    process._current_scheduled_length += (\n                        schedulable_instruction_length\n                    )\n                    scheduled_cpu_time = (\n                        schedulable_instruction_length / core.capacity\n                    ) * 1000\n\n                    if process.__class__.__name__ != \"vPacketHandler\":\n                        process.container.cpu.distribute(  # type: ignore\n                            process, scheduled_cpu_time\n                        )\n\n        LOGGER.debug(\n            f\"{simulation.now:0.2f}:\\tvCPU {self.label} scheduled all process within the queue.\"\n        )\n\n        self._process_scheduler = None  # type: ignore\n\n    if self.process_scheduler is None:\n        self._process_scheduler = Actor(\n            at=simulation.now,\n            action=_schedule_process,\n            label=f\"vCPU {self.label} Schedule vProcess\",\n            priority=CPU_SCHEDULE_PROCESS,\n        )\n</code></pre>"},{"location":"api/physical_component/v_cpu/#PyCloudSim.entity.v_cpu.vCPU.termination","title":"<code>termination()</code>","text":"<p>Terminates the cpu.</p> Source code in <code>PyCloudSim\\entity\\v_cpu.py</code> <pre><code>def termination(self):\n    \"\"\"Terminates the cpu.\"\"\"\n    return super().termination()\n</code></pre>"},{"location":"api/physical_component/v_cpu/#PyCloudSim.entity.v_cpu.vCPU.utilization_in_past","title":"<code>utilization_in_past(interval)</code>","text":"<p>return the utilization of the cpu in the past interval.</p> Source code in <code>PyCloudSim\\entity\\v_cpu.py</code> <pre><code>def utilization_in_past(self, interval: Union[int, float]) -&gt; Union[int, float]:\n    \"\"\"return the utilization of the cpu in the past interval.\"\"\"\n    return (\n        sum(\n            [\n                core.computational_power.utilization_in_past(interval)\n                for core in self.cpu_cores\n            ]\n        )\n        / self.num_cores\n    )\n</code></pre>"},{"location":"api/physical_component/v_cpu_core/","title":"vCPUCore","text":"<p>The class \"vCPUCore\" serves as the implementation of CPU cores within the simulation. It includes two mandatory attributes: frequency and instructions-per-cycle, which determine the computational capacity of the core. The computational capacity is represented as a \"Resource\" object from the \"Akatosh\" library, enabling withdrawal or return of the available amount during the simulation. The \"vCPUCore\" is responsible for allocating the computational power to the assigned processes and reclaiming the distributed amount once the execution of the assigned process is complete. In the event that the \"vCPUCore\" is arbitrarily powered off during the simulation, all processes currently in execution will be considered as failed.</p> <p>             Bases: <code>PhysicalComponent</code></p> Source code in <code>PyCloudSim\\entity\\v_cpu_core.py</code> <pre><code>class vCPUCore(PhysicalComponent):\n    _ipc: Union[int, float]\n    _frequency: Union[int, float]\n    _computational_power: Resource\n    _processes: List[vProcess]\n\n    def __init__(\n        self,\n        ipc: Union[int, float],\n        frequency: Union[int, float],\n        cpu: vCPU,\n        at: Union[int, float, Callable] = simulation.now,\n        after: Optional[Entity | List[Entity]] = None,\n        label: Optional[str] = None,\n    ):\n        \"\"\"Creates a new vCPUCore.\n\n        Args:\n            ipc (Union[int, float]): instructions per cycle.\n            frequency (Union[int, float]): the frequency of cpu core.\n            cpu (vCPU): the cpu that this core belongs to.\n            at (Union[int, float, Callable], optional): when the cpu core should be created. Defaults to simulation.now.\n            after (Optional[Entity  |  List[Entity]], optional): the entity that must be terminated before the cpu core is created. Defaults to None.\n            label (Optional[str], optional): the short description of the cpu core. Defaults to None.\n        \"\"\"\n        super().__init__(at, after, label)\n        self._ipc = ipc\n        self._frequency = frequency\n        self._cpu_id = cpu.id\n        self._computational_power = Resource(\n            capacity=ipc * frequency / simulation.cpu_acceleration,\n            label=f\"{self.__class__.__name__} {self.label} Capacity\",\n        )\n        self._processes = list()\n        simulation.CPU_CORES.append(self)\n\n    def creation(self):\n        \"\"\"Creates the cpu core.\"\"\"\n        return super().creation()\n\n    def termination(self):\n        \"\"\"Terminates the cpu core.\"\"\"\n        return super().termination()\n\n    def _power_on(self):\n        \"\"\"Power on the cpu core.\"\"\"\n        super()._power_on()\n\n    def _power_off(self):\n        \"\"\"Power off the cpu core\"\"\"\n        super()._power_off()\n\n    def execute_process(self, process: vProcess, length: int):\n        \"\"\"Executes a process for a given length.\n\n        Args:\n            process (vProcess): the process to be executed.\n            length (int): the length of instructions to be executed.\n        \"\"\"\n        self.processes.append(process)\n        self.computational_power.distribute(process, length)\n        execution_time = length / self.computational_power.capacity\n        process.executing_cores.append(self)\n        process.status.append(EXECUTING)\n        LOGGER.debug(\n            f\"{simulation.now:0.2f}:\\tvCPUCore {self.label} is executing {length} instructions for {process .__class__.__name__} {process.label}, {self.availablity} Capaccity left.\"\n        )\n\n        def _clear_executed_instructions():\n            if not process.failed:\n                self.computational_power.release(process, length)\n                process._progress += length\n                process._current_scheduled_length -= length\n                self.processes.remove(process)\n                process.executing_cores.remove(self)\n                process.status.remove(EXECUTING)\n                cpu_time = length / self.computational_power.capacity * 1000\n                if process.__class__.__name__ != \"vPacketHandler\":\n                    process.container.cpu.release(process, cpu_time) #type: ignore\n                LOGGER.debug(\n                    f\"{simulation.now:0.2f}:\\tvCPUCore {self.label} executed {length} instructions for {process .__class__.__name__} {process.label}, {self.availablity} Capacity left.\"\n                )\n                if process.__class__.__name__ != \"vPacketHandler\":\n                    LOGGER.debug(\n                        f\"{simulation.now:0.2f}:\\tvProcess {process.label} progress: {process.progress/process.length}, released {cpu_time} CPU Time of vContainer {process.container.label}, current CPU Time capacity {process.container.cpu.available_quantity}.\" #type: ignore\n                    )\n                else:\n                    LOGGER.debug(\n                        f\"{simulation.now:0.2f}:\\tvPacketHandler {process.label} progress: {process.progress/process.length}, released {cpu_time} CPU Time of vHost {process.host.label}, current CPU Time capacity {process.host.cpu.availablity}.\"\n                    )\n\n                Actor(\n                    at=simulation.now,\n                    action=process.complete,\n                    label=f\"vProcess {process.label} Clear Executed Instructions\",\n                    priority=PROCESS_COMPLETE_CHECK,\n                )\n\n                Actor(\n                    at=simulation.now,\n                    action=self.cpu.schedule_process,\n                    label=f\"vCPU {self.cpu.label} Schedule Processes\",\n                    priority=CPU_SCHEDULE_PROCESS,\n                )\n\n        Actor(\n            at=simulation.now + execution_time,\n            action=_clear_executed_instructions,\n            label=f\"vCPUCore {self.label} Clear Executed Instructions\",\n            priority=CORE_CLEAR_INSTRUCTIONS,\n        )\n\n    @property\n    def ipc(self) -&gt; Union[int, float]:\n        \"\"\"returns the instructions per cycle of the cpu core.\"\"\"\n        return self._ipc\n\n    @property\n    def frequency(self) -&gt; Union[int, float]:\n        \"\"\"returns the frequency of the cpu core.\"\"\"\n        return self._frequency\n\n    @property\n    def computational_power(self) -&gt; Resource:\n        \"\"\"returns the computational power ( as Resource ) of the cpu core.\"\"\"\n        return self._computational_power\n\n    @property\n    def capacity(self) -&gt; Union[int, float]:\n        \"\"\"returns the capacity of the cpu core, aka how many instructions can be executed per second.\"\"\"\n        return self.computational_power.capacity\n\n    @property\n    def availablity(self) -&gt; Union[int, float]:\n        \"\"\"returns the availablity of the cpu core in number of instructions.\"\"\"\n        return self.computational_power.available_quantity\n\n    @property\n    def utilization(self) -&gt; Union[int, float]:\n        \"\"\"returns the utilization of the cpu core in percentage.\"\"\"\n        return self.computational_power.utilization * 100\n\n    @property\n    def processes(self) -&gt; List[vProcess]:\n        \"\"\"returns the processes that are currently executing on the cpu core.\"\"\"\n        return self._processes\n\n    @property\n    def cpu(self) -&gt; vCPU:\n        \"\"\"returns the cpu that this cpu core belongs to.\"\"\"\n        for cpu in simulation.CPUS:\n            if cpu.id == self._cpu_id:\n                return cpu\n        raise RuntimeError(f\"vCPUCore {self.label} can not found its associated vCPU.\")\n</code></pre>"},{"location":"api/physical_component/v_cpu_core/#PyCloudSim.entity.v_cpu_core.vCPUCore.availablity","title":"<code>availablity: Union[int, float]</code>  <code>property</code>","text":"<p>returns the availablity of the cpu core in number of instructions.</p>"},{"location":"api/physical_component/v_cpu_core/#PyCloudSim.entity.v_cpu_core.vCPUCore.capacity","title":"<code>capacity: Union[int, float]</code>  <code>property</code>","text":"<p>returns the capacity of the cpu core, aka how many instructions can be executed per second.</p>"},{"location":"api/physical_component/v_cpu_core/#PyCloudSim.entity.v_cpu_core.vCPUCore.computational_power","title":"<code>computational_power: Resource</code>  <code>property</code>","text":"<p>returns the computational power ( as Resource ) of the cpu core.</p>"},{"location":"api/physical_component/v_cpu_core/#PyCloudSim.entity.v_cpu_core.vCPUCore.cpu","title":"<code>cpu: vCPU</code>  <code>property</code>","text":"<p>returns the cpu that this cpu core belongs to.</p>"},{"location":"api/physical_component/v_cpu_core/#PyCloudSim.entity.v_cpu_core.vCPUCore.frequency","title":"<code>frequency: Union[int, float]</code>  <code>property</code>","text":"<p>returns the frequency of the cpu core.</p>"},{"location":"api/physical_component/v_cpu_core/#PyCloudSim.entity.v_cpu_core.vCPUCore.ipc","title":"<code>ipc: Union[int, float]</code>  <code>property</code>","text":"<p>returns the instructions per cycle of the cpu core.</p>"},{"location":"api/physical_component/v_cpu_core/#PyCloudSim.entity.v_cpu_core.vCPUCore.processes","title":"<code>processes: List[vProcess]</code>  <code>property</code>","text":"<p>returns the processes that are currently executing on the cpu core.</p>"},{"location":"api/physical_component/v_cpu_core/#PyCloudSim.entity.v_cpu_core.vCPUCore.utilization","title":"<code>utilization: Union[int, float]</code>  <code>property</code>","text":"<p>returns the utilization of the cpu core in percentage.</p>"},{"location":"api/physical_component/v_cpu_core/#PyCloudSim.entity.v_cpu_core.vCPUCore.__init__","title":"<code>__init__(ipc, frequency, cpu, at=simulation.now, after=None, label=None)</code>","text":"<p>Creates a new vCPUCore.</p> <p>Parameters:</p> Name Type Description Default <code>ipc</code> <code>Union[int, float]</code> <p>instructions per cycle.</p> required <code>frequency</code> <code>Union[int, float]</code> <p>the frequency of cpu core.</p> required <code>cpu</code> <code>vCPU</code> <p>the cpu that this core belongs to.</p> required <code>at</code> <code>Union[int, float, Callable]</code> <p>when the cpu core should be created. Defaults to simulation.now.</p> <code>now</code> <code>after</code> <code>Optional[Entity | List[Entity]]</code> <p>the entity that must be terminated before the cpu core is created. Defaults to None.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>the short description of the cpu core. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_cpu_core.py</code> <pre><code>def __init__(\n    self,\n    ipc: Union[int, float],\n    frequency: Union[int, float],\n    cpu: vCPU,\n    at: Union[int, float, Callable] = simulation.now,\n    after: Optional[Entity | List[Entity]] = None,\n    label: Optional[str] = None,\n):\n    \"\"\"Creates a new vCPUCore.\n\n    Args:\n        ipc (Union[int, float]): instructions per cycle.\n        frequency (Union[int, float]): the frequency of cpu core.\n        cpu (vCPU): the cpu that this core belongs to.\n        at (Union[int, float, Callable], optional): when the cpu core should be created. Defaults to simulation.now.\n        after (Optional[Entity  |  List[Entity]], optional): the entity that must be terminated before the cpu core is created. Defaults to None.\n        label (Optional[str], optional): the short description of the cpu core. Defaults to None.\n    \"\"\"\n    super().__init__(at, after, label)\n    self._ipc = ipc\n    self._frequency = frequency\n    self._cpu_id = cpu.id\n    self._computational_power = Resource(\n        capacity=ipc * frequency / simulation.cpu_acceleration,\n        label=f\"{self.__class__.__name__} {self.label} Capacity\",\n    )\n    self._processes = list()\n    simulation.CPU_CORES.append(self)\n</code></pre>"},{"location":"api/physical_component/v_cpu_core/#PyCloudSim.entity.v_cpu_core.vCPUCore.creation","title":"<code>creation()</code>","text":"<p>Creates the cpu core.</p> Source code in <code>PyCloudSim\\entity\\v_cpu_core.py</code> <pre><code>def creation(self):\n    \"\"\"Creates the cpu core.\"\"\"\n    return super().creation()\n</code></pre>"},{"location":"api/physical_component/v_cpu_core/#PyCloudSim.entity.v_cpu_core.vCPUCore.execute_process","title":"<code>execute_process(process, length)</code>","text":"<p>Executes a process for a given length.</p> <p>Parameters:</p> Name Type Description Default <code>process</code> <code>vProcess</code> <p>the process to be executed.</p> required <code>length</code> <code>int</code> <p>the length of instructions to be executed.</p> required Source code in <code>PyCloudSim\\entity\\v_cpu_core.py</code> <pre><code>def execute_process(self, process: vProcess, length: int):\n    \"\"\"Executes a process for a given length.\n\n    Args:\n        process (vProcess): the process to be executed.\n        length (int): the length of instructions to be executed.\n    \"\"\"\n    self.processes.append(process)\n    self.computational_power.distribute(process, length)\n    execution_time = length / self.computational_power.capacity\n    process.executing_cores.append(self)\n    process.status.append(EXECUTING)\n    LOGGER.debug(\n        f\"{simulation.now:0.2f}:\\tvCPUCore {self.label} is executing {length} instructions for {process .__class__.__name__} {process.label}, {self.availablity} Capaccity left.\"\n    )\n\n    def _clear_executed_instructions():\n        if not process.failed:\n            self.computational_power.release(process, length)\n            process._progress += length\n            process._current_scheduled_length -= length\n            self.processes.remove(process)\n            process.executing_cores.remove(self)\n            process.status.remove(EXECUTING)\n            cpu_time = length / self.computational_power.capacity * 1000\n            if process.__class__.__name__ != \"vPacketHandler\":\n                process.container.cpu.release(process, cpu_time) #type: ignore\n            LOGGER.debug(\n                f\"{simulation.now:0.2f}:\\tvCPUCore {self.label} executed {length} instructions for {process .__class__.__name__} {process.label}, {self.availablity} Capacity left.\"\n            )\n            if process.__class__.__name__ != \"vPacketHandler\":\n                LOGGER.debug(\n                    f\"{simulation.now:0.2f}:\\tvProcess {process.label} progress: {process.progress/process.length}, released {cpu_time} CPU Time of vContainer {process.container.label}, current CPU Time capacity {process.container.cpu.available_quantity}.\" #type: ignore\n                )\n            else:\n                LOGGER.debug(\n                    f\"{simulation.now:0.2f}:\\tvPacketHandler {process.label} progress: {process.progress/process.length}, released {cpu_time} CPU Time of vHost {process.host.label}, current CPU Time capacity {process.host.cpu.availablity}.\"\n                )\n\n            Actor(\n                at=simulation.now,\n                action=process.complete,\n                label=f\"vProcess {process.label} Clear Executed Instructions\",\n                priority=PROCESS_COMPLETE_CHECK,\n            )\n\n            Actor(\n                at=simulation.now,\n                action=self.cpu.schedule_process,\n                label=f\"vCPU {self.cpu.label} Schedule Processes\",\n                priority=CPU_SCHEDULE_PROCESS,\n            )\n\n    Actor(\n        at=simulation.now + execution_time,\n        action=_clear_executed_instructions,\n        label=f\"vCPUCore {self.label} Clear Executed Instructions\",\n        priority=CORE_CLEAR_INSTRUCTIONS,\n    )\n</code></pre>"},{"location":"api/physical_component/v_cpu_core/#PyCloudSim.entity.v_cpu_core.vCPUCore.termination","title":"<code>termination()</code>","text":"<p>Terminates the cpu core.</p> Source code in <code>PyCloudSim\\entity\\v_cpu_core.py</code> <pre><code>def termination(self):\n    \"\"\"Terminates the cpu core.\"\"\"\n    return super().termination()\n</code></pre>"},{"location":"api/physical_component/v_nic/","title":"vNIC","text":"<p>The class \"vNIC\" serves as the implementation of the network interface card in the simulation. It includes a queue specifically designed to store \"vPacket\" objects and has the capability to establish connections with other \"vNIC\" instances. The \"vNIC\" class is equipped with two resources: uplink bandwidth and downlink bandwidth. These resources are allocated to the transmission and reception of \"vPacket\" objects respectively. The transmission and reception functionalities of \"vPacket\" are implemented as member functions within the class. Upon receiving a \"vPacket\", a specialized \"vProcess\" called PacketHandler is created to simulate the decoding process and the associated processing delay. If there is insufficient uplink or downlink bandwidth available, the \"vPacket\" will be kept in the queue until the necessary resources become available.</p> <p>             Bases: <code>PhysicalComponent</code></p> Source code in <code>PyCloudSim\\entity\\v_nic.py</code> <pre><code>class vNIC(PhysicalComponent):\n    def __init__(\n        self,\n        host: Union[vHost, vRouter, vSwitch, vGateway],\n        connected_to: Optional[Union[vHost, vRouter, vSwitch, vGateway]] = None,\n        bandwidth: int = 1000,\n        delay: float = 0.02,\n        ip: Optional[IPv4Address] = None,\n        at: Union[int, float, Callable] = simulation.now,\n        after: Optional[Entity | List[Entity]] = None,\n        label: Optional[str] = None,\n    ):\n        \"\"\"Create a vNIC object.\n\n        Args:\n            host (Union[vHost, vRouter, vSwitch, vGateway]): the host that the vNIC is attached to.\n            connected_to (Optional[Union[vHost, vRouter, vSwitch, vGateway]], optional): the device that the vNIC is connected to. Defaults to None.\n            bandwidth (int, optional): the bandwidth in MBps of the vNIC. Defaults to 1000.\n            delay (float, optional): the processing delay of the vNIC. Defaults to 0.02.\n            ip (Optional[IPv4Address], optional): the IP address of the vNIC. Defaults to None.\n            at (Union[int, float, Callable], optional): same as Entity. Defaults to simulation.now.\n            after (Optional[Entity  |  List[Entity]], optional): same as Entity. Defaults to None.\n            label (Optional[str], optional): Same as Entity. Defaults to None.\n        \"\"\"\n        super().__init__(at, after, label)\n        self._host = host\n        self._connected_to = connected_to\n        self._bandwidth = MiB(bandwidth)\n        self._delay = delay\n        self._ip = ip\n        if host.__class__.__name__ == \"vHost\" or host.__class__.__name__ == \"vRouter\":\n            self._type = \"Interface\"\n        else:\n            self._type = \"Port\"\n        self._uplink = Resource(\n            capacity=self.bandwidth, label=f\"vNIC {self.label} Uplink\"\n        )\n        self._downlink = Resource(\n            capacity=self.bandwidth, label=f\"vNIC {self.label} Downlink\"\n        )\n        simulation.NICS.append(self)\n\n    def creation(self):\n        \"\"\"Creation process of the vNIC\"\"\"\n        return super().creation()\n\n    def termination(self):\n        \"\"\"Termination process of the vNIC\"\"\"\n        return super().termination()\n\n    def _power_on(self):\n        \"\"\"Power on the vNIC\"\"\"\n        return super()._power_on()\n\n    def _power_off(self):\n        \"\"\"Power off the vNIC\"\"\"\n        return super()._power_off()\n\n    def receive_packet(self, packet: vPacket, delay: float = 0.0):\n        \"\"\"Rceive a vPacket, the vPacket will be dropped if the attached host does not have enough RAM.\n\n        Args:\n            packet (vPacket): the vPacket to be recevived.\n            delay (float, optional): the delay for receiving this vPacket in term of transmitting time. Defaults to 0.0.\n        \"\"\"\n        self.uplink.distribute(packet, packet.size)\n        LOGGER.debug(\n            f\"{simulation.now:0.2f}:\\tvPacket {packet.label} is using {packet.size}/{self.uplink.available_quantity}/{self.uplink.capacity} bytes of vNIC {self.label} uplink.\"\n        )\n\n        def _received_packet():\n            self.uplink.release(packet)\n            packet.status.remove(TRANSMITTING)\n            packet.status.remove(DECODED)\n            try:\n                self.host.cache_packet(packet)\n                LOGGER.info(\n                    f\"{simulation.now:0.2f}:\\tvPacket {packet.label} is received by {self.host.__class__.__name__} {self.host.label}\"\n                )\n            except:\n                packet.drop()\n                LOGGER.info(\n                    f\"{simulation.now:0.2f}:\\tvPacket {packet.label} is droped by {self.host.__class__.__name__} {self.host.label}\"\n                )\n\n        Actor(\n            at=simulation.now + delay,\n            action=_received_packet,\n            label=f\"vNIC {self.label} Receive Packet\",\n            priority=CORE_EXECUTE_PROCESS,\n        )\n\n    def send_packet(self, packet: vPacket, delay: float = 0.0):\n        \"\"\"Send a vPacket.\n\n        Args:\n            packet (vPacket): the vPacket to be sent.\n            delay (float, optional): the delay for sending this packet in term of transmitting time. Defaults to 0.0.\n        \"\"\"\n        self.downlink.distribute(packet, packet.size)\n        LOGGER.debug(\n            f\"{simulation.now:0.2f}:\\tvPacket {packet.label} is using {packet.size}/{self.downlink.available_quantity}/{self.downlink.capacity} bytes of vNIC {self.label} downlink.\"\n        )\n        self.host.packets.remove(packet)\n        packet.status.append(TRANSMITTING)\n        packet.status.remove(QUEUED)\n\n        def _sent_packet():\n            self.downlink.release(packet)\n            if self.host.__class__.__name__ == \"vGateway\":\n                pass\n            else:\n                self.host.ram.release(packet)  # type: ignore\n            LOGGER.info(\n                f\"{simulation.now:0.2f}:\\tvPacket {packet.label} is sent by {self.host.__class__.__name__} {self.host.label}\"\n            )\n            Actor(\n                at=simulation.now,\n                action=self.host.send_packets,\n                label=f\"{self.__class__.__name__} {self.label} Send Packets\",\n                priority=HOST_SCHEDULE_PACKET,\n            )\n\n        Actor(\n            at=simulation.now + delay,\n            action=_sent_packet,\n            label=f\"vNIC {self.label} Send Packet\",\n            priority=CORE_EXECUTE_PROCESS,\n        )\n\n    @property\n    def host(self) -&gt; Union[vHost, vRouter, vSwitch, vGateway]:\n        \"\"\"The attached host.\"\"\"\n        return self._host\n\n    @property\n    def connected_to(self) -&gt; Optional[Union[vHost, vRouter, vSwitch, vGateway]]:\n        \"\"\"The connected device.\"\"\"\n        return self._connected_to\n\n    @property\n    def bandwidth(self) -&gt; float:\n        \"\"\"The bandwidth of the vNIC in MB/s.\"\"\"\n        return self._bandwidth.bytes\n\n    @property\n    def delay(self) -&gt; float:\n        return self._delay\n\n    @property\n    def ip(self) -&gt; Optional[IPv4Address]:\n        \"\"\"The IP address of the vNIC.\"\"\"\n        if self.type == \"Interface\":\n            return self._ip\n        else:\n            return None\n\n    @property\n    def type(self) -&gt; str:\n        \"\"\"The type of the vNIC.\"\"\"\n        return self._type\n\n    @property\n    def uplink(self) -&gt; Resource:\n        \"\"\"The uplink of the vNIC.\"\"\"\n        return self._uplink\n\n    @property\n    def downlink(self) -&gt; Resource:\n        \"\"\"The downlink of the vNIC.\"\"\"\n        return self._downlink\n\n    def downlink_utilization(self, inertval: float = 0.1) -&gt; float:\n        \"\"\"The downlink utilization of the vNIC in percentage.\"\"\"\n        return self.downlink.utilization_in_past(inertval) * 100\n\n    def uplink_utilization(self, inertval: float = 0.1) -&gt; float:\n        \"\"\"The uplink utilization of the vNIC in percentage.\"\"\"\n        return self.uplink.utilization_in_past(inertval) * 100\n</code></pre>"},{"location":"api/physical_component/v_nic/#PyCloudSim.entity.v_nic.vNIC.bandwidth","title":"<code>bandwidth: float</code>  <code>property</code>","text":"<p>The bandwidth of the vNIC in MB/s.</p>"},{"location":"api/physical_component/v_nic/#PyCloudSim.entity.v_nic.vNIC.connected_to","title":"<code>connected_to: Optional[Union[vHost, vRouter, vSwitch, vGateway]]</code>  <code>property</code>","text":"<p>The connected device.</p>"},{"location":"api/physical_component/v_nic/#PyCloudSim.entity.v_nic.vNIC.downlink","title":"<code>downlink: Resource</code>  <code>property</code>","text":"<p>The downlink of the vNIC.</p>"},{"location":"api/physical_component/v_nic/#PyCloudSim.entity.v_nic.vNIC.host","title":"<code>host: Union[vHost, vRouter, vSwitch, vGateway]</code>  <code>property</code>","text":"<p>The attached host.</p>"},{"location":"api/physical_component/v_nic/#PyCloudSim.entity.v_nic.vNIC.ip","title":"<code>ip: Optional[IPv4Address]</code>  <code>property</code>","text":"<p>The IP address of the vNIC.</p>"},{"location":"api/physical_component/v_nic/#PyCloudSim.entity.v_nic.vNIC.type","title":"<code>type: str</code>  <code>property</code>","text":"<p>The type of the vNIC.</p>"},{"location":"api/physical_component/v_nic/#PyCloudSim.entity.v_nic.vNIC.uplink","title":"<code>uplink: Resource</code>  <code>property</code>","text":"<p>The uplink of the vNIC.</p>"},{"location":"api/physical_component/v_nic/#PyCloudSim.entity.v_nic.vNIC.__init__","title":"<code>__init__(host, connected_to=None, bandwidth=1000, delay=0.02, ip=None, at=simulation.now, after=None, label=None)</code>","text":"<p>Create a vNIC object.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>Union[vHost, vRouter, vSwitch, vGateway]</code> <p>the host that the vNIC is attached to.</p> required <code>connected_to</code> <code>Optional[Union[vHost, vRouter, vSwitch, vGateway]]</code> <p>the device that the vNIC is connected to. Defaults to None.</p> <code>None</code> <code>bandwidth</code> <code>int</code> <p>the bandwidth in MBps of the vNIC. Defaults to 1000.</p> <code>1000</code> <code>delay</code> <code>float</code> <p>the processing delay of the vNIC. Defaults to 0.02.</p> <code>0.02</code> <code>ip</code> <code>Optional[IPv4Address]</code> <p>the IP address of the vNIC. Defaults to None.</p> <code>None</code> <code>at</code> <code>Union[int, float, Callable]</code> <p>same as Entity. Defaults to simulation.now.</p> <code>now</code> <code>after</code> <code>Optional[Entity | List[Entity]]</code> <p>same as Entity. Defaults to None.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>Same as Entity. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_nic.py</code> <pre><code>def __init__(\n    self,\n    host: Union[vHost, vRouter, vSwitch, vGateway],\n    connected_to: Optional[Union[vHost, vRouter, vSwitch, vGateway]] = None,\n    bandwidth: int = 1000,\n    delay: float = 0.02,\n    ip: Optional[IPv4Address] = None,\n    at: Union[int, float, Callable] = simulation.now,\n    after: Optional[Entity | List[Entity]] = None,\n    label: Optional[str] = None,\n):\n    \"\"\"Create a vNIC object.\n\n    Args:\n        host (Union[vHost, vRouter, vSwitch, vGateway]): the host that the vNIC is attached to.\n        connected_to (Optional[Union[vHost, vRouter, vSwitch, vGateway]], optional): the device that the vNIC is connected to. Defaults to None.\n        bandwidth (int, optional): the bandwidth in MBps of the vNIC. Defaults to 1000.\n        delay (float, optional): the processing delay of the vNIC. Defaults to 0.02.\n        ip (Optional[IPv4Address], optional): the IP address of the vNIC. Defaults to None.\n        at (Union[int, float, Callable], optional): same as Entity. Defaults to simulation.now.\n        after (Optional[Entity  |  List[Entity]], optional): same as Entity. Defaults to None.\n        label (Optional[str], optional): Same as Entity. Defaults to None.\n    \"\"\"\n    super().__init__(at, after, label)\n    self._host = host\n    self._connected_to = connected_to\n    self._bandwidth = MiB(bandwidth)\n    self._delay = delay\n    self._ip = ip\n    if host.__class__.__name__ == \"vHost\" or host.__class__.__name__ == \"vRouter\":\n        self._type = \"Interface\"\n    else:\n        self._type = \"Port\"\n    self._uplink = Resource(\n        capacity=self.bandwidth, label=f\"vNIC {self.label} Uplink\"\n    )\n    self._downlink = Resource(\n        capacity=self.bandwidth, label=f\"vNIC {self.label} Downlink\"\n    )\n    simulation.NICS.append(self)\n</code></pre>"},{"location":"api/physical_component/v_nic/#PyCloudSim.entity.v_nic.vNIC.creation","title":"<code>creation()</code>","text":"<p>Creation process of the vNIC</p> Source code in <code>PyCloudSim\\entity\\v_nic.py</code> <pre><code>def creation(self):\n    \"\"\"Creation process of the vNIC\"\"\"\n    return super().creation()\n</code></pre>"},{"location":"api/physical_component/v_nic/#PyCloudSim.entity.v_nic.vNIC.downlink_utilization","title":"<code>downlink_utilization(inertval=0.1)</code>","text":"<p>The downlink utilization of the vNIC in percentage.</p> Source code in <code>PyCloudSim\\entity\\v_nic.py</code> <pre><code>def downlink_utilization(self, inertval: float = 0.1) -&gt; float:\n    \"\"\"The downlink utilization of the vNIC in percentage.\"\"\"\n    return self.downlink.utilization_in_past(inertval) * 100\n</code></pre>"},{"location":"api/physical_component/v_nic/#PyCloudSim.entity.v_nic.vNIC.receive_packet","title":"<code>receive_packet(packet, delay=0.0)</code>","text":"<p>Rceive a vPacket, the vPacket will be dropped if the attached host does not have enough RAM.</p> <p>Parameters:</p> Name Type Description Default <code>packet</code> <code>vPacket</code> <p>the vPacket to be recevived.</p> required <code>delay</code> <code>float</code> <p>the delay for receiving this vPacket in term of transmitting time. Defaults to 0.0.</p> <code>0.0</code> Source code in <code>PyCloudSim\\entity\\v_nic.py</code> <pre><code>def receive_packet(self, packet: vPacket, delay: float = 0.0):\n    \"\"\"Rceive a vPacket, the vPacket will be dropped if the attached host does not have enough RAM.\n\n    Args:\n        packet (vPacket): the vPacket to be recevived.\n        delay (float, optional): the delay for receiving this vPacket in term of transmitting time. Defaults to 0.0.\n    \"\"\"\n    self.uplink.distribute(packet, packet.size)\n    LOGGER.debug(\n        f\"{simulation.now:0.2f}:\\tvPacket {packet.label} is using {packet.size}/{self.uplink.available_quantity}/{self.uplink.capacity} bytes of vNIC {self.label} uplink.\"\n    )\n\n    def _received_packet():\n        self.uplink.release(packet)\n        packet.status.remove(TRANSMITTING)\n        packet.status.remove(DECODED)\n        try:\n            self.host.cache_packet(packet)\n            LOGGER.info(\n                f\"{simulation.now:0.2f}:\\tvPacket {packet.label} is received by {self.host.__class__.__name__} {self.host.label}\"\n            )\n        except:\n            packet.drop()\n            LOGGER.info(\n                f\"{simulation.now:0.2f}:\\tvPacket {packet.label} is droped by {self.host.__class__.__name__} {self.host.label}\"\n            )\n\n    Actor(\n        at=simulation.now + delay,\n        action=_received_packet,\n        label=f\"vNIC {self.label} Receive Packet\",\n        priority=CORE_EXECUTE_PROCESS,\n    )\n</code></pre>"},{"location":"api/physical_component/v_nic/#PyCloudSim.entity.v_nic.vNIC.send_packet","title":"<code>send_packet(packet, delay=0.0)</code>","text":"<p>Send a vPacket.</p> <p>Parameters:</p> Name Type Description Default <code>packet</code> <code>vPacket</code> <p>the vPacket to be sent.</p> required <code>delay</code> <code>float</code> <p>the delay for sending this packet in term of transmitting time. Defaults to 0.0.</p> <code>0.0</code> Source code in <code>PyCloudSim\\entity\\v_nic.py</code> <pre><code>def send_packet(self, packet: vPacket, delay: float = 0.0):\n    \"\"\"Send a vPacket.\n\n    Args:\n        packet (vPacket): the vPacket to be sent.\n        delay (float, optional): the delay for sending this packet in term of transmitting time. Defaults to 0.0.\n    \"\"\"\n    self.downlink.distribute(packet, packet.size)\n    LOGGER.debug(\n        f\"{simulation.now:0.2f}:\\tvPacket {packet.label} is using {packet.size}/{self.downlink.available_quantity}/{self.downlink.capacity} bytes of vNIC {self.label} downlink.\"\n    )\n    self.host.packets.remove(packet)\n    packet.status.append(TRANSMITTING)\n    packet.status.remove(QUEUED)\n\n    def _sent_packet():\n        self.downlink.release(packet)\n        if self.host.__class__.__name__ == \"vGateway\":\n            pass\n        else:\n            self.host.ram.release(packet)  # type: ignore\n        LOGGER.info(\n            f\"{simulation.now:0.2f}:\\tvPacket {packet.label} is sent by {self.host.__class__.__name__} {self.host.label}\"\n        )\n        Actor(\n            at=simulation.now,\n            action=self.host.send_packets,\n            label=f\"{self.__class__.__name__} {self.label} Send Packets\",\n            priority=HOST_SCHEDULE_PACKET,\n        )\n\n    Actor(\n        at=simulation.now + delay,\n        action=_sent_packet,\n        label=f\"vNIC {self.label} Send Packet\",\n        priority=CORE_EXECUTE_PROCESS,\n    )\n</code></pre>"},{"location":"api/physical_component/v_nic/#PyCloudSim.entity.v_nic.vNIC.termination","title":"<code>termination()</code>","text":"<p>Termination process of the vNIC</p> Source code in <code>PyCloudSim\\entity\\v_nic.py</code> <pre><code>def termination(self):\n    \"\"\"Termination process of the vNIC\"\"\"\n    return super().termination()\n</code></pre>"},{"location":"api/physical_component/v_nic/#PyCloudSim.entity.v_nic.vNIC.uplink_utilization","title":"<code>uplink_utilization(inertval=0.1)</code>","text":"<p>The uplink utilization of the vNIC in percentage.</p> Source code in <code>PyCloudSim\\entity\\v_nic.py</code> <pre><code>def uplink_utilization(self, inertval: float = 0.1) -&gt; float:\n    \"\"\"The uplink utilization of the vNIC in percentage.\"\"\"\n    return self.uplink.utilization_in_past(inertval) * 100\n</code></pre>"},{"location":"api/physical_entity/","title":"Index","text":"<p>The <code>PhysicalEntity</code> class is the base for all simulated physical entities such as Host, Switch and Router.</p> <p>             Bases: <code>PhysicalComponent</code>, <code>ABC</code></p> Source code in <code>PyCloudSim\\entity\\v_physical_entity.py</code> <pre><code>class PhysicalEntity(PhysicalComponent, ABC):\n    _privisoned_at: float\n\n    def __init__(\n        self,\n        num_cpu_cores: int = 1,\n        ipc: Union[int, float] = 1,\n        frequency: Union[int, float] = 1000,\n        ram: int = 1,\n        rom: int = 1,\n        delay: float = 0.01,\n        idle_power=50,\n        cpu_tdp=125,\n        ram_tdp=50,\n        at: Union[int, float, Callable] = simulation.now,\n        after: Optional[Entity | List[Entity]] = None,\n        label: Optional[str] = None,\n    ):\n        super().__init__(at=at, after=after, label=label)\n        self._cpu = vCPU(\n            ipc=ipc, frequency=frequency, num_cores=num_cpu_cores, tdp=cpu_tdp\n        )\n        self._ram = Resource(\n            capacity=GiB(ram).bytes, label=f\"{self.__class__.__name__} {self.label} RAM\"\n        )\n        self._rom = Resource(\n            capacity=GiB(rom).bytes, label=f\"{self.__class__.__name__} {self.label} ROM\"\n        )\n        self._delay = delay\n        self._privisoned_at = float()\n        self._packets = list()\n        self._interfaces: List[vNIC] = list()\n        self._processes = list()\n        self._packet_scheduler: Actor = None  # type: ignore\n        self._idle_power = idle_power\n        self._ram_tdp = ram_tdp\n        simulation.topology.add_node(self)\n\n    def send_packets(self):\n        def _send_packets():\n            if len(self.packets) &gt; 0:\n                LOGGER.debug(\n                    f\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} is scheduling packets, queued packets: {len(self.packets)}.\"\n                )\n                self.packets.sort(key=lambda packet: packet.priority)\n                for packet in self.packets:\n                    if (\n                        packet.decoded\n                        and not packet.terminated\n                        and not packet.transmitting\n                    ):\n                        LOGGER.debug(\n                            f\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} is sending packet {packet.label}.\"\n                        )\n                        for s_interface in self.interfaces:\n                            if s_interface.connected_to is packet.next_hop:\n                                LOGGER.debug(\n                                    f\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} found interface {s_interface.label} for packet {packet.label}.\"\n                                )\n                                for d_interface in packet.next_hop.interfaces:\n                                    if d_interface.connected_to is self:\n                                        LOGGER.debug(\n                                            f\"{simulation.now:0.2f}:\\t{packet.next_hop.__class__.__name__} {packet.next_hop.label} found interface {d_interface.label} for packet {packet.label}.\"\n                                        )\n                                        delay = packet.size / min(\n                                            [\n                                                s_interface.bandwidth,\n                                                d_interface.bandwidth,\n                                            ]\n                                        )\n                                        if (\n                                            s_interface.downlink.available_quantity\n                                            &gt;= packet.size\n                                            and d_interface.uplink.available_quantity\n                                            &gt;= packet.size\n                                        ):\n                                            s_interface.send_packet(packet, delay)\n                                            d_interface.receive_packet(packet, delay)\n                                            LOGGER.info(\n                                                f\"{simulation.now:0.2f}:\\tvPacket {packet.label} is in transmission from {self.__class__.__name__} {self.label} to {packet.next_hop.__class__.__name__} {packet.next_hop.label}\"\n                                            )\n                                            break\n                                break\n            LOGGER.debug(\n                f\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} scheduled all packets within the queue.\"\n            )\n            self._packet_scheduler = None  # type: ignore\n\n        if self.packet_scheduler is None:\n            self._packet_scheduler = Actor(\n                at=simulation.now,\n                action=_send_packets,\n                label=f\"{self.__class__.__name__} {self.label} Send Packets\",\n                priority=HOST_SCHEDULE_PACKET,\n            )\n\n    def uplink_utilization(self, inertval: float = 0.1) -&gt; float:\n        return float(\n            sum(\n                [\n                    interface.uplink_utilization(inertval)\n                    for interface in self.interfaces\n                ]\n            )\n            / len(self.interfaces)\n        )\n\n    def downlink_utilization(self, inertval: float = 0.1) -&gt; float:\n        return float(\n            sum(\n                [\n                    interface.downlink_utilization(inertval)\n                    for interface in self.interfaces\n                ]\n            )\n            / len(self.interfaces)\n        )\n\n    def power_usage(\n        self, interval: Union[int, float] = 0.1, func: str = \"log\"\n    ) -&gt; float:\n        cpu_usage = self.cpu.utilization_in_past(interval) * 100\n        ram_usage = self.ram.utilization_in_past(interval) * 100\n        if func == \"log\":\n            cpu_power_usage = log((cpu_usage + 1), 100) * self.cpu_tdp\n            ram_power_usage = log((ram_usage + 1), 100) * self.ram_tdp\n            return cpu_power_usage + ram_power_usage + self.idle_power\n        elif func == \"linear\":\n            return (\n                (cpu_usage * self.cpu_tdp / 100)\n                + (ram_usage * self.ram_tdp / 100)\n                + self.idle_power\n            )\n        else:\n            raise ValueError(f\"Unknown power usage function: {func}\")\n\n    @property\n    def privisoned_at(self) -&gt; float:\n        return self._privisoned_at\n\n    @property\n    def privisoned(self) -&gt; bool:\n        return PRIVISIONED in self._status\n\n    @property\n    def powered_on(self) -&gt; bool:\n        return POWERED_ON in self._status\n\n    @property\n    def powered_off(self) -&gt; bool:\n        return POWERED_ON not in self._status\n\n    @property\n    def packets(self) -&gt; List[vPacket]:\n        return self._packets\n\n    @property\n    def interfaces(self) -&gt; List[vNIC]:\n        return self._interfaces\n\n    @property\n    def processes(self) -&gt; List[vProcess]:\n        return self._processes\n\n    @property\n    def cpu(self) -&gt; vCPU:\n        return self._cpu\n\n    @property\n    def ram(self) -&gt; Resource:\n        return self._ram\n\n    @property\n    def rom(self) -&gt; Resource:\n        return self._rom\n\n    @property\n    def delay(self) -&gt; float:\n        return self._delay\n\n    @property\n    def packet_scheduler(self) -&gt; Actor:\n        return self._packet_scheduler\n\n    @property\n    def idle_power(self) -&gt; float:\n        return self._idle_power\n\n    @property\n    def cpu_tdp(self) -&gt; float:\n        return self.cpu.tdp\n\n    @property\n    def ram_tdp(self) -&gt; float:\n        return self._ram_tdp\n</code></pre>"},{"location":"api/physical_entity/v_gateway/","title":"vGateway","text":"<p>The class \"vGateway\" is a unique implementation of the \"PhysicalEntity\" class. Unlike other entities, the \"vGateway\" does not possess a \"vCPU\", RAM, or ROM. Its primary role is to function as the entry point for the cloud environment, serving as the central hub for incoming and outgoing user traffic.</p> <p>The \"vGateway\" inherits all the member functions implemented for the \"vSwitch\" class, allowing it to perform routing and switching operations. However, unlike other entities, the \"vGateway\" does not create a simulated process for packet decoding upon receiving simulated packets.</p> <p>Additionally, the \"vGateway\" is designed to be linked exclusively with \"vRouter\" instances, facilitating seamless connectivity and routing between the gateway and the routers within the simulated network topology.</p> <p>             Bases: <code>PhysicalEntity</code></p> Source code in <code>PyCloudSim\\entity\\v_gateway.py</code> <pre><code>class vGateway(PhysicalEntity):\n    def __init__(\n        self,\n        at: Union[int, float, Callable] = simulation.now,\n        after: Optional[Entity | List[Entity]] = None,\n        label: Optional[str] = None,\n    ):\n        \"\"\"Create a virtual gateway, which is the entry/exit point of the simulated cluster.\n\n        Args:\n            at (Union[int, float, Callable], optional): same as the entity. Defaults to simulation.now.\n            after (Optional[Entity  |  List[Entity]], optional): same as the entity. Defaults to None.\n            label (Optional[str], optional): same as the entity. Defaults to None.\n        \"\"\"\n        super().__init__(\n            num_cpu_cores=1,\n            ipc=1,\n            frequency=1000,\n            ram=1,\n            rom=1,\n            delay=0.01,\n            at=at,\n            after=after,\n            label=label,\n        )\n\n    def creation(self):\n        \"\"\"Creation process of the virtual gateway.\"\"\"\n        return super().creation()\n\n    def termination(self):\n        \"\"\"Termination process of the virtual gateway.\"\"\"\n        return super().termination()\n\n    def _power_on(self):\n        \"\"\"Power on the virtual gateway.\"\"\"\n        super()._power_on()\n\n    def _power_off(self):\n        \"\"\"Power off the virtual gateway.\"\"\"\n        super()._power_off()\n\n    def cache_packet(self, packet: vPacket):\n        \"\"\"Cache a packet in the virtual gateway, no packet handler vProcess will be created.\"\"\"\n        self.packets.append(packet)\n        if not packet.scheduled:\n            packet.status.append(SCHEDULED)\n            packet._scheduled_at = simulation.now\n        packet.status.append(QUEUED)\n        packet.status.append(DECODED)\n        packet._current_hop = self\n        if packet.path[-1] is self:\n            packet.complete()\n        self.send_packets()\n        LOGGER.info(\n            f\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} cached packet {packet.label}.\"\n        )\n</code></pre>"},{"location":"api/physical_entity/v_gateway/#PyCloudSim.entity.v_gateway.vGateway.__init__","title":"<code>__init__(at=simulation.now, after=None, label=None)</code>","text":"<p>Create a virtual gateway, which is the entry/exit point of the simulated cluster.</p> <p>Parameters:</p> Name Type Description Default <code>at</code> <code>Union[int, float, Callable]</code> <p>same as the entity. Defaults to simulation.now.</p> <code>now</code> <code>after</code> <code>Optional[Entity | List[Entity]]</code> <p>same as the entity. Defaults to None.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>same as the entity. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_gateway.py</code> <pre><code>def __init__(\n    self,\n    at: Union[int, float, Callable] = simulation.now,\n    after: Optional[Entity | List[Entity]] = None,\n    label: Optional[str] = None,\n):\n    \"\"\"Create a virtual gateway, which is the entry/exit point of the simulated cluster.\n\n    Args:\n        at (Union[int, float, Callable], optional): same as the entity. Defaults to simulation.now.\n        after (Optional[Entity  |  List[Entity]], optional): same as the entity. Defaults to None.\n        label (Optional[str], optional): same as the entity. Defaults to None.\n    \"\"\"\n    super().__init__(\n        num_cpu_cores=1,\n        ipc=1,\n        frequency=1000,\n        ram=1,\n        rom=1,\n        delay=0.01,\n        at=at,\n        after=after,\n        label=label,\n    )\n</code></pre>"},{"location":"api/physical_entity/v_gateway/#PyCloudSim.entity.v_gateway.vGateway.cache_packet","title":"<code>cache_packet(packet)</code>","text":"<p>Cache a packet in the virtual gateway, no packet handler vProcess will be created.</p> Source code in <code>PyCloudSim\\entity\\v_gateway.py</code> <pre><code>def cache_packet(self, packet: vPacket):\n    \"\"\"Cache a packet in the virtual gateway, no packet handler vProcess will be created.\"\"\"\n    self.packets.append(packet)\n    if not packet.scheduled:\n        packet.status.append(SCHEDULED)\n        packet._scheduled_at = simulation.now\n    packet.status.append(QUEUED)\n    packet.status.append(DECODED)\n    packet._current_hop = self\n    if packet.path[-1] is self:\n        packet.complete()\n    self.send_packets()\n    LOGGER.info(\n        f\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} cached packet {packet.label}.\"\n    )\n</code></pre>"},{"location":"api/physical_entity/v_gateway/#PyCloudSim.entity.v_gateway.vGateway.creation","title":"<code>creation()</code>","text":"<p>Creation process of the virtual gateway.</p> Source code in <code>PyCloudSim\\entity\\v_gateway.py</code> <pre><code>def creation(self):\n    \"\"\"Creation process of the virtual gateway.\"\"\"\n    return super().creation()\n</code></pre>"},{"location":"api/physical_entity/v_gateway/#PyCloudSim.entity.v_gateway.vGateway.termination","title":"<code>termination()</code>","text":"<p>Termination process of the virtual gateway.</p> Source code in <code>PyCloudSim\\entity\\v_gateway.py</code> <pre><code>def termination(self):\n    \"\"\"Termination process of the virtual gateway.\"\"\"\n    return super().termination()\n</code></pre>"},{"location":"api/physical_entity/v_host/","title":"vHost","text":"<p>The <code>vHost</code> class is the implementation of simulated Host.</p> <p>             Bases: <code>PhysicalEntity</code></p> Source code in <code>PyCloudSim\\entity\\v_host.py</code> <pre><code>class vHost(PhysicalEntity):\n    def __init__(\n        self,\n        num_cpu_cores: int,\n        ipc: Union[int, float],\n        frequency: Union[int, float],\n        ram: int,\n        rom: int,\n        delay: float = 0.01,\n        taint: Optional[str] = None,\n        switch: Optional[vSwitch] = None,\n        at: Union[int, float, Callable] = simulation.now,\n        after: Optional[Entity | List[Entity]] = None,\n        label: Optional[str] = None,\n    ):\n        \"\"\"Creat a virtual host.\n\n        Args:\n            num_cpu_cores (int): number of cpu cores.\n            ipc (Union[int, float]): the instructions per cycle of the CPU.\n            frequency (Union[int, float]): the frequency of the CPU.\n            ram (int): the size of the RAM in MiB.\n            rom (int): the size of the ROM in GiB.\n            delay (float, optional): the packet processing delay. Defaults to 0.01.\n            taint (Optional[str], optional): the taint of this vHost, used during container scheduling. Defaults to None.\n            switch (Optional[vSwitch], optional): the switch this vHost is connected with. Defaults to None.\n            at (Union[int, float, Callable], optional): same as entity. Defaults to simulation.now.\n            after (Optional[Entity  |  List[Entity]], optional): same as entity. Defaults to None.\n            label (Optional[str], optional): same as entity. Defaults to None.\n        \"\"\"\n        super().__init__(\n            num_cpu_cores=num_cpu_cores,\n            ipc=ipc,\n            frequency=frequency,\n            ram=ram,\n            rom=rom,\n            delay=delay,\n            at=at,\n            after=after,\n            label=label,\n        )\n        self._cpu_reservor = Resource(\n            capacity=(num_cpu_cores * 1000),\n            label=f\"{self.__class__.__name__} {self.label} CPU reservor\",\n        )\n        self._ram_reservor = Resource(\n            capacity=(ram * 1024),\n            label=f\"{self.__class__.__name__} {self.label} RAM reservor\",\n        )\n        self._taint = taint or str()\n        self._containers = list()\n        self._volumes = list()\n        self._privisioned = False\n        self._delay = delay\n        simulation.HOSTS.append(self)\n        simulation.topology.add_node(self)\n        if switch is not None:\n            switch.connect_device(self)\n        else:\n            simulation.core_switch.connect_device(self)\n\n    def creation(self):\n        \"\"\"The creation process of the vHost.\n        \"\"\"\n        super().creation()\n        simulation.core_switch.connect_device(self)\n\n    def termination(self):\n        \"\"\"The termination process of the vHost.\n        \"\"\"\n        return super().termination()\n\n    def _power_on(self):\n        \"\"\"Power on the vHost.\"\"\"\n        super()._power_on()\n        self.cpu.power_on()\n        for interface in self.interfaces:\n            interface.power_on()\n\n    def _power_off(self):\n        \"\"\"Power off the vHost.\"\"\"\n        super()._power_off()\n        self.cpu.power_off()\n        for interface in self.interfaces:\n            interface.power_off()\n\n    def allocate_container(self, container: vContainer):\n        \"\"\"Allocate a container on the vHost.\"\"\"\n        self.containers.append(container)\n        self.cpu_reservor.distribute(container, container.cpu_request)\n        self.ram_reservor.distribute(container, container.ram_request)\n        self.rom.distribute(container, container.image_size)\n        container._host_id = self.id\n        container.status.append(SCHEDULED)\n        LOGGER.info(\n            f\"{simulation.now:0.2f}:\\tvContainer {container.label} is scheduled on vHost {self.label}.\"\n        )\n        container.init_deamon()\n        container.microservice.evaluate()\n        simulation.request_scheduler.schedule()\n\n    def allocate_volume(self, volume: vVolume):\n        \"\"\"Allocate a volume on the vHost.\"\"\"\n        self.rom.distribute(volume, volume.size)\n        self.volumes.append(volume)\n        volume._host_id = self.id\n        LOGGER.info(\n            f\"{simulation.now:0.2f}:\\tvVolume {volume.label} is allocated on vHost {self.label}.\"\n        )\n        simulation.volume_allocator.allocate()\n\n    def cache_packet(self, packet: vPacket):\n        \"\"\"Cache a packet on the vHost.\"\"\"\n        self.ram.distribute(packet, packet.size)\n        self.packets.append(packet)\n        if not packet.scheduled:\n            packet.status.append(SCHEDULED)\n            packet._scheduled_at = simulation.now\n        packet.status.append(QUEUED)\n        packet._current_hop = self\n        packet_handler = vPacketHandler(\n            length=int(self.delay * self.cpu.single_core_capacity),\n            packet=packet,\n            host=self,\n            at=simulation.now,\n        )\n        self.processes.append(packet_handler)\n        self.cpu.cache_process(packet_handler)\n        LOGGER.info(\n            f\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} cached packet {packet.label}.\"\n        )\n\n    @property\n    def taint(self) -&gt; str:\n        \"\"\"The taint of the vHost. Used during container scheduling.\"\"\"\n        return self._taint\n\n    @property\n    def containers(self) -&gt; List[Entity]:\n        \"\"\"The containers on the vHost.\"\"\"\n        return self._containers\n\n    @property\n    def volumes(self) -&gt; List[Entity]:\n        \"\"\"The volumes on the vHost.\"\"\"\n        return self._volumes\n\n    @property\n    def privisioned(self) -&gt; bool:\n        \"\"\"return True if the vHost is privisioned, False otherwise.\"\"\"\n        return self._privisioned\n\n    @property\n    def delay(self) -&gt; float:\n        \"\"\"the packet processing delay of the vHost.\"\"\"\n        return self._delay\n\n    @property\n    def cpu_reservor(self) -&gt; Resource:\n        \"\"\"the reservor of the CPU of the vHost.\"\"\"\n        return self._cpu_reservor\n\n    @property\n    def ram_reservor(self) -&gt; Resource:\n        \"\"\"the reservor of the RAM of the vHost.\"\"\"\n        return self._ram_reservor\n</code></pre>"},{"location":"api/physical_entity/v_host/#PyCloudSim.entity.v_host.vHost.containers","title":"<code>containers: List[Entity]</code>  <code>property</code>","text":"<p>The containers on the vHost.</p>"},{"location":"api/physical_entity/v_host/#PyCloudSim.entity.v_host.vHost.cpu_reservor","title":"<code>cpu_reservor: Resource</code>  <code>property</code>","text":"<p>the reservor of the CPU of the vHost.</p>"},{"location":"api/physical_entity/v_host/#PyCloudSim.entity.v_host.vHost.delay","title":"<code>delay: float</code>  <code>property</code>","text":"<p>the packet processing delay of the vHost.</p>"},{"location":"api/physical_entity/v_host/#PyCloudSim.entity.v_host.vHost.privisioned","title":"<code>privisioned: bool</code>  <code>property</code>","text":"<p>return True if the vHost is privisioned, False otherwise.</p>"},{"location":"api/physical_entity/v_host/#PyCloudSim.entity.v_host.vHost.ram_reservor","title":"<code>ram_reservor: Resource</code>  <code>property</code>","text":"<p>the reservor of the RAM of the vHost.</p>"},{"location":"api/physical_entity/v_host/#PyCloudSim.entity.v_host.vHost.taint","title":"<code>taint: str</code>  <code>property</code>","text":"<p>The taint of the vHost. Used during container scheduling.</p>"},{"location":"api/physical_entity/v_host/#PyCloudSim.entity.v_host.vHost.volumes","title":"<code>volumes: List[Entity]</code>  <code>property</code>","text":"<p>The volumes on the vHost.</p>"},{"location":"api/physical_entity/v_host/#PyCloudSim.entity.v_host.vHost.__init__","title":"<code>__init__(num_cpu_cores, ipc, frequency, ram, rom, delay=0.01, taint=None, switch=None, at=simulation.now, after=None, label=None)</code>","text":"<p>Creat a virtual host.</p> <p>Parameters:</p> Name Type Description Default <code>num_cpu_cores</code> <code>int</code> <p>number of cpu cores.</p> required <code>ipc</code> <code>Union[int, float]</code> <p>the instructions per cycle of the CPU.</p> required <code>frequency</code> <code>Union[int, float]</code> <p>the frequency of the CPU.</p> required <code>ram</code> <code>int</code> <p>the size of the RAM in MiB.</p> required <code>rom</code> <code>int</code> <p>the size of the ROM in GiB.</p> required <code>delay</code> <code>float</code> <p>the packet processing delay. Defaults to 0.01.</p> <code>0.01</code> <code>taint</code> <code>Optional[str]</code> <p>the taint of this vHost, used during container scheduling. Defaults to None.</p> <code>None</code> <code>switch</code> <code>Optional[vSwitch]</code> <p>the switch this vHost is connected with. Defaults to None.</p> <code>None</code> <code>at</code> <code>Union[int, float, Callable]</code> <p>same as entity. Defaults to simulation.now.</p> <code>now</code> <code>after</code> <code>Optional[Entity | List[Entity]]</code> <p>same as entity. Defaults to None.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>same as entity. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_host.py</code> <pre><code>def __init__(\n    self,\n    num_cpu_cores: int,\n    ipc: Union[int, float],\n    frequency: Union[int, float],\n    ram: int,\n    rom: int,\n    delay: float = 0.01,\n    taint: Optional[str] = None,\n    switch: Optional[vSwitch] = None,\n    at: Union[int, float, Callable] = simulation.now,\n    after: Optional[Entity | List[Entity]] = None,\n    label: Optional[str] = None,\n):\n    \"\"\"Creat a virtual host.\n\n    Args:\n        num_cpu_cores (int): number of cpu cores.\n        ipc (Union[int, float]): the instructions per cycle of the CPU.\n        frequency (Union[int, float]): the frequency of the CPU.\n        ram (int): the size of the RAM in MiB.\n        rom (int): the size of the ROM in GiB.\n        delay (float, optional): the packet processing delay. Defaults to 0.01.\n        taint (Optional[str], optional): the taint of this vHost, used during container scheduling. Defaults to None.\n        switch (Optional[vSwitch], optional): the switch this vHost is connected with. Defaults to None.\n        at (Union[int, float, Callable], optional): same as entity. Defaults to simulation.now.\n        after (Optional[Entity  |  List[Entity]], optional): same as entity. Defaults to None.\n        label (Optional[str], optional): same as entity. Defaults to None.\n    \"\"\"\n    super().__init__(\n        num_cpu_cores=num_cpu_cores,\n        ipc=ipc,\n        frequency=frequency,\n        ram=ram,\n        rom=rom,\n        delay=delay,\n        at=at,\n        after=after,\n        label=label,\n    )\n    self._cpu_reservor = Resource(\n        capacity=(num_cpu_cores * 1000),\n        label=f\"{self.__class__.__name__} {self.label} CPU reservor\",\n    )\n    self._ram_reservor = Resource(\n        capacity=(ram * 1024),\n        label=f\"{self.__class__.__name__} {self.label} RAM reservor\",\n    )\n    self._taint = taint or str()\n    self._containers = list()\n    self._volumes = list()\n    self._privisioned = False\n    self._delay = delay\n    simulation.HOSTS.append(self)\n    simulation.topology.add_node(self)\n    if switch is not None:\n        switch.connect_device(self)\n    else:\n        simulation.core_switch.connect_device(self)\n</code></pre>"},{"location":"api/physical_entity/v_host/#PyCloudSim.entity.v_host.vHost.allocate_container","title":"<code>allocate_container(container)</code>","text":"<p>Allocate a container on the vHost.</p> Source code in <code>PyCloudSim\\entity\\v_host.py</code> <pre><code>def allocate_container(self, container: vContainer):\n    \"\"\"Allocate a container on the vHost.\"\"\"\n    self.containers.append(container)\n    self.cpu_reservor.distribute(container, container.cpu_request)\n    self.ram_reservor.distribute(container, container.ram_request)\n    self.rom.distribute(container, container.image_size)\n    container._host_id = self.id\n    container.status.append(SCHEDULED)\n    LOGGER.info(\n        f\"{simulation.now:0.2f}:\\tvContainer {container.label} is scheduled on vHost {self.label}.\"\n    )\n    container.init_deamon()\n    container.microservice.evaluate()\n    simulation.request_scheduler.schedule()\n</code></pre>"},{"location":"api/physical_entity/v_host/#PyCloudSim.entity.v_host.vHost.allocate_volume","title":"<code>allocate_volume(volume)</code>","text":"<p>Allocate a volume on the vHost.</p> Source code in <code>PyCloudSim\\entity\\v_host.py</code> <pre><code>def allocate_volume(self, volume: vVolume):\n    \"\"\"Allocate a volume on the vHost.\"\"\"\n    self.rom.distribute(volume, volume.size)\n    self.volumes.append(volume)\n    volume._host_id = self.id\n    LOGGER.info(\n        f\"{simulation.now:0.2f}:\\tvVolume {volume.label} is allocated on vHost {self.label}.\"\n    )\n    simulation.volume_allocator.allocate()\n</code></pre>"},{"location":"api/physical_entity/v_host/#PyCloudSim.entity.v_host.vHost.cache_packet","title":"<code>cache_packet(packet)</code>","text":"<p>Cache a packet on the vHost.</p> Source code in <code>PyCloudSim\\entity\\v_host.py</code> <pre><code>def cache_packet(self, packet: vPacket):\n    \"\"\"Cache a packet on the vHost.\"\"\"\n    self.ram.distribute(packet, packet.size)\n    self.packets.append(packet)\n    if not packet.scheduled:\n        packet.status.append(SCHEDULED)\n        packet._scheduled_at = simulation.now\n    packet.status.append(QUEUED)\n    packet._current_hop = self\n    packet_handler = vPacketHandler(\n        length=int(self.delay * self.cpu.single_core_capacity),\n        packet=packet,\n        host=self,\n        at=simulation.now,\n    )\n    self.processes.append(packet_handler)\n    self.cpu.cache_process(packet_handler)\n    LOGGER.info(\n        f\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} cached packet {packet.label}.\"\n    )\n</code></pre>"},{"location":"api/physical_entity/v_host/#PyCloudSim.entity.v_host.vHost.creation","title":"<code>creation()</code>","text":"<p>The creation process of the vHost.</p> Source code in <code>PyCloudSim\\entity\\v_host.py</code> <pre><code>def creation(self):\n    \"\"\"The creation process of the vHost.\n    \"\"\"\n    super().creation()\n    simulation.core_switch.connect_device(self)\n</code></pre>"},{"location":"api/physical_entity/v_host/#PyCloudSim.entity.v_host.vHost.termination","title":"<code>termination()</code>","text":"<p>The termination process of the vHost.</p> Source code in <code>PyCloudSim\\entity\\v_host.py</code> <pre><code>def termination(self):\n    \"\"\"The termination process of the vHost.\n    \"\"\"\n    return super().termination()\n</code></pre>"},{"location":"api/physical_entity/switch_router/","title":"Index","text":"<p>The class \"vSwitch\" and \"vRouter\" are the implementation of the switch and router in the simulated network topology. \"vSwitch\" and \"vRouter\" will create a scheduling process to schedule all \"vPacket\" in the queue to \"vNIC\" for transmission based on the priority of \"vPacket\" when a \"vPacket\" arrived or has been transmitted. The scheduling process is implemented as an \"event and only one scheduling process for each \"vSwitch\" or \"vRouter\" can exist at any time. If a \"vSwitch\" or \"vRouter\" does not have enough RAM to accommodate a \"vPacket\" upon receiving it, the \"vPacket\" will be dropped. The difference between \"vSwitch\" and \"vRouter\" are:</p> <ol> <li> <p>For a \"vSwitch,\" the IP address attribute of its \"vNIC\" is set to none, and its \"vNIC\" can be connected to any entity.</p> </li> <li> <p>For a \"vRouter,\" the IP address of each of its \"vNIC\" instances must belong to a unique network and its \"vNIC\" cannot be connected to a \"vHost\" entity.</p> </li> </ol>"},{"location":"api/physical_entity/switch_router/v_router/","title":"vRouter","text":"<p>The class \"vSwitch\" and \"vRouter\" are the implementation of the switch and router in the simulated network topology. \"vSwitch\" and \"vRouter\" will create a scheduling process to schedule all \"vPacket\" in the queue to \"vNIC\" for transmission based on the priority of \"vPacket\" when a \"vPacket\" arrived or has been transmitted. The scheduling process is implemented as an \"event and only one scheduling process for each \"vSwitch\" or \"vRouter\" can exist at any time. If a \"vSwitch\" or \"vRouter\" does not have enough RAM to accommodate a \"vPacket\" upon receiving it, the \"vPacket\" will be dropped. The difference between \"vSwitch\" and \"vRouter\" are:</p> <ol> <li> <p>For a \"vSwitch,\" the IP address attribute of its \"vNIC\" is set to none, and its \"vNIC\" can be connected to any entity.</p> </li> <li> <p>For a \"vRouter,\" the IP address of each of its \"vNIC\" instances must belong to a unique network and its \"vNIC\" cannot be connected to a \"vHost\" entity.</p> </li> </ol> <p>             Bases: <code>PhysicalEntity</code></p> Source code in <code>PyCloudSim\\entity\\v_router.py</code> <pre><code>class vRouter(PhysicalEntity):\n    def __init__(\n        self,\n        ipc: Union[int, float],\n        frequency: Union[int, float],\n        num_cpu_cores: int,\n        ram: int,\n        delay: float = 0.01,\n        at: Union[int, float, Callable] = simulation.now,\n        after: Optional[Entity | List[Entity]] = None,\n        label: Optional[str] = None,\n    ):\n        \"\"\"Create a virtual router.\n\n        Args:\n            ipc (Union[int, float]): the instructions per cycle of the CPU.\n            frequency (Union[int, float]): the frequency of the CPU.\n            num_cpu_cores (int): the number of CPU cores.\n            ram (int): the amount of RAM in MiB.\n            delay (float, optional): the packet processing delay. Defaults to 0.01.\n            at (Union[int, float, Callable], optional): same as entity. Defaults to simulation.now.\n            after (Optional[Entity  |  List[Entity]], optional): same as entity. Defaults to None.\n            label (Optional[str], optional): same as entity. Defaults to None.\n        \"\"\"\n        super().__init__(\n            num_cpu_cores=num_cpu_cores,\n            ipc=ipc,\n            frequency=frequency,\n            ram=ram,\n            rom=1,\n            delay=delay,\n            at=at,\n            after=after,\n            label=label,\n        )\n\n    def creation(self):\n        \"\"\"The creation process of the vRouter\"\"\"\n        return super().creation()\n\n    def termination(self):\n        \"\"\"The termination process of the vRouter\"\"\"\n        return super().termination()\n\n    def _power_on(self):\n        \"\"\"Power on the vRouter\"\"\"\n        super()._power_on()\n        self.cpu.power_on()\n        for interface in self.interfaces:\n            interface.power_on()\n\n    def _power_off(self):\n        \"\"\"Power off the vRouter\"\"\"\n        super()._power_off()\n        self.cpu.power_off()\n        for interface in self.interfaces:\n            interface.power_off()\n\n    def connect_device(self, device: Union[vSwitch, vGateway], bandwidth: int = 1000):\n        \"\"\"Connect the vRouter to a device.\n\n        Args:\n            device (Union[vSwitch, vGateway]): the device to connect to.\n            bandwidth (int, optional): the bandwidth of this link. Defaults to 1000.\n        \"\"\"\n        def _connect_device():\n            if (\n                device.__class__.__name__ != \"vSwitch\"\n                and device.__class__.__name__ != \"vGateway\"\n            ):\n                raise TypeError(\n                    f\"Device {device.label} type {device.__class__.__name__} is not vSwitch.\"\n                )\n            elif device.__class__.__name__ == \"vSwitch\":\n                interface = vNIC(host=self, connected_to=device, bandwidth=bandwidth)\n                interface._ip = device.usable_host_address[0]  # type: ignore\n                self.interfaces.append(interface)\n                port = vNIC(host=device, connected_to=self, bandwidth=bandwidth)\n                device.interfaces.append(port)\n                simulation.topology.add_weighted_edges_from(\n                    [(self, device, min([bandwidth, interface.bandwidth]))]\n                )\n                simulation.topology.add_weighted_edges_from(\n                    [(device, self, min([bandwidth, interface.bandwidth]))]\n                )\n                LOGGER.info(\n                    f\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} connected to {device.__class__.__name__} {device.label}.\"\n                )\n            elif device.__class__.__name__ == \"vGateway\":\n                interface = vNIC(host=self, connected_to=device, bandwidth=bandwidth)\n                interface._ip = IPv4Address(\"0.0.0.0\")\n                self.interfaces.append(interface)\n                port = vNIC(host=device, connected_to=self, bandwidth=bandwidth)\n                device.interfaces.append(port)\n                simulation.topology.add_weighted_edges_from(\n                    [(self, device, min([bandwidth, interface.bandwidth]))]\n                )\n                simulation.topology.add_weighted_edges_from(\n                    [(device, self, min([bandwidth, interface.bandwidth]))]\n                )\n                LOGGER.info(\n                    f\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} connected to {device.__class__.__name__} {device.label}.\"\n                )\n\n        Actor(\n            at=simulation.now,\n            action=_connect_device,\n            label=f\"Connect {self.__class__.__name__} {self.label} to {device.__class__.__name__} {device.label}\",\n            priority=CREATION,\n        )\n\n    def cache_packet(self, packet: vPacket):\n        \"\"\"Cache a packet, this function will be automatically called by the vNIC upon receiving a packet.\n\n        Args:\n            packet (vPacket): the received packet.\n        \"\"\"\n        self.ram.distribute(packet, packet.size)\n        self.packets.append(packet)\n        if not packet.scheduled:\n            packet.status.append(SCHEDULED)\n            packet._scheduled_at = simulation.now\n        packet.status.append(QUEUED)\n        packet._current_hop = self\n        packet_handler = vPacketHandler(\n            length=int(self.delay * self.cpu.single_core_capacity),\n            packet=packet,\n            host=self,\n            at=simulation.now,\n        )\n        self.processes.append(packet_handler)\n        self.ram.distribute(packet_handler, packet_handler.length)\n        self.cpu.cache_process(packet_handler)\n        LOGGER.info(\n            f\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} cached packet {packet.label}.\"\n        )\n</code></pre>"},{"location":"api/physical_entity/switch_router/v_router/#PyCloudSim.entity.v_router.vRouter.__init__","title":"<code>__init__(ipc, frequency, num_cpu_cores, ram, delay=0.01, at=simulation.now, after=None, label=None)</code>","text":"<p>Create a virtual router.</p> <p>Parameters:</p> Name Type Description Default <code>ipc</code> <code>Union[int, float]</code> <p>the instructions per cycle of the CPU.</p> required <code>frequency</code> <code>Union[int, float]</code> <p>the frequency of the CPU.</p> required <code>num_cpu_cores</code> <code>int</code> <p>the number of CPU cores.</p> required <code>ram</code> <code>int</code> <p>the amount of RAM in MiB.</p> required <code>delay</code> <code>float</code> <p>the packet processing delay. Defaults to 0.01.</p> <code>0.01</code> <code>at</code> <code>Union[int, float, Callable]</code> <p>same as entity. Defaults to simulation.now.</p> <code>now</code> <code>after</code> <code>Optional[Entity | List[Entity]]</code> <p>same as entity. Defaults to None.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>same as entity. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_router.py</code> <pre><code>def __init__(\n    self,\n    ipc: Union[int, float],\n    frequency: Union[int, float],\n    num_cpu_cores: int,\n    ram: int,\n    delay: float = 0.01,\n    at: Union[int, float, Callable] = simulation.now,\n    after: Optional[Entity | List[Entity]] = None,\n    label: Optional[str] = None,\n):\n    \"\"\"Create a virtual router.\n\n    Args:\n        ipc (Union[int, float]): the instructions per cycle of the CPU.\n        frequency (Union[int, float]): the frequency of the CPU.\n        num_cpu_cores (int): the number of CPU cores.\n        ram (int): the amount of RAM in MiB.\n        delay (float, optional): the packet processing delay. Defaults to 0.01.\n        at (Union[int, float, Callable], optional): same as entity. Defaults to simulation.now.\n        after (Optional[Entity  |  List[Entity]], optional): same as entity. Defaults to None.\n        label (Optional[str], optional): same as entity. Defaults to None.\n    \"\"\"\n    super().__init__(\n        num_cpu_cores=num_cpu_cores,\n        ipc=ipc,\n        frequency=frequency,\n        ram=ram,\n        rom=1,\n        delay=delay,\n        at=at,\n        after=after,\n        label=label,\n    )\n</code></pre>"},{"location":"api/physical_entity/switch_router/v_router/#PyCloudSim.entity.v_router.vRouter.cache_packet","title":"<code>cache_packet(packet)</code>","text":"<p>Cache a packet, this function will be automatically called by the vNIC upon receiving a packet.</p> <p>Parameters:</p> Name Type Description Default <code>packet</code> <code>vPacket</code> <p>the received packet.</p> required Source code in <code>PyCloudSim\\entity\\v_router.py</code> <pre><code>def cache_packet(self, packet: vPacket):\n    \"\"\"Cache a packet, this function will be automatically called by the vNIC upon receiving a packet.\n\n    Args:\n        packet (vPacket): the received packet.\n    \"\"\"\n    self.ram.distribute(packet, packet.size)\n    self.packets.append(packet)\n    if not packet.scheduled:\n        packet.status.append(SCHEDULED)\n        packet._scheduled_at = simulation.now\n    packet.status.append(QUEUED)\n    packet._current_hop = self\n    packet_handler = vPacketHandler(\n        length=int(self.delay * self.cpu.single_core_capacity),\n        packet=packet,\n        host=self,\n        at=simulation.now,\n    )\n    self.processes.append(packet_handler)\n    self.ram.distribute(packet_handler, packet_handler.length)\n    self.cpu.cache_process(packet_handler)\n    LOGGER.info(\n        f\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} cached packet {packet.label}.\"\n    )\n</code></pre>"},{"location":"api/physical_entity/switch_router/v_router/#PyCloudSim.entity.v_router.vRouter.connect_device","title":"<code>connect_device(device, bandwidth=1000)</code>","text":"<p>Connect the vRouter to a device.</p> <p>Parameters:</p> Name Type Description Default <code>device</code> <code>Union[vSwitch, vGateway]</code> <p>the device to connect to.</p> required <code>bandwidth</code> <code>int</code> <p>the bandwidth of this link. Defaults to 1000.</p> <code>1000</code> Source code in <code>PyCloudSim\\entity\\v_router.py</code> <pre><code>def connect_device(self, device: Union[vSwitch, vGateway], bandwidth: int = 1000):\n    \"\"\"Connect the vRouter to a device.\n\n    Args:\n        device (Union[vSwitch, vGateway]): the device to connect to.\n        bandwidth (int, optional): the bandwidth of this link. Defaults to 1000.\n    \"\"\"\n    def _connect_device():\n        if (\n            device.__class__.__name__ != \"vSwitch\"\n            and device.__class__.__name__ != \"vGateway\"\n        ):\n            raise TypeError(\n                f\"Device {device.label} type {device.__class__.__name__} is not vSwitch.\"\n            )\n        elif device.__class__.__name__ == \"vSwitch\":\n            interface = vNIC(host=self, connected_to=device, bandwidth=bandwidth)\n            interface._ip = device.usable_host_address[0]  # type: ignore\n            self.interfaces.append(interface)\n            port = vNIC(host=device, connected_to=self, bandwidth=bandwidth)\n            device.interfaces.append(port)\n            simulation.topology.add_weighted_edges_from(\n                [(self, device, min([bandwidth, interface.bandwidth]))]\n            )\n            simulation.topology.add_weighted_edges_from(\n                [(device, self, min([bandwidth, interface.bandwidth]))]\n            )\n            LOGGER.info(\n                f\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} connected to {device.__class__.__name__} {device.label}.\"\n            )\n        elif device.__class__.__name__ == \"vGateway\":\n            interface = vNIC(host=self, connected_to=device, bandwidth=bandwidth)\n            interface._ip = IPv4Address(\"0.0.0.0\")\n            self.interfaces.append(interface)\n            port = vNIC(host=device, connected_to=self, bandwidth=bandwidth)\n            device.interfaces.append(port)\n            simulation.topology.add_weighted_edges_from(\n                [(self, device, min([bandwidth, interface.bandwidth]))]\n            )\n            simulation.topology.add_weighted_edges_from(\n                [(device, self, min([bandwidth, interface.bandwidth]))]\n            )\n            LOGGER.info(\n                f\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} connected to {device.__class__.__name__} {device.label}.\"\n            )\n\n    Actor(\n        at=simulation.now,\n        action=_connect_device,\n        label=f\"Connect {self.__class__.__name__} {self.label} to {device.__class__.__name__} {device.label}\",\n        priority=CREATION,\n    )\n</code></pre>"},{"location":"api/physical_entity/switch_router/v_router/#PyCloudSim.entity.v_router.vRouter.creation","title":"<code>creation()</code>","text":"<p>The creation process of the vRouter</p> Source code in <code>PyCloudSim\\entity\\v_router.py</code> <pre><code>def creation(self):\n    \"\"\"The creation process of the vRouter\"\"\"\n    return super().creation()\n</code></pre>"},{"location":"api/physical_entity/switch_router/v_router/#PyCloudSim.entity.v_router.vRouter.termination","title":"<code>termination()</code>","text":"<p>The termination process of the vRouter</p> Source code in <code>PyCloudSim\\entity\\v_router.py</code> <pre><code>def termination(self):\n    \"\"\"The termination process of the vRouter\"\"\"\n    return super().termination()\n</code></pre>"},{"location":"api/physical_entity/switch_router/v_switch/","title":"vSwitch","text":"<p>The class \"vSwitch\" and \"vRouter\" are the implementation of the switch and router in the simulated network topology. \"vSwitch\" and \"vRouter\" will create a scheduling process to schedule all \"vPacket\" in the queue to \"vNIC\" for transmission based on the priority of \"vPacket\" when a \"vPacket\" arrived or has been transmitted. The scheduling process is implemented as an \"event and only one scheduling process for each \"vSwitch\" or \"vRouter\" can exist at any time. If a \"vSwitch\" or \"vRouter\" does not have enough RAM to accommodate a \"vPacket\" upon receiving it, the \"vPacket\" will be dropped. The difference between \"vSwitch\" and \"vRouter\" are:</p> <ol> <li> <p>For a \"vSwitch,\" the IP address attribute of its \"vNIC\" is set to none, and its \"vNIC\" can be connected to any entity.</p> </li> <li> <p>For a \"vRouter,\" the IP address of each of its \"vNIC\" instances must belong to a unique network and its \"vNIC\" cannot be connected to a \"vHost\" entity.</p> </li> </ol> <p>             Bases: <code>PhysicalEntity</code></p> Source code in <code>PyCloudSim\\entity\\v_switch.py</code> <pre><code>class vSwitch(PhysicalEntity):\n    def __init__(\n        self,\n        ipc: Union[int, float],\n        frequency: Union[int, float],\n        num_cpu_cores: int,\n        ram: int,\n        subnet: str,\n        delay: float = 0.01,\n        at: Union[int, float, Callable] = simulation.now,\n        after: Optional[Entity | List[Entity]] = None,\n        label: Optional[str] = None,\n    ):\n        \"\"\"Create a virtual switch.\n\n        Args:\n            ipc (Union[int, float]): the instructions per cycle of the CPU.\n            frequency (Union[int, float]): the frequency of the CPU.\n            num_cpu_cores (int): the number of CPU cores.\n            ram (int): the amount of RAM in MiB.\n            subnet (str): the subnet of the switch.\n            delay (float, optional): the packet proccessing dekay. Defaults to 0.01.\n            at (Union[int, float, Callable], optional): same as entity. Defaults to simulation.now.\n            after (Optional[Entity  |  List[Entity]], optional): same as entity. Defaults to None.\n            label (Optional[str], optional): same as entity. Defaults to None.\n        \"\"\"\n        super().__init__(\n            num_cpu_cores=num_cpu_cores,\n            ipc=ipc,\n            frequency=frequency,\n            ram=ram,\n            rom=1,\n            delay=delay,\n            at=at,\n            after=after,\n            label=label,\n        )\n        self._subnet = IPv4Network(subnet)\n        self._usable_host_address = list(self.subnet.hosts())\n        simulation.SWITCHES.append(self)\n\n    def creation(self):\n        \"\"\"Creation process of the vSwitch.\n        \"\"\"\n        return super().creation()\n\n    def termination(self):\n        \"\"\"Termination process of the vSwitch.\n        \"\"\"\n        return super().termination()\n\n    def _power_on(self):\n        \"\"\"Power on process of the vSwitch.\"\"\"\n        super()._power_on()\n        self.cpu.power_on()\n        for interface in self.interfaces:\n            interface.power_on()\n\n    def _power_off(self):\n        \"\"\"Power off process of the vSwitch.\"\"\"\n        super()._power_off()\n        self.cpu.power_off()\n        for interface in self.interfaces:\n            interface.power_off()\n\n    def connect_device(self, device: Union[vHost, vRouter], bandwidth: int = 1000):\n        \"\"\"Connect a device to the vSwitch. A new vNIC will be created as a \"Port\" of the switch.\n\n        Args:\n            device (Union[vHost, vRouter]): the device to connect to the switch.\n            bandwidth (int, optional): the bandwidth of this link. Defaults to 1000.\n        \"\"\"\n        def _connect_device():\n            port = vNIC(host=self, connected_to=device, bandwidth=bandwidth)\n            self.interfaces.append(port)\n            if device.__class__.__name__ == \"vHost\":\n                interface = vNIC(host=device, connected_to=self, bandwidth=bandwidth)\n                chosen_ip = choice(self.usable_host_address[1:-1])\n                interface._ip = chosen_ip\n                device.interfaces.append(interface)\n                device.interfaces.append(interface)\n                simulation.topology.add_weighted_edges_from(\n                    [(self, device, min([bandwidth, interface.bandwidth]))]\n                )\n                simulation.topology.add_weighted_edges_from(\n                    [(device, self, min([bandwidth, interface.bandwidth]))]\n                )\n            elif device.__class__.__name__ == \"vRouter\":\n                interface = vNIC(host=device, connected_to=self, bandwidth=bandwidth)\n                interface._ip = self.usable_host_address[0]\n                device.interfaces.append(interface)\n                simulation.topology.add_weighted_edges_from(\n                    [(self, device, min([bandwidth, interface.bandwidth]))]\n                )\n                simulation.topology.add_weighted_edges_from(\n                    [(device, self, min([bandwidth, interface.bandwidth]))]\n                )\n            else:\n                raise TypeError(\n                    f\"Device {device.label} type {device.__class__.__name__} is not vHost or vRouter.\"\n                )\n            LOGGER.info(\n                f\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} connected to {device.__class__.__name__} {device.label}.\"\n            )\n\n        Actor(\n            at=simulation.now,\n            action=_connect_device,\n            label=f\"Connect {self.__class__.__name__} {self.label} to {device.__class__.__name__} {device.label}\",\n            priority=CREATION,\n        )\n\n    def cache_packet(self, packet: vPacket):\n        \"\"\"Cache a packet and engage the packet processing. This function is automatically called by the vNIC upon receiving any packet.\n\n        Args:\n            packet (vPacket): _description_\n        \"\"\"\n        self.ram.distribute(packet, packet.size) \n        self.packets.append(packet)\n        if not packet.scheduled:\n            packet.status.append(SCHEDULED)\n            packet._scheduled_at = simulation.now\n        packet.status.append(QUEUED)\n        packet._current_hop = self\n        packet_handler = vPacketHandler(\n            length=int(self.delay * self.cpu.single_core_capacity),\n            packet=packet,\n            host=self,\n            at=simulation.now\n        )\n        self.processes.append(packet_handler)\n        self.ram.distribute(packet_handler, packet_handler.length)\n        self.cpu.cache_process(packet_handler)\n        LOGGER.info(\n            f\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} cached packet {packet.label}.\"\n        )\n\n    @property\n    def cpu(self) -&gt; vCPU:\n        \"\"\"returns the CPU of the vSwitch.\"\"\"\n        return self._cpu\n\n    @property\n    def ram(self) -&gt; Resource:\n        \"\"\"returns the RAM of the vSwitch.\"\"\"\n        return self._ram\n\n    @property\n    def subnet(self) -&gt; IPv4Network:\n        \"\"\"returns the subnet of the vSwitch.\"\"\"\n        return self._subnet\n\n    @property\n    def usable_host_address(self) -&gt; List[IPv4Address]:\n        \"\"\"returns the usable host addresses of the vSwitch.\"\"\"\n        return self._usable_host_address\n\n    @property\n    def delay(self) -&gt; float:\n        \"\"\"returns the packet processing delay of the vSwitch.\"\"\"\n        return self._delay\n</code></pre>"},{"location":"api/physical_entity/switch_router/v_switch/#PyCloudSim.entity.v_switch.vSwitch.cpu","title":"<code>cpu: vCPU</code>  <code>property</code>","text":"<p>returns the CPU of the vSwitch.</p>"},{"location":"api/physical_entity/switch_router/v_switch/#PyCloudSim.entity.v_switch.vSwitch.delay","title":"<code>delay: float</code>  <code>property</code>","text":"<p>returns the packet processing delay of the vSwitch.</p>"},{"location":"api/physical_entity/switch_router/v_switch/#PyCloudSim.entity.v_switch.vSwitch.ram","title":"<code>ram: Resource</code>  <code>property</code>","text":"<p>returns the RAM of the vSwitch.</p>"},{"location":"api/physical_entity/switch_router/v_switch/#PyCloudSim.entity.v_switch.vSwitch.subnet","title":"<code>subnet: IPv4Network</code>  <code>property</code>","text":"<p>returns the subnet of the vSwitch.</p>"},{"location":"api/physical_entity/switch_router/v_switch/#PyCloudSim.entity.v_switch.vSwitch.usable_host_address","title":"<code>usable_host_address: List[IPv4Address]</code>  <code>property</code>","text":"<p>returns the usable host addresses of the vSwitch.</p>"},{"location":"api/physical_entity/switch_router/v_switch/#PyCloudSim.entity.v_switch.vSwitch.__init__","title":"<code>__init__(ipc, frequency, num_cpu_cores, ram, subnet, delay=0.01, at=simulation.now, after=None, label=None)</code>","text":"<p>Create a virtual switch.</p> <p>Parameters:</p> Name Type Description Default <code>ipc</code> <code>Union[int, float]</code> <p>the instructions per cycle of the CPU.</p> required <code>frequency</code> <code>Union[int, float]</code> <p>the frequency of the CPU.</p> required <code>num_cpu_cores</code> <code>int</code> <p>the number of CPU cores.</p> required <code>ram</code> <code>int</code> <p>the amount of RAM in MiB.</p> required <code>subnet</code> <code>str</code> <p>the subnet of the switch.</p> required <code>delay</code> <code>float</code> <p>the packet proccessing dekay. Defaults to 0.01.</p> <code>0.01</code> <code>at</code> <code>Union[int, float, Callable]</code> <p>same as entity. Defaults to simulation.now.</p> <code>now</code> <code>after</code> <code>Optional[Entity | List[Entity]]</code> <p>same as entity. Defaults to None.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>same as entity. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_switch.py</code> <pre><code>def __init__(\n    self,\n    ipc: Union[int, float],\n    frequency: Union[int, float],\n    num_cpu_cores: int,\n    ram: int,\n    subnet: str,\n    delay: float = 0.01,\n    at: Union[int, float, Callable] = simulation.now,\n    after: Optional[Entity | List[Entity]] = None,\n    label: Optional[str] = None,\n):\n    \"\"\"Create a virtual switch.\n\n    Args:\n        ipc (Union[int, float]): the instructions per cycle of the CPU.\n        frequency (Union[int, float]): the frequency of the CPU.\n        num_cpu_cores (int): the number of CPU cores.\n        ram (int): the amount of RAM in MiB.\n        subnet (str): the subnet of the switch.\n        delay (float, optional): the packet proccessing dekay. Defaults to 0.01.\n        at (Union[int, float, Callable], optional): same as entity. Defaults to simulation.now.\n        after (Optional[Entity  |  List[Entity]], optional): same as entity. Defaults to None.\n        label (Optional[str], optional): same as entity. Defaults to None.\n    \"\"\"\n    super().__init__(\n        num_cpu_cores=num_cpu_cores,\n        ipc=ipc,\n        frequency=frequency,\n        ram=ram,\n        rom=1,\n        delay=delay,\n        at=at,\n        after=after,\n        label=label,\n    )\n    self._subnet = IPv4Network(subnet)\n    self._usable_host_address = list(self.subnet.hosts())\n    simulation.SWITCHES.append(self)\n</code></pre>"},{"location":"api/physical_entity/switch_router/v_switch/#PyCloudSim.entity.v_switch.vSwitch.cache_packet","title":"<code>cache_packet(packet)</code>","text":"<p>Cache a packet and engage the packet processing. This function is automatically called by the vNIC upon receiving any packet.</p> <p>Parameters:</p> Name Type Description Default <code>packet</code> <code>vPacket</code> <p>description</p> required Source code in <code>PyCloudSim\\entity\\v_switch.py</code> <pre><code>def cache_packet(self, packet: vPacket):\n    \"\"\"Cache a packet and engage the packet processing. This function is automatically called by the vNIC upon receiving any packet.\n\n    Args:\n        packet (vPacket): _description_\n    \"\"\"\n    self.ram.distribute(packet, packet.size) \n    self.packets.append(packet)\n    if not packet.scheduled:\n        packet.status.append(SCHEDULED)\n        packet._scheduled_at = simulation.now\n    packet.status.append(QUEUED)\n    packet._current_hop = self\n    packet_handler = vPacketHandler(\n        length=int(self.delay * self.cpu.single_core_capacity),\n        packet=packet,\n        host=self,\n        at=simulation.now\n    )\n    self.processes.append(packet_handler)\n    self.ram.distribute(packet_handler, packet_handler.length)\n    self.cpu.cache_process(packet_handler)\n    LOGGER.info(\n        f\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} cached packet {packet.label}.\"\n    )\n</code></pre>"},{"location":"api/physical_entity/switch_router/v_switch/#PyCloudSim.entity.v_switch.vSwitch.connect_device","title":"<code>connect_device(device, bandwidth=1000)</code>","text":"<p>Connect a device to the vSwitch. A new vNIC will be created as a \"Port\" of the switch.</p> <p>Parameters:</p> Name Type Description Default <code>device</code> <code>Union[vHost, vRouter]</code> <p>the device to connect to the switch.</p> required <code>bandwidth</code> <code>int</code> <p>the bandwidth of this link. Defaults to 1000.</p> <code>1000</code> Source code in <code>PyCloudSim\\entity\\v_switch.py</code> <pre><code>def connect_device(self, device: Union[vHost, vRouter], bandwidth: int = 1000):\n    \"\"\"Connect a device to the vSwitch. A new vNIC will be created as a \"Port\" of the switch.\n\n    Args:\n        device (Union[vHost, vRouter]): the device to connect to the switch.\n        bandwidth (int, optional): the bandwidth of this link. Defaults to 1000.\n    \"\"\"\n    def _connect_device():\n        port = vNIC(host=self, connected_to=device, bandwidth=bandwidth)\n        self.interfaces.append(port)\n        if device.__class__.__name__ == \"vHost\":\n            interface = vNIC(host=device, connected_to=self, bandwidth=bandwidth)\n            chosen_ip = choice(self.usable_host_address[1:-1])\n            interface._ip = chosen_ip\n            device.interfaces.append(interface)\n            device.interfaces.append(interface)\n            simulation.topology.add_weighted_edges_from(\n                [(self, device, min([bandwidth, interface.bandwidth]))]\n            )\n            simulation.topology.add_weighted_edges_from(\n                [(device, self, min([bandwidth, interface.bandwidth]))]\n            )\n        elif device.__class__.__name__ == \"vRouter\":\n            interface = vNIC(host=device, connected_to=self, bandwidth=bandwidth)\n            interface._ip = self.usable_host_address[0]\n            device.interfaces.append(interface)\n            simulation.topology.add_weighted_edges_from(\n                [(self, device, min([bandwidth, interface.bandwidth]))]\n            )\n            simulation.topology.add_weighted_edges_from(\n                [(device, self, min([bandwidth, interface.bandwidth]))]\n            )\n        else:\n            raise TypeError(\n                f\"Device {device.label} type {device.__class__.__name__} is not vHost or vRouter.\"\n            )\n        LOGGER.info(\n            f\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} connected to {device.__class__.__name__} {device.label}.\"\n        )\n\n    Actor(\n        at=simulation.now,\n        action=_connect_device,\n        label=f\"Connect {self.__class__.__name__} {self.label} to {device.__class__.__name__} {device.label}\",\n        priority=CREATION,\n    )\n</code></pre>"},{"location":"api/physical_entity/switch_router/v_switch/#PyCloudSim.entity.v_switch.vSwitch.creation","title":"<code>creation()</code>","text":"<p>Creation process of the vSwitch.</p> Source code in <code>PyCloudSim\\entity\\v_switch.py</code> <pre><code>def creation(self):\n    \"\"\"Creation process of the vSwitch.\n    \"\"\"\n    return super().creation()\n</code></pre>"},{"location":"api/physical_entity/switch_router/v_switch/#PyCloudSim.entity.v_switch.vSwitch.termination","title":"<code>termination()</code>","text":"<p>Termination process of the vSwitch.</p> Source code in <code>PyCloudSim\\entity\\v_switch.py</code> <pre><code>def termination(self):\n    \"\"\"Termination process of the vSwitch.\n    \"\"\"\n    return super().termination()\n</code></pre>"},{"location":"api/scheduler/container_scheduler/","title":"Container Scheduler","text":"<p>The \"ContainerScheduler\" class is responsible for allocating suitable \"vHost\" instances to \"vContainer\" instances based on the available CPU and RAM resources. The scheduling process is implemented as an event that is triggered whenever a new \"vContainer\" is created or a \"vContainer\" is terminated. Only one scheduling process can exist at any time during the simulation.</p> <p>The \"ContainerScheduler\" class includes an abstract member function called \"findHost\", which allows developers to customize the conditions for determining which \"vHost\" instances are eligible for hosting a specific \"vContainer\". By implementing the \"findHost\" function, different scheduling strategies can be employed based on specific requirements and constraints.</p> <p>PyCloudSim provides several default schedulers that can be used with the \"ContainerScheduler\" class:</p> <ol> <li>\"Bestfit\" scheduler: This scheduler finds the most utilized \"vHost\" instance that still has available resources to host the \"vContainer\" being scheduled.</li> <li>\"Worstfit\" scheduler: This scheduler finds the most underutilized \"vHost\" instance that still has available resources to host the \"vContainer\" being scheduled.</li> <li>\"Random\" scheduler: This scheduler allocates the \"vContainer\" to a random \"vHost\" instance that has sufficient resources.</li> </ol> <p>Only one \"ContainerScheduler\" can be defined and used in the simulation. If multiple \"ContainerScheduler\" instances are initialized, the last one defined will be used during the simulation.</p> <p>The general procedure followed by the \"ContainerScheduler\" involves evaluating the available resources of each \"vHost\" instance and selecting the most suitable \"vHost\" to host the \"vContainer\" based on the defined scheduling strategy. This process ensures efficient resource allocation and utilization in the simulated cloud environment.</p>"},{"location":"api/scheduler/container_scheduler/#PyCloudSim.scheduler.container_scheduler.ContainerScheduler","title":"<code>ContainerScheduler</code>","text":"<p>             Bases: <code>ABC</code></p> Source code in <code>PyCloudSim\\scheduler\\container_scheduler.py</code> <pre><code>class ContainerScheduler(ABC):\n    __host_affinity: bool\n\n    def __init__(\n        self,\n        host_affinity: bool = False,\n    ) -&gt; None:\n        \"\"\"Base class for container schedulers.\n\n        Args:\n            host_affinity (bool, optional): set to true for host affinity scheduling, that the host and container must have the same taint. Defaults to False.\n        \"\"\"        \n        self._host_affinity = host_affinity\n        self._active_process: Actor = None  # type: ignore\n        simulation._container_scheduler = self\n\n    @abstractmethod\n    def find_host(self, container: vContainer) -&gt; Union[vHost, None]:\n        \"\"\"Abstract function to be implemented with your specific container scheduling algorithm.\"\"\"\n        pass\n\n    def schedule(self):\n        \"\"\"Event function to be called by the simulation engine to schedule containers. find_host() is called automatically by this function.\"\"\"\n        def _schedule():\n            self._active_process = None  # type: ignore\n            for container in simulation.CONTAINERS:\n                if (\n                    container.scheduled\n                    or container.terminated\n                    or not container.schedulable\n                ):\n                    continue\n\n                if candidate_host := self.find_host(container):\n                    candidate_host.allocate_container(container)\n\n                if not container.scheduled:\n                    LOGGER.info(\n                        f\"{simulation.now:0.2f}\\tvContainer {container.label} can not be shceduled, privisioning new vHost if possible.\"\n                    )\n                    if self.host_affinity:\n                        for host in simulation.HOSTS:\n                            if host.taint == container.taint:\n                                simulation.host_privisioner.privision(host)\n\n                    else:\n                        for host in simulation.HOSTS:\n                            if host.powered_off:\n                                simulation.host_privisioner.privision(host)\n\n        if self.active_process is None:\n            self._active_process = Actor(\n                at=simulation.now,\n                action=_schedule,\n                label=f\"vContainer Scheduling\",\n                priority=CONTAINER_SCHEDULER,\n            )\n\n    @property\n    def host_affinity(self) -&gt; bool:\n        \"\"\"returns True if host affinity is enabled, False otherwise.\"\"\"\n        return self._host_affinity\n\n    @property\n    def active_process(self) -&gt; Actor:\n        \"\"\"returns the active process of the scheduler.\"\"\"\n        return self._active_process\n</code></pre>"},{"location":"api/scheduler/container_scheduler/#PyCloudSim.scheduler.container_scheduler.ContainerScheduler.active_process","title":"<code>active_process: Actor</code>  <code>property</code>","text":"<p>returns the active process of the scheduler.</p>"},{"location":"api/scheduler/container_scheduler/#PyCloudSim.scheduler.container_scheduler.ContainerScheduler.host_affinity","title":"<code>host_affinity: bool</code>  <code>property</code>","text":"<p>returns True if host affinity is enabled, False otherwise.</p>"},{"location":"api/scheduler/container_scheduler/#PyCloudSim.scheduler.container_scheduler.ContainerScheduler.__init__","title":"<code>__init__(host_affinity=False)</code>","text":"<p>Base class for container schedulers.</p> <p>Parameters:</p> Name Type Description Default <code>host_affinity</code> <code>bool</code> <p>set to true for host affinity scheduling, that the host and container must have the same taint. Defaults to False.</p> <code>False</code> Source code in <code>PyCloudSim\\scheduler\\container_scheduler.py</code> <pre><code>def __init__(\n    self,\n    host_affinity: bool = False,\n) -&gt; None:\n    \"\"\"Base class for container schedulers.\n\n    Args:\n        host_affinity (bool, optional): set to true for host affinity scheduling, that the host and container must have the same taint. Defaults to False.\n    \"\"\"        \n    self._host_affinity = host_affinity\n    self._active_process: Actor = None  # type: ignore\n    simulation._container_scheduler = self\n</code></pre>"},{"location":"api/scheduler/container_scheduler/#PyCloudSim.scheduler.container_scheduler.ContainerScheduler.find_host","title":"<code>find_host(container)</code>  <code>abstractmethod</code>","text":"<p>Abstract function to be implemented with your specific container scheduling algorithm.</p> Source code in <code>PyCloudSim\\scheduler\\container_scheduler.py</code> <pre><code>@abstractmethod\ndef find_host(self, container: vContainer) -&gt; Union[vHost, None]:\n    \"\"\"Abstract function to be implemented with your specific container scheduling algorithm.\"\"\"\n    pass\n</code></pre>"},{"location":"api/scheduler/container_scheduler/#PyCloudSim.scheduler.container_scheduler.ContainerScheduler.schedule","title":"<code>schedule()</code>","text":"<p>Event function to be called by the simulation engine to schedule containers. find_host() is called automatically by this function.</p> Source code in <code>PyCloudSim\\scheduler\\container_scheduler.py</code> <pre><code>def schedule(self):\n    \"\"\"Event function to be called by the simulation engine to schedule containers. find_host() is called automatically by this function.\"\"\"\n    def _schedule():\n        self._active_process = None  # type: ignore\n        for container in simulation.CONTAINERS:\n            if (\n                container.scheduled\n                or container.terminated\n                or not container.schedulable\n            ):\n                continue\n\n            if candidate_host := self.find_host(container):\n                candidate_host.allocate_container(container)\n\n            if not container.scheduled:\n                LOGGER.info(\n                    f\"{simulation.now:0.2f}\\tvContainer {container.label} can not be shceduled, privisioning new vHost if possible.\"\n                )\n                if self.host_affinity:\n                    for host in simulation.HOSTS:\n                        if host.taint == container.taint:\n                            simulation.host_privisioner.privision(host)\n\n                else:\n                    for host in simulation.HOSTS:\n                        if host.powered_off:\n                            simulation.host_privisioner.privision(host)\n\n    if self.active_process is None:\n        self._active_process = Actor(\n            at=simulation.now,\n            action=_schedule,\n            label=f\"vContainer Scheduling\",\n            priority=CONTAINER_SCHEDULER,\n        )\n</code></pre>"},{"location":"api/scheduler/container_scheduler/#PyCloudSim.scheduler.container_scheduler.ContainerSchedulerBestfit","title":"<code>ContainerSchedulerBestfit</code>","text":"<p>             Bases: <code>ContainerScheduler</code></p> <p>Bestfit container scheduler, that finds the fullest host for the container based on the available resources of the host.</p> Source code in <code>PyCloudSim\\scheduler\\container_scheduler.py</code> <pre><code>class ContainerSchedulerBestfit(ContainerScheduler):\n    \"\"\"Bestfit container scheduler, that finds the fullest host for the container based on the available resources of the host.\n    \"\"\"\n    def find_host(self, container: vContainer) -&gt; vHost | None:\n        if self._host_affinity:\n            candidate_host = [host for host in simulation.HOSTS if host.taint == container.taint and host.powered_on]\n            candidate_host.sort(key=lambda host: host.ram.utilization)\n            candidate_host.sort(key=lambda host: host.cpu.utilization)\n            for host in candidate_host:\n                if (\n                    host.cpu_reservor.available_quantity &gt;= container.cpu_request\n                    and host.ram_reservor.available_quantity\n                    &gt;= container.ram_request\n                    and host.rom.available_quantity &gt;= container.image_size\n                ):\n                    LOGGER.debug(\n                        f\"{simulation.now:0.2f}\\tFound vHost {host.label} {host.cpu.availablity} CPU, {host.ram.available_quantity} RAM, {host.rom.available_quantity} ROM for vContainer {container.label} {container.cpu_request} CPU, {container.ram_request} RAM, {container.image_size} ROM\"\n                    )\n                    return host\n        else:\n            simulation.HOSTS.sort(key=lambda host: host.ram.utilization)\n            simulation.HOSTS.sort(key=lambda host: host.cpu.utilization)\n            for host in simulation.HOSTS:\n                if host.powered_on:\n                    if (\n                        host.cpu_reservor.available_quantity &gt;= container.cpu_request\n                        and host.ram_reservor.available_quantity\n                        &gt;= container.ram_request\n                        and host.rom.available_quantity &gt;= container.image_size\n                    ):\n                        LOGGER.debug(\n                            f\"{simulation.now:0.2f}\\tFound vHost {host.label} {host.cpu_reservor.available_quantity} CPU, {host.ram_reservor.available_quantity} RAM, {host.rom.available_quantity} ROM for vContainer {container.label} {container.cpu_request} CPU, {container.ram_request} RAM, {container.image_size} ROM\"\n                        )\n                        return host\n\n        return None\n</code></pre>"},{"location":"api/scheduler/container_scheduler/#PyCloudSim.scheduler.container_scheduler.ContainerSchedulerRandom","title":"<code>ContainerSchedulerRandom</code>","text":"<p>             Bases: <code>ContainerScheduler</code></p> <p>Worstfit container scheduler, that finds the most empty host for the container based on the available resources of the host.</p> Source code in <code>PyCloudSim\\scheduler\\container_scheduler.py</code> <pre><code>class ContainerSchedulerRandom(ContainerScheduler):\n    \"\"\"Worstfit container scheduler, that finds the most empty host for the container based on the available resources of the host.\n    \"\"\"\n    def find_host(self, container: vContainer) -&gt; vHost | None:\n        if self._host_affinity:\n            candidate_host = [host for host in simulation.HOSTS if host.taint == container.taint and host.powered_on]\n            random.shuffle(candidate_host)\n            for host in candidate_host:\n                if (\n                    host.cpu_reservor.available_quantity &gt;= container.cpu_request\n                    and host.ram_reservor.available_quantity\n                    &gt;= container.ram_request\n                    and host.rom.available_quantity &gt;= container.image_size\n                ):\n                    LOGGER.debug(\n                        f\"{simulation.now:0.2f}\\tFound vHost {host.label} {host.cpu.availablity} CPU, {host.ram.available_quantity} RAM, {host.rom.available_quantity} ROM for vContainer {container.label} {container.cpu_request} CPU, {container.ram_request} RAM, {container.image_size} ROM\"\n                    )\n                    return host\n        else:\n            random.shuffle(simulation.HOSTS)\n            for host in simulation.HOSTS:\n                if host.powered_on:\n                    if (\n                        host.cpu_reservor.available_quantity &gt;= container.cpu_request\n                        and host.ram_reservor.available_quantity\n                        &gt;= container.ram_request\n                        and host.rom.available_quantity &gt;= container.image_size\n                    ):\n                        LOGGER.debug(\n                            f\"{simulation.now:0.2f}\\tFound vHost {host.label} {host.cpu_reservor.available_quantity} CPU, {host.ram_reservor.available_quantity} RAM, {host.rom.available_quantity} ROM for vContainer {container.label} {container.cpu_request} CPU, {container.ram_request} RAM, {container.image_size} ROM\"\n                        )\n                        return host\n\n        return None\n</code></pre>"},{"location":"api/scheduler/container_scheduler/#PyCloudSim.scheduler.container_scheduler.ContainerSchedulerWorstfit","title":"<code>ContainerSchedulerWorstfit</code>","text":"<p>             Bases: <code>ContainerScheduler</code></p> <p>Worstfit container scheduler, that finds the most empty host for the container based on the available resources of the host.</p> Source code in <code>PyCloudSim\\scheduler\\container_scheduler.py</code> <pre><code>class ContainerSchedulerWorstfit(ContainerScheduler):\n    \"\"\"Worstfit container scheduler, that finds the most empty host for the container based on the available resources of the host.\n    \"\"\"\n    def find_host(self, container: vContainer) -&gt; vHost | None:\n        if self._host_affinity:\n            candidate_host = [host for host in simulation.HOSTS if host.taint == container.taint and host.powered_on]\n            candidate_host.sort(key=lambda host: host.ram.utilization, reverse=True)\n            candidate_host.sort(key=lambda host: host.cpu.utilization, reverse=True)\n            for host in candidate_host:\n                if (\n                    host.cpu_reservor.available_quantity &gt;= container.cpu_request\n                    and host.ram_reservor.available_quantity\n                    &gt;= container.ram_request\n                    and host.rom.available_quantity &gt;= container.image_size\n                ):\n                    LOGGER.debug(\n                        f\"{simulation.now:0.2f}\\tFound vHost {host.label} {host.cpu.availablity} CPU, {host.ram.available_quantity} RAM, {host.rom.available_quantity} ROM for vContainer {container.label} {container.cpu_request} CPU, {container.ram_request} RAM, {container.image_size} ROM\"\n                    )\n                    return host\n        else:\n            simulation.HOSTS.sort(key=lambda host: host.ram.utilization, reverse=True)\n            simulation.HOSTS.sort(key=lambda host: host.cpu.utilization, reverse=True)\n            for host in simulation.HOSTS:\n                if host.powered_on:\n                    if (\n                        host.cpu_reservor.available_quantity &gt;= container.cpu_request\n                        and host.ram_reservor.available_quantity\n                        &gt;= container.ram_request\n                        and host.rom.available_quantity &gt;= container.image_size\n                    ):\n                        LOGGER.debug(\n                            f\"{simulation.now:0.2f}\\tFound vHost {host.label} {host.cpu_reservor.available_quantity} CPU, {host.ram_reservor.available_quantity} RAM, {host.rom.available_quantity} ROM for vContainer {container.label} {container.cpu_request} CPU, {container.ram_request} RAM, {container.image_size} ROM\"\n                        )\n                        return host\n\n        return None\n</code></pre>"},{"location":"api/scheduler/host_provisioner/","title":"Host Provisioner","text":"<p>The \"HostProvisioner\" class is responsible for handling the provisioning and decommissioning of \"vHost\" instances in the simulation environment. Its main tasks include provisioning a new \"vHost\" if any \"vContainer\" cannot be scheduled and decommissioning idle \"vHost\" instances that have been inactive for an extended period.</p> <p>The provisioning process is implemented as an event, and only one provisioning process can exist at any given time during the simulation. When triggered, the provisioning process evaluates the current state of the simulation and checks if there are any \"vContainer\" instances that cannot be scheduled onto available \"vHost\" instances. If such a situation is detected, a new \"vHost\" is provisioned to accommodate the unscheduled \"vContainer\" and ensure the continuity of the simulation.</p> <p>On the other hand, the decommissioning process is continuously associated with each \"vHost\" instance. It periodically checks if a \"vHost\" is idle, meaning it is not currently hosting any \"vContainer\" instances. If an idle state is detected, the decommissioning process is engaged, resulting in the shutdown of the idle \"vHost\" instance. However, if the \"vHost\" is not idle, indicating it is still hosting active \"vContainer\" instances, the decommissioning process will back off and wait for the next evaluation cycle. It's important to note that multiple decommissioning processes can coexist during the simulation, each associated with a specific \"vHost\" instance.</p> <p>By incorporating the \"HostProvisioner\" class into the simulation environment, the provisioning and decommissioning of \"vHost\" instances can be managed dynamically, optimizing resource utilization and ensuring efficient allocation of computational resources.</p>"},{"location":"api/scheduler/host_provisioner/#PyCloudSim.scheduler.host_provisioner.HostProvisioner","title":"<code>HostProvisioner</code>","text":"Source code in <code>PyCloudSim\\scheduler\\host_provisioner.py</code> <pre><code>class HostProvisioner:\n    _power_saving: bool\n    _evaluation_interval: Union[int, float]\n\n    def __init__(\n        self, power_saving: bool = True, evaluation_interval: Union[int, float] = 1\n    ) -&gt; None:\n        \"\"\"Host provisioner.\n\n        Args:\n            power_saving (bool, optional): set to true for power saving, that the host will be powered off if no container or volume is being hosted. Defaults to True.\n            evaluation_interval (Union[int, float], optional): the interval for the host provisioner to check on the host. Defaults to 1.\n        \"\"\"\n        self._power_saving = power_saving\n        if evaluation_interval &lt;= 0:\n            raise ValueError(\n                \"Host privisioner evaluation delay must be greater than 0.\"\n            )\n        self._evaluation_interval = evaluation_interval\n        simulation._host_privisioner = self\n\n    def privision(self, host: vHost):\n        \"\"\"Provision a host.\"\"\"\n        def _evaluation():\n            if host.powered_on:\n                if len(host.containers) == 0:\n                    host.power_off()\n                else:\n                    Actor(\n                        at=simulation.now + self.evaluation_interval,\n                        action=_evaluation,\n                        label=\"Host Privisioning Evaluation\",\n                        priority=HOST_EVALUATION,\n                    )\n\n        if host.privisioned:\n            return\n        host._privisioned = True\n        host.power_on()\n        simulation.container_scheduler.schedule()\n        simulation.volume_allocator.allocate()\n        if self.power_saving:\n            Actor(\n                at=simulation.now + self.evaluation_interval,\n                action=_evaluation,\n                label=\"Host Privisioning Evaluation\",\n                priority=HOST_EVALUATION,\n            )\n\n    @property\n    def power_saving(self) -&gt; bool:\n        \"\"\"return true if power saving is enabled.\"\"\"\n        return self._power_saving\n\n    @property\n    def evaluation_interval(self) -&gt; Union[int, float]:\n        \"\"\"return the evaluation interval.\"\"\"\n        return self._evaluation_interval\n</code></pre>"},{"location":"api/scheduler/host_provisioner/#PyCloudSim.scheduler.host_provisioner.HostProvisioner.evaluation_interval","title":"<code>evaluation_interval: Union[int, float]</code>  <code>property</code>","text":"<p>return the evaluation interval.</p>"},{"location":"api/scheduler/host_provisioner/#PyCloudSim.scheduler.host_provisioner.HostProvisioner.power_saving","title":"<code>power_saving: bool</code>  <code>property</code>","text":"<p>return true if power saving is enabled.</p>"},{"location":"api/scheduler/host_provisioner/#PyCloudSim.scheduler.host_provisioner.HostProvisioner.__init__","title":"<code>__init__(power_saving=True, evaluation_interval=1)</code>","text":"<p>Host provisioner.</p> <p>Parameters:</p> Name Type Description Default <code>power_saving</code> <code>bool</code> <p>set to true for power saving, that the host will be powered off if no container or volume is being hosted. Defaults to True.</p> <code>True</code> <code>evaluation_interval</code> <code>Union[int, float]</code> <p>the interval for the host provisioner to check on the host. Defaults to 1.</p> <code>1</code> Source code in <code>PyCloudSim\\scheduler\\host_provisioner.py</code> <pre><code>def __init__(\n    self, power_saving: bool = True, evaluation_interval: Union[int, float] = 1\n) -&gt; None:\n    \"\"\"Host provisioner.\n\n    Args:\n        power_saving (bool, optional): set to true for power saving, that the host will be powered off if no container or volume is being hosted. Defaults to True.\n        evaluation_interval (Union[int, float], optional): the interval for the host provisioner to check on the host. Defaults to 1.\n    \"\"\"\n    self._power_saving = power_saving\n    if evaluation_interval &lt;= 0:\n        raise ValueError(\n            \"Host privisioner evaluation delay must be greater than 0.\"\n        )\n    self._evaluation_interval = evaluation_interval\n    simulation._host_privisioner = self\n</code></pre>"},{"location":"api/scheduler/host_provisioner/#PyCloudSim.scheduler.host_provisioner.HostProvisioner.privision","title":"<code>privision(host)</code>","text":"<p>Provision a host.</p> Source code in <code>PyCloudSim\\scheduler\\host_provisioner.py</code> <pre><code>def privision(self, host: vHost):\n    \"\"\"Provision a host.\"\"\"\n    def _evaluation():\n        if host.powered_on:\n            if len(host.containers) == 0:\n                host.power_off()\n            else:\n                Actor(\n                    at=simulation.now + self.evaluation_interval,\n                    action=_evaluation,\n                    label=\"Host Privisioning Evaluation\",\n                    priority=HOST_EVALUATION,\n                )\n\n    if host.privisioned:\n        return\n    host._privisioned = True\n    host.power_on()\n    simulation.container_scheduler.schedule()\n    simulation.volume_allocator.allocate()\n    if self.power_saving:\n        Actor(\n            at=simulation.now + self.evaluation_interval,\n            action=_evaluation,\n            label=\"Host Privisioning Evaluation\",\n            priority=HOST_EVALUATION,\n        )\n</code></pre>"},{"location":"api/scheduler/request_scheduler/","title":"Request Scheduler","text":"<p>The \"RequestScheduler\" class is responsible for scheduling \"vRequest\" instances onto \"vContainer\" instances in a simulated cloud environment. Since the computational resource usage of a \"vRequest\" cannot be known in advance due to the dynamic generation of \"vProcess\" and \"vPacket\" during execution, the \"RequestScheduler\" behaves like a load balancer, distributing \"vRequest\" instances among \"vContainer\" instances.</p> <p>By default, the \"RequestScheduler\" uses a logic that directs each \"vRequest\" to the \"vContainer\" instance that is currently executing the least number of \"vRequest\" instances. This default logic ensures a balanced distribution of workloads across available \"vContainer\" instances. However, the \"RequestScheduler\" class also provides an abstract member function that allows developers to customize the scheduling logic according to specific requirements.</p> <p>Similar to the \"ContainerScheduler\", the scheduling process in the \"RequestScheduler\" is implemented as an event that is triggered whenever a new \"vRequest\" is created, a current \"vRequest\" is terminated or a new 'vContainer\" is scheduled. This ensures that all unscheduled \"vRequest\" instances are processed and assigned to appropriate \"vContainer\" instances as soon as possible. During the simulation, only one \"RequestScheduler\" scheduling process can exist at any time to maintain the consistency of workload distribution.</p>"},{"location":"api/scheduler/request_scheduler/#PyCloudSim.scheduler.request_scheduler.RequestScheduler","title":"<code>RequestScheduler</code>","text":"Source code in <code>PyCloudSim\\scheduler\\request_scheduler.py</code> <pre><code>class RequestScheduler:\n    def __init__(self) -&gt; None:\n        \"\"\"Request Scheduler\n        \"\"\"        \n        self._active_process: Actor = None  # type: ignore\n        simulation._request_scheduler = self\n\n    def schedule(self):\n        \"\"\"Schedule requests.\n        \"\"\"        \n        def _schedule():\n            LOGGER.debug(\n                f\"{simulation.now:0.2f}:\\tRequest Scheduler is scheduling...{len([req for req in simulation.REQUESTS if req.scheduled == False])} requests.\"\n            )\n            self._active_process = None  # type: ignore\n            simulation.REQUESTS.sort(key=lambda x: x.priority)\n            for request in simulation.REQUESTS:\n                source_endpoint = None\n                target_endpoint = None\n                if not request.scheduled and request.created:\n                    # find the containers\n                    if isinstance(request.source, vMicroservice):\n                        source_endpoint = request.source.service.loadbalancer()\n                    else:\n                        source_endpoint = None\n\n                    if isinstance(request.target, vMicroservice):\n                        target_endpoint = request.target.service.loadbalancer()\n                    else:\n                        target_endpoint = None\n\n                    # check if request schedulable\n                    if (\n                        source_endpoint is None\n                        and isinstance(request.source, vMicroservice)\n                    ) or (\n                        target_endpoint is None\n                        and isinstance(request.target, vMicroservice)\n                    ):\n                        LOGGER.debug(f\"{simulation.now:0.2f}:\\tvRequest {request.label} not schedulable, {request.source} or {request.target} not available.\")\n                        continue\n\n                    request._scheduled_at = simulation.now\n                    request.status.append(SCHEDULED)\n                    if request.flow is not None and not request.flow.scheduled:\n                        request.flow._scheduled_at = simulation.now\n                        request.flow.status.append(SCHEDULED)\n\n                    if source_endpoint is not None:\n                        request._source_endpoint = source_endpoint\n                        source_endpoint.accept_request(request)\n\n                    if target_endpoint is not None:\n                        request._target_endpoint = target_endpoint\n                        target_endpoint.accept_request(request)\n\n                    request.execute()\n\n        if self._active_process is None:\n            self._active_process = Actor(\n                at=simulation.now,\n                action=_schedule,\n                label=f\"vRequest Scedule Start\",\n                priority=REQUEST_SCHEDULER,\n            )\n\n    @property\n    def active_process(self) -&gt; Actor:\n        \"\"\"return the active process of the request scheduler.\"\"\"\n        return self._active_process\n</code></pre>"},{"location":"api/scheduler/request_scheduler/#PyCloudSim.scheduler.request_scheduler.RequestScheduler.active_process","title":"<code>active_process: Actor</code>  <code>property</code>","text":"<p>return the active process of the request scheduler.</p>"},{"location":"api/scheduler/request_scheduler/#PyCloudSim.scheduler.request_scheduler.RequestScheduler.__init__","title":"<code>__init__()</code>","text":"<p>Request Scheduler</p> Source code in <code>PyCloudSim\\scheduler\\request_scheduler.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Request Scheduler\n    \"\"\"        \n    self._active_process: Actor = None  # type: ignore\n    simulation._request_scheduler = self\n</code></pre>"},{"location":"api/scheduler/request_scheduler/#PyCloudSim.scheduler.request_scheduler.RequestScheduler.schedule","title":"<code>schedule()</code>","text":"<p>Schedule requests.</p> Source code in <code>PyCloudSim\\scheduler\\request_scheduler.py</code> <pre><code>def schedule(self):\n    \"\"\"Schedule requests.\n    \"\"\"        \n    def _schedule():\n        LOGGER.debug(\n            f\"{simulation.now:0.2f}:\\tRequest Scheduler is scheduling...{len([req for req in simulation.REQUESTS if req.scheduled == False])} requests.\"\n        )\n        self._active_process = None  # type: ignore\n        simulation.REQUESTS.sort(key=lambda x: x.priority)\n        for request in simulation.REQUESTS:\n            source_endpoint = None\n            target_endpoint = None\n            if not request.scheduled and request.created:\n                # find the containers\n                if isinstance(request.source, vMicroservice):\n                    source_endpoint = request.source.service.loadbalancer()\n                else:\n                    source_endpoint = None\n\n                if isinstance(request.target, vMicroservice):\n                    target_endpoint = request.target.service.loadbalancer()\n                else:\n                    target_endpoint = None\n\n                # check if request schedulable\n                if (\n                    source_endpoint is None\n                    and isinstance(request.source, vMicroservice)\n                ) or (\n                    target_endpoint is None\n                    and isinstance(request.target, vMicroservice)\n                ):\n                    LOGGER.debug(f\"{simulation.now:0.2f}:\\tvRequest {request.label} not schedulable, {request.source} or {request.target} not available.\")\n                    continue\n\n                request._scheduled_at = simulation.now\n                request.status.append(SCHEDULED)\n                if request.flow is not None and not request.flow.scheduled:\n                    request.flow._scheduled_at = simulation.now\n                    request.flow.status.append(SCHEDULED)\n\n                if source_endpoint is not None:\n                    request._source_endpoint = source_endpoint\n                    source_endpoint.accept_request(request)\n\n                if target_endpoint is not None:\n                    request._target_endpoint = target_endpoint\n                    target_endpoint.accept_request(request)\n\n                request.execute()\n\n    if self._active_process is None:\n        self._active_process = Actor(\n            at=simulation.now,\n            action=_schedule,\n            label=f\"vRequest Scedule Start\",\n            priority=REQUEST_SCHEDULER,\n        )\n</code></pre>"},{"location":"api/scheduler/volume_allocator/","title":"Volume Allocator","text":"<p>The class \"vVolume\" is implemented to resemble a volume that can be attached to a container in Docker or Kubernetes which consumes the ROM from \"vHost\". A \"vContainer\" could be attached with multiple \"vVolume\" and those  \"vVolume\" could be allocated on different \"vHost\" rather than the \"vHost\" where the \"vContainer\" is hosted. A \"vVolume\" could be persistent by setting attribute \"retain\" equals to true. If a \"vVolume\" is persistent, it will not be destoried when its associated \"vContainer\" is terminated and could be reattached to a new instance of the \"vContainer\". The \"vVolume\" must be allocated first before a \"vContainer\" is scheduled. If any \"vVolume\" is failed to be allocated onto \"vHost\", the schedule of its associated \"vContainer\" will be on hold.</p>"},{"location":"api/scheduler/volume_allocator/#PyCloudSim.scheduler.volume_allocator.VolumeAllocator","title":"<code>VolumeAllocator</code>","text":"Source code in <code>PyCloudSim\\scheduler\\volume_allocator.py</code> <pre><code>class VolumeAllocator:\n    _host_affinity: bool\n\n    def __init__(\n        self,\n        host_affinity: bool = False,\n    ):\n        \"\"\"volume allocator.\n\n        Args:\n            host_affinity (bool, optional): set to true to enable volume allocator. Defaults to False.\n        \"\"\"        \n        self._host_affinity = host_affinity\n        self._active_process: Actor = None  # type: ignore\n        simulation._volume_allocator = self\n\n    def allocate(self):\n        \"\"\"Allocate the volume.\"\"\"\n        def _allocate():\n            self._active_process = None  # type: ignore\n            for volume in simulation.VOLUMES:\n                if volume.allocated or volume.terminated:\n                    continue\n\n                if self.host_affinity:\n                    for host in simulation.HOSTS:\n                        if (\n                            host.taint == volume.taint\n                            and host.powered_on\n                            and host.rom.available_quantity &gt;= volume.size\n                        ):\n                            host.allocate_volume(volume)\n                            volume._allocated = True\n                            self._active_process = None  # type: ignore\n                        break\n\n                else:\n                    for host in simulation.HOSTS:\n                        if (\n                            host.powered_on\n                            and host.rom.available_quantity &gt;= volume.size\n                        ):\n                            host.allocate_volume(volume)\n                            volume._allocated = True\n                            self._active_process = None  # type: ignore\n                        break\n\n                if not volume.allocated:\n                    LOGGER.info(\n                        f\"{simulation.now:0.2f}:\\tvVolume {volume.label} can not be allocated, privisioning new vHost if possible.\"\n                    )\n                    if self.host_affinity:\n                        for host in simulation.HOSTS:\n                            if host.taint == volume.taint:\n                                simulation.host_privisioner.privision(host)\n                    else:\n                        for host in simulation.HOSTS:\n                            if host.powered_off:\n                                simulation.host_privisioner.privision(host)\n\n        if self.active_process is None:\n            self._active_process = Actor(\n                at=simulation.now,\n                action=_allocate,\n                label=f\"vVolume Allocate\",\n                priority=VOLUME_ALLOCATOR,\n            )\n\n    @property\n    def host_affinity(self) -&gt; bool:\n        \"\"\"Return the \"\"\"\n        return self._host_affinity\n\n    @property\n    def active_process(self) -&gt; Actor:\n        \"\"\"return the current active scheduler process.\"\"\"\n        return self._active_process\n</code></pre>"},{"location":"api/scheduler/volume_allocator/#PyCloudSim.scheduler.volume_allocator.VolumeAllocator.active_process","title":"<code>active_process: Actor</code>  <code>property</code>","text":"<p>return the current active scheduler process.</p>"},{"location":"api/scheduler/volume_allocator/#PyCloudSim.scheduler.volume_allocator.VolumeAllocator.host_affinity","title":"<code>host_affinity: bool</code>  <code>property</code>","text":"<p>Return the</p>"},{"location":"api/scheduler/volume_allocator/#PyCloudSim.scheduler.volume_allocator.VolumeAllocator.__init__","title":"<code>__init__(host_affinity=False)</code>","text":"<p>volume allocator.</p> <p>Parameters:</p> Name Type Description Default <code>host_affinity</code> <code>bool</code> <p>set to true to enable volume allocator. Defaults to False.</p> <code>False</code> Source code in <code>PyCloudSim\\scheduler\\volume_allocator.py</code> <pre><code>def __init__(\n    self,\n    host_affinity: bool = False,\n):\n    \"\"\"volume allocator.\n\n    Args:\n        host_affinity (bool, optional): set to true to enable volume allocator. Defaults to False.\n    \"\"\"        \n    self._host_affinity = host_affinity\n    self._active_process: Actor = None  # type: ignore\n    simulation._volume_allocator = self\n</code></pre>"},{"location":"api/scheduler/volume_allocator/#PyCloudSim.scheduler.volume_allocator.VolumeAllocator.allocate","title":"<code>allocate()</code>","text":"<p>Allocate the volume.</p> Source code in <code>PyCloudSim\\scheduler\\volume_allocator.py</code> <pre><code>def allocate(self):\n    \"\"\"Allocate the volume.\"\"\"\n    def _allocate():\n        self._active_process = None  # type: ignore\n        for volume in simulation.VOLUMES:\n            if volume.allocated or volume.terminated:\n                continue\n\n            if self.host_affinity:\n                for host in simulation.HOSTS:\n                    if (\n                        host.taint == volume.taint\n                        and host.powered_on\n                        and host.rom.available_quantity &gt;= volume.size\n                    ):\n                        host.allocate_volume(volume)\n                        volume._allocated = True\n                        self._active_process = None  # type: ignore\n                    break\n\n            else:\n                for host in simulation.HOSTS:\n                    if (\n                        host.powered_on\n                        and host.rom.available_quantity &gt;= volume.size\n                    ):\n                        host.allocate_volume(volume)\n                        volume._allocated = True\n                        self._active_process = None  # type: ignore\n                    break\n\n            if not volume.allocated:\n                LOGGER.info(\n                    f\"{simulation.now:0.2f}:\\tvVolume {volume.label} can not be allocated, privisioning new vHost if possible.\"\n                )\n                if self.host_affinity:\n                    for host in simulation.HOSTS:\n                        if host.taint == volume.taint:\n                            simulation.host_privisioner.privision(host)\n                else:\n                    for host in simulation.HOSTS:\n                        if host.powered_off:\n                            simulation.host_privisioner.privision(host)\n\n    if self.active_process is None:\n        self._active_process = Actor(\n            at=simulation.now,\n            action=_allocate,\n            label=f\"vVolume Allocate\",\n            priority=VOLUME_ALLOCATOR,\n        )\n</code></pre>"},{"location":"api/virtual_entity/","title":"Index","text":"<p>The abstract class \"VirtualEntity\" extends the \"Entity\" class and introduces additional statuses that are specific to virtual entities within the simulation context. These new statuses include \"initiated,\" \"scheduled,\" \"failed,\" and \"completed.\" These statuses are designed to capture different stages or outcomes relevant to virtual entities during the simulation process.</p>"},{"location":"api/virtual_entity/v_container/","title":"vContainer","text":"<p>The class \"vContainer\" serves as an implementation of the abstract class \"VirtualEntity\" and emulates containers in Docker or Pods in Kubernetes. It encompasses the following essential attributes and member functions:</p> <ol> <li>CPU: Represents the CPU time limit allocated to the \"vContainer\".</li> <li>RAM: Denotes the maximum amount of RAM that the \"vContainer\" can utilize.</li> <li>Simulated API Call Queue: Stores the simulated API calls associated with the \"vContainer\".</li> <li>Simulated Process Queue: Holds the simulated processes assigned to the \"vContainer\".</li> <li>Crash Handling: If the RAM consumed by all the simulated processes in the queue surpasses the container's RAM capacity, the \"vContainer\" will crash. Consequently, all processes in the queue will be terminated and marked as failed.</li> <li>Simulated Daemon Process: The \"vContainer\" may include a simulated daemon process that mimics resource usage when the container is idle. This daemon process operates continuously until the \"vContainer\" is terminated.</li> </ol> <p>Overall, the \"vContainer\" encapsulates the behavior and characteristics of containerized environments, providing capabilities for resource allocation, process management, and crash handling within the simulated cloud environment.</p> <p>             Bases: <code>VirtualEntity</code></p> Source code in <code>PyCloudSim\\entity\\v_container.py</code> <pre><code>class vContainer(VirtualEntity):\n    def __init__(\n        self,\n        cpu: int,\n        cpu_limit: int,\n        ram: int,\n        ram_limit: int,\n        image_size: int,\n        volumes: Optional[List[Tuple[str, str, int, bool]]] = None,\n        deamon: bool = False,\n        taint: Optional[str] = None,\n        at: Union[int, float, Callable] = simulation.now,\n        after: Optional[Entity | List[Entity]] = None,\n        label: Optional[str] = None,\n    ):\n        \"\"\"Create a container with given specifications. Equivalent to a virtual machine or Pod in Kubernetes.\n\n        Args:\n            cpu (int): the amount of CPU requested by the container.\n            cpu_limit (int): the maximum amount of CPU that the container can use.\n            ram (int): the amount of RAM requested by the container.\n            ram_limit (int): the maximum amount of RAM that the container can use.\n            image_size (int): the size of the image that the container is running, in MB.\n            volumes (Optional[List[Tuple[str, str, int, bool]]], optional): the volumes that attaches to this container, (name, path, size in MB, persistent or not). Defaults to None.\n            deamon (bool, optional): set true will enable a deamon process for the container. Defaults to False.\n            taint (Optional[str], optional): the container taint, using for host allocation. Defaults to None.\n            at (Union[int, float, Callable], optional): when the container is created. Defaults to simulation.now.\n            after (Optional[Entity  |  List[Entity]], optional): the container must be created after the given entity is terminated. Defaults to None.\n            label (Optional[str], optional): short description of the container. Defaults to None.\n        \"\"\"\n        super().__init__(at=at, after=after, label=label)\n\n        self._cpu_request = cpu\n        self._cpu = Resource(\n            capacity=cpu_limit, label=f\"{self.__class__.__name__} {self.label} CPU\"\n        )\n        self._ram_request = ram\n        self._ram = Resource(\n            capacity=MiB(ram_limit).bytes,\n            label=f\"{self.__class__.__name__} {self.label} RAM\",\n        )\n\n        self._image_size = MiB(image_size)\n        self._volumes = list()\n        if volumes is None:\n            self._volumes: List[vVolume] = list()\n        else:\n            for volume in volumes:\n                new_volume = vVolume(volume[0], volume[1], volume[2], volume[3])\n                new_volume.attach(self)\n                self._volumes.append(new_volume)\n\n        self._deamon = deamon\n        self._taint = taint or str()\n        self._host_id = int()\n        self._microservice_id = int()\n        self._processes: List[vProcess] = list()\n        self._requests: List[vRequest] = list()\n        self._on_creation = lambda: simulation.container_scheduler.schedule()\n        simulation.CONTAINERS.append(self)\n\n    def init_deamon(self):\n        \"\"\"Initialize the deamon process for the container.\"\"\"\n        if self.deamon:\n            deamon = vDeamonProcess(\n                length=int(\n                    self.cpu_request / 1000 * self.host.cpu.single_core_capacity\n                ),\n                container=self,\n                at=simulation.now,\n                label=f\"vContainer {self.label} Deamon\",\n            )\n\n    def accept_request(self, request: vRequest):\n        \"\"\"Accept the vRequest\"\"\"\n        self.requests.append(request)\n        LOGGER.debug(\n            f\"{simulation.now:0.2f}:\\tvContainer {self.label} accepts vRequest {request.label}.\"\n        )\n\n    def accept_process(self, process: vProcess):\n        \"\"\"Accept a process to run in the container.\"\"\"\n        if self.terminated:\n            print(process.status)\n            print(process.request.status)  # type: ignore\n            print(self.label)\n            raise Exception()\n\n        self.processes.append(process)\n        process._container_id = self.id\n        process.status.append(SCHEDULED)\n        # check if the container has enough ram resources to run the process\n        try:\n            self.ram.distribute(process, process.ram_usage)\n        except:\n            LOGGER.info(\n                f\"{simulation.now:0.2f}:\\tvContainer {self.label} is crushed by vProcess {process.label} due to RAM overload.\"\n            )\n            self.crash()\n            return\n        # check if the container's host has enough RAM\n        try:\n            self.host.ram.distribute(process, process.ram_usage)\n        except:\n            LOGGER.info(\n                f\"{simulation.now:0.2f}:\\tvContainer {self.label} is crushed by vProcess {process.label} due to vHost {self.host.label} RAM overload.\"\n            )\n            self.crash()\n            return\n        self.host.processes.append(process)\n        self.host.cpu.cache_process(process)\n        process._host_id = self.host.id\n        LOGGER.info(\n            f\"{simulation.now:0.2f}:\\tvProcess {process.label} is accepted by vContainer {process.container.label}.\"  # type: ignore\n        )\n\n    def termination(self):\n        \"\"\"Terminate the container. Any process running in the container will be terminated as well and marked as failed.\n\n        Raises:\n            RuntimeError: raise if there is a volume that should not be attached to the container.\n        \"\"\"\n        # deallocate the container from the host if it is scheduled\n        if self.scheduled:\n            self.host.containers.remove(self)\n            self.host.rom.release(self)\n            self.host.cpu_reservor.release(self)\n            self.host.ram_reservor.release(self)\n        # detach or terminate all the volumes attached to the container\n        detached_volumes: List[vVolume] = list()\n        for volume in self.volumes:\n            if volume.container is not self:\n                raise RuntimeError(\n                    f\"Virtual Volume {volume.label} is should not be attached to vContainer {self.label}.\"\n                )\n\n            if volume.retain:\n                volume.detach()\n                detached_volumes.append(volume)\n            else:\n                volume.terminate()\n\n        # terminate all the processes running in the container\n        for process in self.processes:\n            if not process.terminated:\n                process.crash()\n\n        for request in self.requests:\n            if not request.terminated:\n                request.fail()\n\n        # recover the container if neccessary\n        self.microservice.containers.remove(self)\n        if self.failed:\n            self.microservice.recover(self, detached_volumes)\n\n        simulation.container_scheduler.schedule()\n\n    def crash(self):\n        \"\"\"Crash the container. Any process running in the container will be terminated as well and marked as failed. This will call terminate() method.\"\"\"\n\n        if not self.failed:\n            self.status.append(FAILED)\n            self.terminate()\n            LOGGER.info(f\"{simulation.now:0.2f}:\\tvContainer {self.label} Crashed.\")\n\n    @property\n    def cpu_request(self) -&gt; int:\n        \"\"\"return the CPU request of the container in millicore.\"\"\"\n        return self._cpu_request\n\n    @property\n    def cpu(self) -&gt; Resource:\n        \"\"\"return the CPU ( as Resource ) of the container.\"\"\"\n        return self._cpu\n\n    @property\n    def ram_request(self) -&gt; int:\n        \"\"\"return the RAM request of the container in MiB.\"\"\"\n        return self._ram_request\n\n    @property\n    def ram(self) -&gt; Resource:\n        \"\"\"return the RAM ( as Resource ) of the container.\"\"\"\n        return self._ram\n\n    @property\n    def image_size(self) -&gt; int:\n        \"\"\"return the image size of the container in bytes.\"\"\"\n        return self._image_size.bytes\n\n    @property\n    def rom_request(self) -&gt; float:\n        \"\"\"return the ROM request of the container in MiB, which is the sum of the image size and the size of the volumes attached to the container.\"\"\"\n        return sum([volume.size for volume in self._volumes]) + self.image_size\n\n    @property\n    def volumes(self) -&gt; List[vVolume]:\n        \"\"\"return the list of volumes attached to the container.\"\"\"\n        return self._volumes\n\n    @property\n    def taint(self) -&gt; str:\n        \"\"\"return the taint of the container.\"\"\"\n        return self._taint\n\n    @property\n    def host_id(self) -&gt; int:\n        \"\"\"return the id of the host that the container is scheduled to.\"\"\"\n        return self._host_id\n\n    @property\n    def host(self) -&gt; vHost:\n        \"\"\"return the host that the container is scheduled to.\"\"\"\n        for host in simulation.HOSTS:\n            if host.id == self.host_id:\n                return host\n        raise RuntimeError(f\"Container {self.label} is not allocated to any host.\")\n\n    @property\n    def microservice_id(self) -&gt; int:\n        \"\"\"return the id of the microservice that the container is associated to.\"\"\"\n        return self._microservice_id\n\n    @property\n    def microservice(self) -&gt; vMicroservice:\n        \"\"\"return the microservice that the container is associated to.\"\"\"\n        for microservice in simulation.MICROSERVICES:\n            if microservice.id == self.microservice_id:\n                return microservice\n        raise RuntimeError(\n            f\"Container {self.label} is not allocated to any microservice.\"\n        )\n\n    @property\n    def processes(self) -&gt; List[vProcess]:\n        \"\"\"return the list of processes running in the container.\"\"\"\n        return self._processes\n\n    @property\n    def requests(self) -&gt; List[vRequest]:\n        \"\"\"return the list of requests that the container has served.\"\"\"\n        return self._requests\n\n    @property\n    def deamon(self):\n        \"\"\"return the deamon of the container.\"\"\"\n        return self._deamon\n\n    @property\n    def schedulable(self) -&gt; bool:\n        \"\"\"return True if the container is schedulable ( all volumes are attached successfully ), otherwise return False.\"\"\"\n        if all([volume.allocated for volume in self.volumes]):\n            return True\n        else:\n            return False\n\n    @property\n    def cordon(self) -&gt; bool:\n        \"\"\"return True if the container is cordon, otherwise return False.\"\"\"\n        return CORDON in self.status\n</code></pre>"},{"location":"api/virtual_entity/v_container/#PyCloudSim.entity.v_container.vContainer.cordon","title":"<code>cordon: bool</code>  <code>property</code>","text":"<p>return True if the container is cordon, otherwise return False.</p>"},{"location":"api/virtual_entity/v_container/#PyCloudSim.entity.v_container.vContainer.cpu","title":"<code>cpu: Resource</code>  <code>property</code>","text":"<p>return the CPU ( as Resource ) of the container.</p>"},{"location":"api/virtual_entity/v_container/#PyCloudSim.entity.v_container.vContainer.cpu_request","title":"<code>cpu_request: int</code>  <code>property</code>","text":"<p>return the CPU request of the container in millicore.</p>"},{"location":"api/virtual_entity/v_container/#PyCloudSim.entity.v_container.vContainer.deamon","title":"<code>deamon</code>  <code>property</code>","text":"<p>return the deamon of the container.</p>"},{"location":"api/virtual_entity/v_container/#PyCloudSim.entity.v_container.vContainer.host","title":"<code>host: vHost</code>  <code>property</code>","text":"<p>return the host that the container is scheduled to.</p>"},{"location":"api/virtual_entity/v_container/#PyCloudSim.entity.v_container.vContainer.host_id","title":"<code>host_id: int</code>  <code>property</code>","text":"<p>return the id of the host that the container is scheduled to.</p>"},{"location":"api/virtual_entity/v_container/#PyCloudSim.entity.v_container.vContainer.image_size","title":"<code>image_size: int</code>  <code>property</code>","text":"<p>return the image size of the container in bytes.</p>"},{"location":"api/virtual_entity/v_container/#PyCloudSim.entity.v_container.vContainer.microservice","title":"<code>microservice: vMicroservice</code>  <code>property</code>","text":"<p>return the microservice that the container is associated to.</p>"},{"location":"api/virtual_entity/v_container/#PyCloudSim.entity.v_container.vContainer.microservice_id","title":"<code>microservice_id: int</code>  <code>property</code>","text":"<p>return the id of the microservice that the container is associated to.</p>"},{"location":"api/virtual_entity/v_container/#PyCloudSim.entity.v_container.vContainer.processes","title":"<code>processes: List[vProcess]</code>  <code>property</code>","text":"<p>return the list of processes running in the container.</p>"},{"location":"api/virtual_entity/v_container/#PyCloudSim.entity.v_container.vContainer.ram","title":"<code>ram: Resource</code>  <code>property</code>","text":"<p>return the RAM ( as Resource ) of the container.</p>"},{"location":"api/virtual_entity/v_container/#PyCloudSim.entity.v_container.vContainer.ram_request","title":"<code>ram_request: int</code>  <code>property</code>","text":"<p>return the RAM request of the container in MiB.</p>"},{"location":"api/virtual_entity/v_container/#PyCloudSim.entity.v_container.vContainer.requests","title":"<code>requests: List[vRequest]</code>  <code>property</code>","text":"<p>return the list of requests that the container has served.</p>"},{"location":"api/virtual_entity/v_container/#PyCloudSim.entity.v_container.vContainer.rom_request","title":"<code>rom_request: float</code>  <code>property</code>","text":"<p>return the ROM request of the container in MiB, which is the sum of the image size and the size of the volumes attached to the container.</p>"},{"location":"api/virtual_entity/v_container/#PyCloudSim.entity.v_container.vContainer.schedulable","title":"<code>schedulable: bool</code>  <code>property</code>","text":"<p>return True if the container is schedulable ( all volumes are attached successfully ), otherwise return False.</p>"},{"location":"api/virtual_entity/v_container/#PyCloudSim.entity.v_container.vContainer.taint","title":"<code>taint: str</code>  <code>property</code>","text":"<p>return the taint of the container.</p>"},{"location":"api/virtual_entity/v_container/#PyCloudSim.entity.v_container.vContainer.volumes","title":"<code>volumes: List[vVolume]</code>  <code>property</code>","text":"<p>return the list of volumes attached to the container.</p>"},{"location":"api/virtual_entity/v_container/#PyCloudSim.entity.v_container.vContainer.__init__","title":"<code>__init__(cpu, cpu_limit, ram, ram_limit, image_size, volumes=None, deamon=False, taint=None, at=simulation.now, after=None, label=None)</code>","text":"<p>Create a container with given specifications. Equivalent to a virtual machine or Pod in Kubernetes.</p> <p>Parameters:</p> Name Type Description Default <code>cpu</code> <code>int</code> <p>the amount of CPU requested by the container.</p> required <code>cpu_limit</code> <code>int</code> <p>the maximum amount of CPU that the container can use.</p> required <code>ram</code> <code>int</code> <p>the amount of RAM requested by the container.</p> required <code>ram_limit</code> <code>int</code> <p>the maximum amount of RAM that the container can use.</p> required <code>image_size</code> <code>int</code> <p>the size of the image that the container is running, in MB.</p> required <code>volumes</code> <code>Optional[List[Tuple[str, str, int, bool]]]</code> <p>the volumes that attaches to this container, (name, path, size in MB, persistent or not). Defaults to None.</p> <code>None</code> <code>deamon</code> <code>bool</code> <p>set true will enable a deamon process for the container. Defaults to False.</p> <code>False</code> <code>taint</code> <code>Optional[str]</code> <p>the container taint, using for host allocation. Defaults to None.</p> <code>None</code> <code>at</code> <code>Union[int, float, Callable]</code> <p>when the container is created. Defaults to simulation.now.</p> <code>now</code> <code>after</code> <code>Optional[Entity | List[Entity]]</code> <p>the container must be created after the given entity is terminated. Defaults to None.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>short description of the container. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_container.py</code> <pre><code>def __init__(\n    self,\n    cpu: int,\n    cpu_limit: int,\n    ram: int,\n    ram_limit: int,\n    image_size: int,\n    volumes: Optional[List[Tuple[str, str, int, bool]]] = None,\n    deamon: bool = False,\n    taint: Optional[str] = None,\n    at: Union[int, float, Callable] = simulation.now,\n    after: Optional[Entity | List[Entity]] = None,\n    label: Optional[str] = None,\n):\n    \"\"\"Create a container with given specifications. Equivalent to a virtual machine or Pod in Kubernetes.\n\n    Args:\n        cpu (int): the amount of CPU requested by the container.\n        cpu_limit (int): the maximum amount of CPU that the container can use.\n        ram (int): the amount of RAM requested by the container.\n        ram_limit (int): the maximum amount of RAM that the container can use.\n        image_size (int): the size of the image that the container is running, in MB.\n        volumes (Optional[List[Tuple[str, str, int, bool]]], optional): the volumes that attaches to this container, (name, path, size in MB, persistent or not). Defaults to None.\n        deamon (bool, optional): set true will enable a deamon process for the container. Defaults to False.\n        taint (Optional[str], optional): the container taint, using for host allocation. Defaults to None.\n        at (Union[int, float, Callable], optional): when the container is created. Defaults to simulation.now.\n        after (Optional[Entity  |  List[Entity]], optional): the container must be created after the given entity is terminated. Defaults to None.\n        label (Optional[str], optional): short description of the container. Defaults to None.\n    \"\"\"\n    super().__init__(at=at, after=after, label=label)\n\n    self._cpu_request = cpu\n    self._cpu = Resource(\n        capacity=cpu_limit, label=f\"{self.__class__.__name__} {self.label} CPU\"\n    )\n    self._ram_request = ram\n    self._ram = Resource(\n        capacity=MiB(ram_limit).bytes,\n        label=f\"{self.__class__.__name__} {self.label} RAM\",\n    )\n\n    self._image_size = MiB(image_size)\n    self._volumes = list()\n    if volumes is None:\n        self._volumes: List[vVolume] = list()\n    else:\n        for volume in volumes:\n            new_volume = vVolume(volume[0], volume[1], volume[2], volume[3])\n            new_volume.attach(self)\n            self._volumes.append(new_volume)\n\n    self._deamon = deamon\n    self._taint = taint or str()\n    self._host_id = int()\n    self._microservice_id = int()\n    self._processes: List[vProcess] = list()\n    self._requests: List[vRequest] = list()\n    self._on_creation = lambda: simulation.container_scheduler.schedule()\n    simulation.CONTAINERS.append(self)\n</code></pre>"},{"location":"api/virtual_entity/v_container/#PyCloudSim.entity.v_container.vContainer.accept_process","title":"<code>accept_process(process)</code>","text":"<p>Accept a process to run in the container.</p> Source code in <code>PyCloudSim\\entity\\v_container.py</code> <pre><code>def accept_process(self, process: vProcess):\n    \"\"\"Accept a process to run in the container.\"\"\"\n    if self.terminated:\n        print(process.status)\n        print(process.request.status)  # type: ignore\n        print(self.label)\n        raise Exception()\n\n    self.processes.append(process)\n    process._container_id = self.id\n    process.status.append(SCHEDULED)\n    # check if the container has enough ram resources to run the process\n    try:\n        self.ram.distribute(process, process.ram_usage)\n    except:\n        LOGGER.info(\n            f\"{simulation.now:0.2f}:\\tvContainer {self.label} is crushed by vProcess {process.label} due to RAM overload.\"\n        )\n        self.crash()\n        return\n    # check if the container's host has enough RAM\n    try:\n        self.host.ram.distribute(process, process.ram_usage)\n    except:\n        LOGGER.info(\n            f\"{simulation.now:0.2f}:\\tvContainer {self.label} is crushed by vProcess {process.label} due to vHost {self.host.label} RAM overload.\"\n        )\n        self.crash()\n        return\n    self.host.processes.append(process)\n    self.host.cpu.cache_process(process)\n    process._host_id = self.host.id\n    LOGGER.info(\n        f\"{simulation.now:0.2f}:\\tvProcess {process.label} is accepted by vContainer {process.container.label}.\"  # type: ignore\n    )\n</code></pre>"},{"location":"api/virtual_entity/v_container/#PyCloudSim.entity.v_container.vContainer.accept_request","title":"<code>accept_request(request)</code>","text":"<p>Accept the vRequest</p> Source code in <code>PyCloudSim\\entity\\v_container.py</code> <pre><code>def accept_request(self, request: vRequest):\n    \"\"\"Accept the vRequest\"\"\"\n    self.requests.append(request)\n    LOGGER.debug(\n        f\"{simulation.now:0.2f}:\\tvContainer {self.label} accepts vRequest {request.label}.\"\n    )\n</code></pre>"},{"location":"api/virtual_entity/v_container/#PyCloudSim.entity.v_container.vContainer.crash","title":"<code>crash()</code>","text":"<p>Crash the container. Any process running in the container will be terminated as well and marked as failed. This will call terminate() method.</p> Source code in <code>PyCloudSim\\entity\\v_container.py</code> <pre><code>def crash(self):\n    \"\"\"Crash the container. Any process running in the container will be terminated as well and marked as failed. This will call terminate() method.\"\"\"\n\n    if not self.failed:\n        self.status.append(FAILED)\n        self.terminate()\n        LOGGER.info(f\"{simulation.now:0.2f}:\\tvContainer {self.label} Crashed.\")\n</code></pre>"},{"location":"api/virtual_entity/v_container/#PyCloudSim.entity.v_container.vContainer.init_deamon","title":"<code>init_deamon()</code>","text":"<p>Initialize the deamon process for the container.</p> Source code in <code>PyCloudSim\\entity\\v_container.py</code> <pre><code>def init_deamon(self):\n    \"\"\"Initialize the deamon process for the container.\"\"\"\n    if self.deamon:\n        deamon = vDeamonProcess(\n            length=int(\n                self.cpu_request / 1000 * self.host.cpu.single_core_capacity\n            ),\n            container=self,\n            at=simulation.now,\n            label=f\"vContainer {self.label} Deamon\",\n        )\n</code></pre>"},{"location":"api/virtual_entity/v_container/#PyCloudSim.entity.v_container.vContainer.termination","title":"<code>termination()</code>","text":"<p>Terminate the container. Any process running in the container will be terminated as well and marked as failed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>raise if there is a volume that should not be attached to the container.</p> Source code in <code>PyCloudSim\\entity\\v_container.py</code> <pre><code>def termination(self):\n    \"\"\"Terminate the container. Any process running in the container will be terminated as well and marked as failed.\n\n    Raises:\n        RuntimeError: raise if there is a volume that should not be attached to the container.\n    \"\"\"\n    # deallocate the container from the host if it is scheduled\n    if self.scheduled:\n        self.host.containers.remove(self)\n        self.host.rom.release(self)\n        self.host.cpu_reservor.release(self)\n        self.host.ram_reservor.release(self)\n    # detach or terminate all the volumes attached to the container\n    detached_volumes: List[vVolume] = list()\n    for volume in self.volumes:\n        if volume.container is not self:\n            raise RuntimeError(\n                f\"Virtual Volume {volume.label} is should not be attached to vContainer {self.label}.\"\n            )\n\n        if volume.retain:\n            volume.detach()\n            detached_volumes.append(volume)\n        else:\n            volume.terminate()\n\n    # terminate all the processes running in the container\n    for process in self.processes:\n        if not process.terminated:\n            process.crash()\n\n    for request in self.requests:\n        if not request.terminated:\n            request.fail()\n\n    # recover the container if neccessary\n    self.microservice.containers.remove(self)\n    if self.failed:\n        self.microservice.recover(self, detached_volumes)\n\n    simulation.container_scheduler.schedule()\n</code></pre>"},{"location":"api/virtual_entity/v_microservice/","title":"vMicroservice","text":"<p>The class \"vMicroservice\" is designed to resemble a deployment in Kubernetes, comprising one or more instances of the \"vContainer\" class. It encompasses the following important member functions and behaviours:</p> <ol> <li>Recovery of Failed vContainers: When any \"vContainer\" crashes or encounters a failure, the \"vMicroservice\" includes a member function that facilitates the recovery of these failed containers. This recovery process is initiated immediately after a container failure or after a specific delay, as determined by the simulation.</li> <li>Horizontal Scaling: The \"vMicroservice\" is responsible for horizontal scaling, which involves dynamically adjusting the number of \"vContainer\" instances based on certain conditions. If the overall CPU/RAM usage of all current \"vContainer\" instances exceeds a predetermined threshold, a new \"vContainer\" will be created to handle the increased workload. Conversely, if a \"vContainer\" is identified as being under-utilized, it may be forcibly terminated. Horizontal scaling is implemented as an event, and only one horizontal scaling event can occur per \"vMicroservice\" instance at any given time during the simulation.</li> <li>Readiness of vMicroservice: The readiness of a \"vMicroservice\" is determined by the number of current \"vContainer\" instances reaching the minimum required number. This minimum requirement ensures that the \"vMicroservice\" is considered ready for operation.</li> </ol> <p>In summary, the \"vMicroservice\" class emulates the behaviour of deployments in Kubernetes, facilitating the management of \"vContainer\" instances, recovery from failures, horizontal scaling, and readiness evaluation within the simulated cloud environment.</p> <p>             Bases: <code>VirtualEntity</code>, <code>ABC</code></p> Source code in <code>PyCloudSim\\entity\\v_microservice.py</code> <pre><code>class vMicroservice(VirtualEntity, ABC):\n    def __init__(\n        self,\n        cpu: int,\n        cpu_limit: int,\n        ram: int,\n        ram_limit: int,\n        image_size: int,\n        volumes: Optional[List[Tuple[str, str, int, bool]]] = None,\n        taint: Optional[str] = None,\n        deamon: bool = False,\n        min_num_containers: int = 1,\n        max_num_containers: int = 3,\n        evaluation_interval: float = 0.01,\n        service: Type[vService] = vServiceBestFit,\n        ports: List[int] = [],\n        at: Union[int, float, Callable] = simulation.now,\n        after: Optional[Entity | List[Entity]] = None,\n        label: Optional[str] = None,\n    ):\n        \"\"\"Create a virtual microservice.\n\n        Args:\n            cpu (int): the requested CPU time.\n            cpu_limit (int): the limited CPU time.\n            ram (int): the requested RAM in MiB.\n            ram_limit (int): the limited RAM in MiB.\n            image_size (int): the image size in MiB of the microservice container instance.\n            volumes (Optional[List[Tuple[str, str, int, bool]]], optional): The volumes that are attached to each container instance, (name, path, size in MiB, retain or not). Defaults to None.\n            taint (Optional[str], optional): the taint of the microservice, used in scheduling. Defaults to None.\n            deamon (bool, optional): set true for create deamon process for container instance. Defaults to False.\n            min_num_containers (int, optional): minimum number of container instances. Defaults to 1.\n            max_num_containers (int, optional): maximum number of container instances. Defaults to 3.\n            evaluation_interval (float, optional): the interval for horizontal scaler to check on the microservice. Defaults to 0.01.\n            service (Type[vService], optional): the service for this microservice, will determine the load balancing method. Defaults to vServiceBestFit.\n            ports (List[int], optional): the port that are exposed. Defaults to [].\n            at (Union[int, float, Callable], optional): same as entity. Defaults to simulation.now.\n            after (Optional[Entity  |  List[Entity]], optional): same as entity. Defaults to None.\n            label (Optional[str], optional): same as entity. Defaults to None.\n        \"\"\"\n        super().__init__(at, after, label)\n\n        self._cpu = cpu\n        self._cpu_limit = cpu_limit\n        self._ram = ram\n        self._ram_limit = ram_limit\n        self._image_size = image_size\n        self._volumes = volumes\n        self._taint = taint\n        self._volumes = volumes\n        self._taint = taint\n        self._deamon = deamon\n\n        self._min_num_containers = min_num_containers\n        self._containers = list()\n        for i in range(min_num_containers):\n            container = vContainer(\n                cpu=cpu,\n                cpu_limit=cpu_limit,\n                ram=ram,\n                ram_limit=ram_limit,\n                image_size=image_size,\n                volumes=volumes,\n                taint=taint,\n                label=f\"{self.label}-{i}\",\n                deamon=self.deamon,\n            )\n            container._microservice_id = self.id\n            self.containers.append(container)\n        self._max_num_containers = max_num_containers\n        self._service = service(ms=self, ports=ports, label=f\"{self.label}-service\")\n        self._evaluator = Actor(\n            at=simulation.now,\n            step=evaluation_interval,\n            action=self.evaluate,\n            label=f\"vMicroservice {self.label} Evaluator\",\n        )\n        simulation.MICROSERVICES.append(self)\n\n    def termination(self):\n        \"\"\"Termination process of the virtual microservice.\"\"\"\n        super().termination()\n        self.service.terminate()\n        for container in self.containers:\n            container.terminate()\n\n    def evaluate(self):\n        \"\"\"Evaluate the status of the virtual microservice, and trigger scaling up or down.\"\"\"\n        scheduled_container = [\n            container for container in self.containers if container.scheduled\n        ]\n        if len(scheduled_container) &gt;= self.min_num_containers:\n            self.status.append(READY)\n            LOGGER.info(f\"{simulation.now:0.2f}:\\tvMicroservice {self.label} is ready. {self.cpu_usage_in_past(0.01)} CPU, {self.ram_usage_in_past(0.01)} RAM.\")\n        else:\n            if self.ready:\n                self.status.remove(READY)\n            LOGGER.info(\n                f\"{simulation.now:0.2f}:\\tvMicroservice {self.label} is not ready, {len(scheduled_container)}/{self.min_num_containers}.\"\n            )\n\n        for sfc in simulation.SFCS:\n            if not sfc.ready:\n                sfc.evaluate()\n\n        if self.scale_up_triggered():\n            if (\n                len(self.containers) &lt; self.max_num_containers\n                and len(\n                    [\n                        container\n                        for container in self.containers\n                        if not container.scheduled\n                    ]\n                )\n                == 0\n            ):\n                new_container = vContainer(\n                    cpu=self.cpu,\n                    cpu_limit=self.cpu_limit,\n                    ram=self.ram,\n                    ram_limit=self.ram_limit,\n                    image_size=self.image_size,\n                    volumes=self.volumes,\n                    taint=self.taint,\n                    label=f\"{self.label}-{len(self.containers)}\",\n                    deamon=self.deamon,\n                )\n                new_container._microservice_id = self.id\n                self.containers.append(new_container)\n                LOGGER.info(\n                    f\"{simulation.now:0.2f}:\\tvMicroservice {self.label} scaled up one vContainer {new_container.label}.\"\n                )\n        elif self.scale_down_triggered():\n            if len(self.containers) &gt; self.min_num_containers:\n                self.containers.sort(key=lambda container: len(container.processes))\n                if len(self.containers[0].requests) == 0:\n                    self.containers[0].terminate()\n                    LOGGER.info(\n                        f\"{simulation.now:0.2f}:\\tvMicroservice {self.label} scaled down one vContainer {self.containers[0].label}.\"\n                    )\n                else:\n                    if (\n                        len(\n                            [\n                                container\n                                for container in self.containers\n                                if container.status == CORDON\n                            ]\n                        )\n                        == 0\n                    ):\n                        self.containers[0].status.append(CORDON)\n                    LOGGER.info(\n                        f\"{simulation.now:0.2f}:\\tvContainer {self.containers[0].label} is cordoned.\"\n                    )\n\n    def recover(\n        self, container: vContainer, detached_volumes: Optional[List[vVolume]] = None\n    ):\n        \"\"\"Recover a failed container instance.\"\"\"\n        def _recover():\n            # find non-retained volumes to recover\n            volumes_to_recover = list()\n            if self.volumes is not None and detached_volumes is not None:\n                for volume in detached_volumes:\n                    for v_definitions in self.volumes:\n                        if (\n                            volume.tag == v_definitions[0]\n                            and volume.path == v_definitions[1]\n                        ):\n                            continue\n                        else:\n                            volumes_to_recover.append(v_definitions)\n            # recover container\n            recovered_container = vContainer(\n                cpu=self.cpu,\n                cpu_limit=self.cpu_limit,\n                ram=self.ram,\n                ram_limit=self.ram_limit,\n                image_size=self.image_size,\n                volumes=volumes_to_recover,\n                taint=self.taint,\n                label=container.label,\n                deamon=self.deamon,\n            )\n            recovered_container._microservice_id = self.id\n            if detached_volumes is not None:\n                for volume in detached_volumes:\n                    volume.attach(recovered_container)\n            self._containers.append(recovered_container)\n            LOGGER.info(\n                f\"{simulation.now:0.2f}:\\tvMicroservice {self.label} recovered one failed containers.\"\n            )\n\n        if not self.terminated:\n            Actor(\n                at=simulation.now,\n                action=_recover,\n                label=f\"vMicroservice {self.label} Recover\",\n                priority=CREATION,\n            )\n\n    @abstractmethod\n    def scale_up_triggered(self) -&gt; bool:\n        \"\"\"For developer to implement the scaling up trigger condition.\"\"\"\n        pass\n\n    @abstractmethod\n    def scale_down_triggered(self) -&gt; bool:\n        \"\"\"For developer to implement the scaling down trigger condition.\"\"\"\n        pass\n\n    @property\n    def containers(self) -&gt; List[vContainer]:\n        \"\"\"The container instances of the virtual microservice.\"\"\"\n        return self._containers\n\n    @property\n    def cpu(self) -&gt; int:\n        \"\"\"The requested CPU time of the virtual microservice.\"\"\"\n        return self._cpu\n\n    @property\n    def cpu_limit(self) -&gt; int:\n        \"\"\"The limited CPU time of the virtual microservice.\"\"\"\n        return self._cpu_limit\n\n    @property\n    def ram(self) -&gt; int:\n        \"\"\"The requested RAM in MiB of the virtual microservice.\"\"\"\n        return self._ram\n\n    @property\n    def ram_limit(self) -&gt; int:\n        \"\"\"The limited RAM in MiB of the virtual microservice.\"\"\"\n        return self._ram_limit\n\n    @property\n    def image_size(self) -&gt; int:\n        \"\"\"The image size in MiB of the microservice container instance.\"\"\"\n        return self._image_size\n\n    @property\n    def volumes(self) -&gt; Optional[List[Tuple[str, str, int, bool]]]:\n        \"\"\"The volumes that are attached to each container instance, (name, path, size in MiB, retain or not).\"\"\"\n        return self._volumes\n\n    @property\n    def taint(self) -&gt; Optional[str]:\n        \"\"\"The taint of the microservice, used in scheduling.\"\"\"\n        return self._taint\n\n    @property\n    def min_num_containers(self) -&gt; int:\n        \"\"\"The minimum number of container instances.\"\"\"\n        return self._min_num_containers\n\n    @property\n    def max_num_containers(self) -&gt; int:\n        \"\"\"The maximum number of container instances.\"\"\"\n        return self._max_num_containers\n\n    @property\n    def ready(self) -&gt; bool:\n        \"\"\"Return True if the virtual microservice is ready.\"\"\"\n        return READY in self.status\n\n    @property\n    def cpu_usage(self) -&gt; float:\n        \"\"\"The CPU utilization of the virtual microservice.\"\"\"\n        return sum([container.cpu.utilization for container in self.containers]) / len(\n            self.containers\n        )\n\n    def cpu_usage_in_past(self, interval: float) -&gt; float:\n        \"\"\"The CPU utilization of the virtual microservice in the past interval.\"\"\"\n        return sum(\n            [\n                container.cpu.utilization_in_past(interval)\n                for container in self.containers\n                if container.scheduled\n            ]\n        ) / len(self.containers)\n\n    @property\n    def ram_usage(self) -&gt; float:\n        \"\"\"The RAM utilization of the virtual microservice.\"\"\"\n        return sum([container.ram.utilization for container in self.containers]) / len(\n            self.containers\n        )\n\n    def ram_usage_in_past(self, interval: float) -&gt; float:\n        \"\"\"The RAM utilization of the virtual microservice in the past interval.\"\"\"\n        return sum(\n            [\n                container.ram.utilization_in_past(interval)\n                for container in self.containers\n                if container.scheduled\n            ]\n        ) / len(self.containers)\n\n    @property\n    def deamon(self) -&gt; bool:\n        \"\"\"Return True if the virtual microservice has a deamon process.\"\"\"\n        return self._deamon\n\n    @property\n    def service(self) -&gt; vService:\n        \"\"\"Return the service of the virtual microservice.\"\"\"\n        return self._service\n</code></pre>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.containers","title":"<code>containers: List[vContainer]</code>  <code>property</code>","text":"<p>The container instances of the virtual microservice.</p>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.cpu","title":"<code>cpu: int</code>  <code>property</code>","text":"<p>The requested CPU time of the virtual microservice.</p>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.cpu_limit","title":"<code>cpu_limit: int</code>  <code>property</code>","text":"<p>The limited CPU time of the virtual microservice.</p>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.cpu_usage","title":"<code>cpu_usage: float</code>  <code>property</code>","text":"<p>The CPU utilization of the virtual microservice.</p>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.deamon","title":"<code>deamon: bool</code>  <code>property</code>","text":"<p>Return True if the virtual microservice has a deamon process.</p>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.image_size","title":"<code>image_size: int</code>  <code>property</code>","text":"<p>The image size in MiB of the microservice container instance.</p>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.max_num_containers","title":"<code>max_num_containers: int</code>  <code>property</code>","text":"<p>The maximum number of container instances.</p>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.min_num_containers","title":"<code>min_num_containers: int</code>  <code>property</code>","text":"<p>The minimum number of container instances.</p>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.ram","title":"<code>ram: int</code>  <code>property</code>","text":"<p>The requested RAM in MiB of the virtual microservice.</p>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.ram_limit","title":"<code>ram_limit: int</code>  <code>property</code>","text":"<p>The limited RAM in MiB of the virtual microservice.</p>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.ram_usage","title":"<code>ram_usage: float</code>  <code>property</code>","text":"<p>The RAM utilization of the virtual microservice.</p>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.ready","title":"<code>ready: bool</code>  <code>property</code>","text":"<p>Return True if the virtual microservice is ready.</p>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.service","title":"<code>service: vService</code>  <code>property</code>","text":"<p>Return the service of the virtual microservice.</p>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.taint","title":"<code>taint: Optional[str]</code>  <code>property</code>","text":"<p>The taint of the microservice, used in scheduling.</p>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.volumes","title":"<code>volumes: Optional[List[Tuple[str, str, int, bool]]]</code>  <code>property</code>","text":"<p>The volumes that are attached to each container instance, (name, path, size in MiB, retain or not).</p>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.__init__","title":"<code>__init__(cpu, cpu_limit, ram, ram_limit, image_size, volumes=None, taint=None, deamon=False, min_num_containers=1, max_num_containers=3, evaluation_interval=0.01, service=vServiceBestFit, ports=[], at=simulation.now, after=None, label=None)</code>","text":"<p>Create a virtual microservice.</p> <p>Parameters:</p> Name Type Description Default <code>cpu</code> <code>int</code> <p>the requested CPU time.</p> required <code>cpu_limit</code> <code>int</code> <p>the limited CPU time.</p> required <code>ram</code> <code>int</code> <p>the requested RAM in MiB.</p> required <code>ram_limit</code> <code>int</code> <p>the limited RAM in MiB.</p> required <code>image_size</code> <code>int</code> <p>the image size in MiB of the microservice container instance.</p> required <code>volumes</code> <code>Optional[List[Tuple[str, str, int, bool]]]</code> <p>The volumes that are attached to each container instance, (name, path, size in MiB, retain or not). Defaults to None.</p> <code>None</code> <code>taint</code> <code>Optional[str]</code> <p>the taint of the microservice, used in scheduling. Defaults to None.</p> <code>None</code> <code>deamon</code> <code>bool</code> <p>set true for create deamon process for container instance. Defaults to False.</p> <code>False</code> <code>min_num_containers</code> <code>int</code> <p>minimum number of container instances. Defaults to 1.</p> <code>1</code> <code>max_num_containers</code> <code>int</code> <p>maximum number of container instances. Defaults to 3.</p> <code>3</code> <code>evaluation_interval</code> <code>float</code> <p>the interval for horizontal scaler to check on the microservice. Defaults to 0.01.</p> <code>0.01</code> <code>service</code> <code>Type[vService]</code> <p>the service for this microservice, will determine the load balancing method. Defaults to vServiceBestFit.</p> <code>vServiceBestFit</code> <code>ports</code> <code>List[int]</code> <p>the port that are exposed. Defaults to [].</p> <code>[]</code> <code>at</code> <code>Union[int, float, Callable]</code> <p>same as entity. Defaults to simulation.now.</p> <code>now</code> <code>after</code> <code>Optional[Entity | List[Entity]]</code> <p>same as entity. Defaults to None.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>same as entity. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_microservice.py</code> <pre><code>def __init__(\n    self,\n    cpu: int,\n    cpu_limit: int,\n    ram: int,\n    ram_limit: int,\n    image_size: int,\n    volumes: Optional[List[Tuple[str, str, int, bool]]] = None,\n    taint: Optional[str] = None,\n    deamon: bool = False,\n    min_num_containers: int = 1,\n    max_num_containers: int = 3,\n    evaluation_interval: float = 0.01,\n    service: Type[vService] = vServiceBestFit,\n    ports: List[int] = [],\n    at: Union[int, float, Callable] = simulation.now,\n    after: Optional[Entity | List[Entity]] = None,\n    label: Optional[str] = None,\n):\n    \"\"\"Create a virtual microservice.\n\n    Args:\n        cpu (int): the requested CPU time.\n        cpu_limit (int): the limited CPU time.\n        ram (int): the requested RAM in MiB.\n        ram_limit (int): the limited RAM in MiB.\n        image_size (int): the image size in MiB of the microservice container instance.\n        volumes (Optional[List[Tuple[str, str, int, bool]]], optional): The volumes that are attached to each container instance, (name, path, size in MiB, retain or not). Defaults to None.\n        taint (Optional[str], optional): the taint of the microservice, used in scheduling. Defaults to None.\n        deamon (bool, optional): set true for create deamon process for container instance. Defaults to False.\n        min_num_containers (int, optional): minimum number of container instances. Defaults to 1.\n        max_num_containers (int, optional): maximum number of container instances. Defaults to 3.\n        evaluation_interval (float, optional): the interval for horizontal scaler to check on the microservice. Defaults to 0.01.\n        service (Type[vService], optional): the service for this microservice, will determine the load balancing method. Defaults to vServiceBestFit.\n        ports (List[int], optional): the port that are exposed. Defaults to [].\n        at (Union[int, float, Callable], optional): same as entity. Defaults to simulation.now.\n        after (Optional[Entity  |  List[Entity]], optional): same as entity. Defaults to None.\n        label (Optional[str], optional): same as entity. Defaults to None.\n    \"\"\"\n    super().__init__(at, after, label)\n\n    self._cpu = cpu\n    self._cpu_limit = cpu_limit\n    self._ram = ram\n    self._ram_limit = ram_limit\n    self._image_size = image_size\n    self._volumes = volumes\n    self._taint = taint\n    self._volumes = volumes\n    self._taint = taint\n    self._deamon = deamon\n\n    self._min_num_containers = min_num_containers\n    self._containers = list()\n    for i in range(min_num_containers):\n        container = vContainer(\n            cpu=cpu,\n            cpu_limit=cpu_limit,\n            ram=ram,\n            ram_limit=ram_limit,\n            image_size=image_size,\n            volumes=volumes,\n            taint=taint,\n            label=f\"{self.label}-{i}\",\n            deamon=self.deamon,\n        )\n        container._microservice_id = self.id\n        self.containers.append(container)\n    self._max_num_containers = max_num_containers\n    self._service = service(ms=self, ports=ports, label=f\"{self.label}-service\")\n    self._evaluator = Actor(\n        at=simulation.now,\n        step=evaluation_interval,\n        action=self.evaluate,\n        label=f\"vMicroservice {self.label} Evaluator\",\n    )\n    simulation.MICROSERVICES.append(self)\n</code></pre>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.cpu_usage_in_past","title":"<code>cpu_usage_in_past(interval)</code>","text":"<p>The CPU utilization of the virtual microservice in the past interval.</p> Source code in <code>PyCloudSim\\entity\\v_microservice.py</code> <pre><code>def cpu_usage_in_past(self, interval: float) -&gt; float:\n    \"\"\"The CPU utilization of the virtual microservice in the past interval.\"\"\"\n    return sum(\n        [\n            container.cpu.utilization_in_past(interval)\n            for container in self.containers\n            if container.scheduled\n        ]\n    ) / len(self.containers)\n</code></pre>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.evaluate","title":"<code>evaluate()</code>","text":"<p>Evaluate the status of the virtual microservice, and trigger scaling up or down.</p> Source code in <code>PyCloudSim\\entity\\v_microservice.py</code> <pre><code>def evaluate(self):\n    \"\"\"Evaluate the status of the virtual microservice, and trigger scaling up or down.\"\"\"\n    scheduled_container = [\n        container for container in self.containers if container.scheduled\n    ]\n    if len(scheduled_container) &gt;= self.min_num_containers:\n        self.status.append(READY)\n        LOGGER.info(f\"{simulation.now:0.2f}:\\tvMicroservice {self.label} is ready. {self.cpu_usage_in_past(0.01)} CPU, {self.ram_usage_in_past(0.01)} RAM.\")\n    else:\n        if self.ready:\n            self.status.remove(READY)\n        LOGGER.info(\n            f\"{simulation.now:0.2f}:\\tvMicroservice {self.label} is not ready, {len(scheduled_container)}/{self.min_num_containers}.\"\n        )\n\n    for sfc in simulation.SFCS:\n        if not sfc.ready:\n            sfc.evaluate()\n\n    if self.scale_up_triggered():\n        if (\n            len(self.containers) &lt; self.max_num_containers\n            and len(\n                [\n                    container\n                    for container in self.containers\n                    if not container.scheduled\n                ]\n            )\n            == 0\n        ):\n            new_container = vContainer(\n                cpu=self.cpu,\n                cpu_limit=self.cpu_limit,\n                ram=self.ram,\n                ram_limit=self.ram_limit,\n                image_size=self.image_size,\n                volumes=self.volumes,\n                taint=self.taint,\n                label=f\"{self.label}-{len(self.containers)}\",\n                deamon=self.deamon,\n            )\n            new_container._microservice_id = self.id\n            self.containers.append(new_container)\n            LOGGER.info(\n                f\"{simulation.now:0.2f}:\\tvMicroservice {self.label} scaled up one vContainer {new_container.label}.\"\n            )\n    elif self.scale_down_triggered():\n        if len(self.containers) &gt; self.min_num_containers:\n            self.containers.sort(key=lambda container: len(container.processes))\n            if len(self.containers[0].requests) == 0:\n                self.containers[0].terminate()\n                LOGGER.info(\n                    f\"{simulation.now:0.2f}:\\tvMicroservice {self.label} scaled down one vContainer {self.containers[0].label}.\"\n                )\n            else:\n                if (\n                    len(\n                        [\n                            container\n                            for container in self.containers\n                            if container.status == CORDON\n                        ]\n                    )\n                    == 0\n                ):\n                    self.containers[0].status.append(CORDON)\n                LOGGER.info(\n                    f\"{simulation.now:0.2f}:\\tvContainer {self.containers[0].label} is cordoned.\"\n                )\n</code></pre>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.ram_usage_in_past","title":"<code>ram_usage_in_past(interval)</code>","text":"<p>The RAM utilization of the virtual microservice in the past interval.</p> Source code in <code>PyCloudSim\\entity\\v_microservice.py</code> <pre><code>def ram_usage_in_past(self, interval: float) -&gt; float:\n    \"\"\"The RAM utilization of the virtual microservice in the past interval.\"\"\"\n    return sum(\n        [\n            container.ram.utilization_in_past(interval)\n            for container in self.containers\n            if container.scheduled\n        ]\n    ) / len(self.containers)\n</code></pre>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.recover","title":"<code>recover(container, detached_volumes=None)</code>","text":"<p>Recover a failed container instance.</p> Source code in <code>PyCloudSim\\entity\\v_microservice.py</code> <pre><code>def recover(\n    self, container: vContainer, detached_volumes: Optional[List[vVolume]] = None\n):\n    \"\"\"Recover a failed container instance.\"\"\"\n    def _recover():\n        # find non-retained volumes to recover\n        volumes_to_recover = list()\n        if self.volumes is not None and detached_volumes is not None:\n            for volume in detached_volumes:\n                for v_definitions in self.volumes:\n                    if (\n                        volume.tag == v_definitions[0]\n                        and volume.path == v_definitions[1]\n                    ):\n                        continue\n                    else:\n                        volumes_to_recover.append(v_definitions)\n        # recover container\n        recovered_container = vContainer(\n            cpu=self.cpu,\n            cpu_limit=self.cpu_limit,\n            ram=self.ram,\n            ram_limit=self.ram_limit,\n            image_size=self.image_size,\n            volumes=volumes_to_recover,\n            taint=self.taint,\n            label=container.label,\n            deamon=self.deamon,\n        )\n        recovered_container._microservice_id = self.id\n        if detached_volumes is not None:\n            for volume in detached_volumes:\n                volume.attach(recovered_container)\n        self._containers.append(recovered_container)\n        LOGGER.info(\n            f\"{simulation.now:0.2f}:\\tvMicroservice {self.label} recovered one failed containers.\"\n        )\n\n    if not self.terminated:\n        Actor(\n            at=simulation.now,\n            action=_recover,\n            label=f\"vMicroservice {self.label} Recover\",\n            priority=CREATION,\n        )\n</code></pre>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.scale_down_triggered","title":"<code>scale_down_triggered()</code>  <code>abstractmethod</code>","text":"<p>For developer to implement the scaling down trigger condition.</p> Source code in <code>PyCloudSim\\entity\\v_microservice.py</code> <pre><code>@abstractmethod\ndef scale_down_triggered(self) -&gt; bool:\n    \"\"\"For developer to implement the scaling down trigger condition.\"\"\"\n    pass\n</code></pre>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.scale_up_triggered","title":"<code>scale_up_triggered()</code>  <code>abstractmethod</code>","text":"<p>For developer to implement the scaling up trigger condition.</p> Source code in <code>PyCloudSim\\entity\\v_microservice.py</code> <pre><code>@abstractmethod\ndef scale_up_triggered(self) -&gt; bool:\n    \"\"\"For developer to implement the scaling up trigger condition.\"\"\"\n    pass\n</code></pre>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.termination","title":"<code>termination()</code>","text":"<p>Termination process of the virtual microservice.</p> Source code in <code>PyCloudSim\\entity\\v_microservice.py</code> <pre><code>def termination(self):\n    \"\"\"Termination process of the virtual microservice.\"\"\"\n    super().termination()\n    self.service.terminate()\n    for container in self.containers:\n        container.terminate()\n</code></pre>"},{"location":"api/virtual_entity/v_microservice/#default-vmicroservice","title":"Default vMicroservice","text":"<p>             Bases: <code>vMicroservice</code></p> Source code in <code>PyCloudSim\\entity\\v_microservice.py</code> <pre><code>class vMicroserviceDeafult(vMicroservice):\n    def __init__(\n        self,\n        cpu: int,\n        cpu_limit: int,\n        ram: int,\n        ram_limit: int,\n        image_size: int,\n        volumes: List[Tuple[str, str, int, bool]] | None = None,\n        taint: str | None = None,\n        deamon: bool = False,\n        min_num_containers: int = 1,\n        max_num_containers: int = 3,\n        evaluation_interval: float = 0.01,\n        cpu_lower_bound: float = 0.2,\n        cpu_upper_bound: float = 0.8,\n        ram_lower_bound: float = 0.2,\n        ram_upper_bound: float = 0.8,\n        cool_down_period: float = 5,\n        service: Type[vService] = vServiceBestFit,\n        ports: List[int] = [],\n        at: int | float | Callable[..., Any] = simulation.now,\n        after: Entity | List[Entity] | None = None,\n        label: str | None = None,\n    ):\n        \"\"\"Create a virtual microservice with default horizontal scaler.\"\"\"\n        super().__init__(\n            cpu,\n            cpu_limit,\n            ram,\n            ram_limit,\n            image_size,\n            volumes,\n            taint,\n            deamon,\n            min_num_containers,\n            max_num_containers,\n            evaluation_interval,\n            service,\n            ports,\n            at,\n            after,\n            label,\n        )\n        self._cpu_lower_bound = cpu_lower_bound\n        self._cpu_upper_bound = cpu_upper_bound\n        self._ram_lower_bound = ram_lower_bound\n        self._ram_upper_bound = ram_upper_bound\n        self._cool_down_period = cool_down_period\n\n    def scale_up_triggered(self) -&gt; bool:\n        \"\"\"Default scaling up trigger condition.\"\"\"\n        if (\n            self.cpu_usage &gt; self.cpu_upper_bound\n            or self.ram_usage &gt; self.ram_upper_bound\n        ):\n            return True\n        else:\n            return False\n\n    def scale_down_triggered(self) -&gt; bool:\n        \"\"\"Default scaling down trigger condition.\"\"\"\n        if (\n            self.cpu_usage &lt; self.cpu_lower_bound\n            and self.ram_usage &lt; self.ram_lower_bound\n        ):\n            return True\n        else:\n            return False\n\n    @property\n    def cpu_lower_bound(self) -&gt; float:\n        \"\"\"The lower bound of CPU utilization.\"\"\"\n        return self._cpu_lower_bound\n\n    @property\n    def cpu_upper_bound(self) -&gt; float:\n        \"\"\"The upper bound of CPU utilization.\"\"\"\n        return self._cpu_upper_bound\n\n    @property\n    def ram_lower_bound(self) -&gt; float:\n        \"\"\"The lower bound of RAM utilization.\"\"\"\n        return self._ram_lower_bound\n\n    @property\n    def ram_upper_bound(self) -&gt; float:\n        \"\"\"The upper bound of RAM utilization.\"\"\"\n        return self._ram_upper_bound\n\n    @property\n    def cool_down_period(self) -&gt; float:\n        \"\"\"The cool down period of the virtual microservice, no scaling operation will happen during cool down period.\"\"\"\n        return self._cool_down_period\n</code></pre>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroserviceDeafult.cool_down_period","title":"<code>cool_down_period: float</code>  <code>property</code>","text":"<p>The cool down period of the virtual microservice, no scaling operation will happen during cool down period.</p>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroserviceDeafult.cpu_lower_bound","title":"<code>cpu_lower_bound: float</code>  <code>property</code>","text":"<p>The lower bound of CPU utilization.</p>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroserviceDeafult.cpu_upper_bound","title":"<code>cpu_upper_bound: float</code>  <code>property</code>","text":"<p>The upper bound of CPU utilization.</p>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroserviceDeafult.ram_lower_bound","title":"<code>ram_lower_bound: float</code>  <code>property</code>","text":"<p>The lower bound of RAM utilization.</p>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroserviceDeafult.ram_upper_bound","title":"<code>ram_upper_bound: float</code>  <code>property</code>","text":"<p>The upper bound of RAM utilization.</p>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroserviceDeafult.__init__","title":"<code>__init__(cpu, cpu_limit, ram, ram_limit, image_size, volumes=None, taint=None, deamon=False, min_num_containers=1, max_num_containers=3, evaluation_interval=0.01, cpu_lower_bound=0.2, cpu_upper_bound=0.8, ram_lower_bound=0.2, ram_upper_bound=0.8, cool_down_period=5, service=vServiceBestFit, ports=[], at=simulation.now, after=None, label=None)</code>","text":"<p>Create a virtual microservice with default horizontal scaler.</p> Source code in <code>PyCloudSim\\entity\\v_microservice.py</code> <pre><code>def __init__(\n    self,\n    cpu: int,\n    cpu_limit: int,\n    ram: int,\n    ram_limit: int,\n    image_size: int,\n    volumes: List[Tuple[str, str, int, bool]] | None = None,\n    taint: str | None = None,\n    deamon: bool = False,\n    min_num_containers: int = 1,\n    max_num_containers: int = 3,\n    evaluation_interval: float = 0.01,\n    cpu_lower_bound: float = 0.2,\n    cpu_upper_bound: float = 0.8,\n    ram_lower_bound: float = 0.2,\n    ram_upper_bound: float = 0.8,\n    cool_down_period: float = 5,\n    service: Type[vService] = vServiceBestFit,\n    ports: List[int] = [],\n    at: int | float | Callable[..., Any] = simulation.now,\n    after: Entity | List[Entity] | None = None,\n    label: str | None = None,\n):\n    \"\"\"Create a virtual microservice with default horizontal scaler.\"\"\"\n    super().__init__(\n        cpu,\n        cpu_limit,\n        ram,\n        ram_limit,\n        image_size,\n        volumes,\n        taint,\n        deamon,\n        min_num_containers,\n        max_num_containers,\n        evaluation_interval,\n        service,\n        ports,\n        at,\n        after,\n        label,\n    )\n    self._cpu_lower_bound = cpu_lower_bound\n    self._cpu_upper_bound = cpu_upper_bound\n    self._ram_lower_bound = ram_lower_bound\n    self._ram_upper_bound = ram_upper_bound\n    self._cool_down_period = cool_down_period\n</code></pre>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroserviceDeafult.scale_down_triggered","title":"<code>scale_down_triggered()</code>","text":"<p>Default scaling down trigger condition.</p> Source code in <code>PyCloudSim\\entity\\v_microservice.py</code> <pre><code>def scale_down_triggered(self) -&gt; bool:\n    \"\"\"Default scaling down trigger condition.\"\"\"\n    if (\n        self.cpu_usage &lt; self.cpu_lower_bound\n        and self.ram_usage &lt; self.ram_lower_bound\n    ):\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"api/virtual_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroserviceDeafult.scale_up_triggered","title":"<code>scale_up_triggered()</code>","text":"<p>Default scaling up trigger condition.</p> Source code in <code>PyCloudSim\\entity\\v_microservice.py</code> <pre><code>def scale_up_triggered(self) -&gt; bool:\n    \"\"\"Default scaling up trigger condition.\"\"\"\n    if (\n        self.cpu_usage &gt; self.cpu_upper_bound\n        or self.ram_usage &gt; self.ram_upper_bound\n    ):\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"api/virtual_entity/v_service/","title":"vService","text":""},{"location":"api/virtual_entity/v_service/#PyCloudSim.entity.v_service.vService","title":"<code>vService</code>","text":"<p>             Bases: <code>VirtualEntity</code>, <code>ABC</code></p> Source code in <code>PyCloudSim\\entity\\v_service.py</code> <pre><code>class vService(VirtualEntity, ABC):\n    def __init__(\n        self,\n        ms: vMicroservice,\n        ports: List[int] = [],\n        at: int | float | Callable[..., Any] = simulation.now,\n        after: Entity | List[Entity] | None = None,\n        label: str | None = None,\n    ):\n        \"\"\"Base class for virtual services.\n\n        Args:\n            ms (vMicroservice): the associated vMicroservice.\n            ports (List[int], optional): the exposed ports for vContainers. Defaults to [].\n            at (int | float | Callable[..., Any], optional): same as entity. Defaults to simulation.now.\n            after (Entity | List[Entity] | None, optional): same as entity. Defaults to None.\n            label (str | None, optional): same as entity. Defaults to None.\n        \"\"\"        \n        super().__init__(at, after, label)\n        # assign the microservice\n        self._ms_id = ms.id\n        # assign the ip address\n        self._ip_address = choice(simulation.virtual_network_ips)\n        simulation.virtual_network_ips.remove(self.ip_address)\n        # ports\n        self._ports = ports\n\n    def creation(self):\n        \"\"\"Creation process of a vService.\"\"\"\n        return super().creation()\n\n    def termination(self):\n        \"\"\"Termination process of a vService.\"\"\"\n        return super().termination()\n\n    @abstractmethod\n    def loadbalancer(self) -&gt; vContainer:\n        \"\"\"The loadbalancer of the vService. Can be implemented by the developer.\"\"\"\n        pass\n\n    @property\n    def ms_id(self):\n        \"\"\"The id of the associated vMicroservice.\"\"\"\n        return self._ms_id\n\n    @property\n    def ip_address(self):\n        \"\"\"The ip address of the vService.\"\"\"\n        return self._ip_address\n\n    @property\n    def ms(self):\n        \"\"\"The associated vMicroservice.\"\"\"\n        for ms in simulation.MICROSERVICES:\n            if ms.id == self.ms_id:\n                return ms\n        raise Exception(\n            f\"Can not find associated vMicroservice for vService {self.id}.\"\n        )\n</code></pre>"},{"location":"api/virtual_entity/v_service/#PyCloudSim.entity.v_service.vService.ip_address","title":"<code>ip_address</code>  <code>property</code>","text":"<p>The ip address of the vService.</p>"},{"location":"api/virtual_entity/v_service/#PyCloudSim.entity.v_service.vService.ms","title":"<code>ms</code>  <code>property</code>","text":"<p>The associated vMicroservice.</p>"},{"location":"api/virtual_entity/v_service/#PyCloudSim.entity.v_service.vService.ms_id","title":"<code>ms_id</code>  <code>property</code>","text":"<p>The id of the associated vMicroservice.</p>"},{"location":"api/virtual_entity/v_service/#PyCloudSim.entity.v_service.vService.__init__","title":"<code>__init__(ms, ports=[], at=simulation.now, after=None, label=None)</code>","text":"<p>Base class for virtual services.</p> <p>Parameters:</p> Name Type Description Default <code>ms</code> <code>vMicroservice</code> <p>the associated vMicroservice.</p> required <code>ports</code> <code>List[int]</code> <p>the exposed ports for vContainers. Defaults to [].</p> <code>[]</code> <code>at</code> <code>int | float | Callable[..., Any]</code> <p>same as entity. Defaults to simulation.now.</p> <code>now</code> <code>after</code> <code>Entity | List[Entity] | None</code> <p>same as entity. Defaults to None.</p> <code>None</code> <code>label</code> <code>str | None</code> <p>same as entity. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_service.py</code> <pre><code>def __init__(\n    self,\n    ms: vMicroservice,\n    ports: List[int] = [],\n    at: int | float | Callable[..., Any] = simulation.now,\n    after: Entity | List[Entity] | None = None,\n    label: str | None = None,\n):\n    \"\"\"Base class for virtual services.\n\n    Args:\n        ms (vMicroservice): the associated vMicroservice.\n        ports (List[int], optional): the exposed ports for vContainers. Defaults to [].\n        at (int | float | Callable[..., Any], optional): same as entity. Defaults to simulation.now.\n        after (Entity | List[Entity] | None, optional): same as entity. Defaults to None.\n        label (str | None, optional): same as entity. Defaults to None.\n    \"\"\"        \n    super().__init__(at, after, label)\n    # assign the microservice\n    self._ms_id = ms.id\n    # assign the ip address\n    self._ip_address = choice(simulation.virtual_network_ips)\n    simulation.virtual_network_ips.remove(self.ip_address)\n    # ports\n    self._ports = ports\n</code></pre>"},{"location":"api/virtual_entity/v_service/#PyCloudSim.entity.v_service.vService.creation","title":"<code>creation()</code>","text":"<p>Creation process of a vService.</p> Source code in <code>PyCloudSim\\entity\\v_service.py</code> <pre><code>def creation(self):\n    \"\"\"Creation process of a vService.\"\"\"\n    return super().creation()\n</code></pre>"},{"location":"api/virtual_entity/v_service/#PyCloudSim.entity.v_service.vService.loadbalancer","title":"<code>loadbalancer()</code>  <code>abstractmethod</code>","text":"<p>The loadbalancer of the vService. Can be implemented by the developer.</p> Source code in <code>PyCloudSim\\entity\\v_service.py</code> <pre><code>@abstractmethod\ndef loadbalancer(self) -&gt; vContainer:\n    \"\"\"The loadbalancer of the vService. Can be implemented by the developer.\"\"\"\n    pass\n</code></pre>"},{"location":"api/virtual_entity/v_service/#PyCloudSim.entity.v_service.vService.termination","title":"<code>termination()</code>","text":"<p>Termination process of a vService.</p> Source code in <code>PyCloudSim\\entity\\v_service.py</code> <pre><code>def termination(self):\n    \"\"\"Termination process of a vService.\"\"\"\n    return super().termination()\n</code></pre>"},{"location":"api/virtual_entity/v_service/#PyCloudSim.entity.v_service.vServiceBestFit","title":"<code>vServiceBestFit</code>","text":"<p>             Bases: <code>vService</code></p> <p>vService with best fit loadbalancer.</p> Source code in <code>PyCloudSim\\entity\\v_service.py</code> <pre><code>class vServiceBestFit(vService):\n    \"\"\"vService with best fit loadbalancer.\"\"\"\n    def __init__(\n        self,\n        ms: vMicroservice,\n        ports: List[int] = [],\n        at: int | float | Callable[..., Any] = simulation.now,\n        after: Entity | List[Entity] | None = None,\n        label: str | None = None,\n    ):\n        super().__init__(ms, ports, at, after, label)\n\n    def loadbalancer(self):\n        self.ms.containers.sort(key=lambda x: x.ram.utilization)\n        self.ms.containers.sort(key=lambda x: x.cpu.utilization)\n        for container in self.ms.containers:\n            if container.scheduled and not container.cordon and not container.terminated:\n                return container\n        return None\n</code></pre>"},{"location":"api/virtual_entity/v_service/#PyCloudSim.entity.v_service.vServiceRandom","title":"<code>vServiceRandom</code>","text":"<p>             Bases: <code>vService</code></p> <p>vService with random loadbalancer.</p> Source code in <code>PyCloudSim\\entity\\v_service.py</code> <pre><code>class vServiceRandom(vService):\n    \"\"\"vService with random loadbalancer.\"\"\"\n    def __init__(\n        self,\n        ms: vMicroservice,\n        ports: List[int] = [],\n        at: int | float | Callable[..., Any] = simulation.now,\n        after: Entity | List[Entity] | None = None,\n        label: str | None = None,\n    ):\n        super().__init__(ms, ports, at, after, label)\n\n    def loadbalancer(self):\n        if all(container.scheduled == False for container in self.ms.containers):\n            return None\n        elif all(container.cordon == True for container in self.ms.containers):\n            return None\n        elif all(container.terminated == True for container in self.ms.containers):\n            return None\n        else:\n            while True:\n                container = choice(self.ms.containers)\n                if container.scheduled:\n                    return container\n</code></pre>"},{"location":"api/virtual_entity/v_service/#PyCloudSim.entity.v_service.vServiceRoundRobin","title":"<code>vServiceRoundRobin</code>","text":"<p>             Bases: <code>vService</code></p> <p>vService with round robin loadbalancer.</p> Source code in <code>PyCloudSim\\entity\\v_service.py</code> <pre><code>class vServiceRoundRobin(vService):\n    \"\"\"vService with round robin loadbalancer.\"\"\"\n    def __init__(\n        self,\n        ms: vMicroservice,\n        ports: List[int] = [],\n        at: int | float | Callable[..., Any] = simulation.now,\n        after: Entity | List[Entity] | None = None,\n        label: str | None = None,\n    ):\n        super().__init__(ms, ports, at, after, label)\n        self._container_pointer = 0\n\n    def loadbalancer(self):\n        if all(container.scheduled == False for container in self.ms.containers):\n            return None\n        elif all(container.cordon == True for container in self.ms.containers):\n            return None\n        elif all(container.terminated == True for container in self.ms.containers):\n            return None\n        else:\n            while True:\n                container = self.ms.containers[self.container_pointer]\n                self._container_pointer = (self.container_pointer + 1) % len(\n                    self.ms.containers\n                )\n                if container.scheduled:\n                    return container\n\n    @property\n    def container_pointer(self):\n        return self._container_pointer\n</code></pre>"},{"location":"api/virtual_entity/v_service/#PyCloudSim.entity.v_service.vServiceWorstFit","title":"<code>vServiceWorstFit</code>","text":"<p>             Bases: <code>vService</code></p> <p>vService with worst fit loadbalancer.</p> Source code in <code>PyCloudSim\\entity\\v_service.py</code> <pre><code>class vServiceWorstFit(vService):\n    \"\"\"vService with worst fit loadbalancer.\"\"\"\n    def __init__(\n        self,\n        ms: vMicroservice,\n        ports: List[int] = [],\n        at: int | float | Callable[..., Any] = simulation.now,\n        after: Entity | List[Entity] | None = None,\n        label: str | None = None,\n    ):\n        super().__init__(ms, ports, at, after, label)\n\n    def loadbalancer(self):\n        self.ms.containers.sort(key=lambda x: x.ram.utilization)\n        self.ms.containers.sort(key=lambda x: x.cpu.utilization)\n\n        for container in reversed(self.ms.containers):\n            if container.scheduled and not container.cordon and not container.terminated:\n                return container\n        return None\n</code></pre>"},{"location":"api/virtual_entity/v_user/","title":"vUser","text":"<p>             Bases: <code>VirtualEntity</code></p> Source code in <code>PyCloudSim\\entity\\v_user.py</code> <pre><code>class vUser(VirtualEntity):\n    _requests: List[vRequest]\n\n    def __init__(\n        self,\n        at: Union[int, float, Callable] = simulation.now,\n        after: Optional[Entity | List[Entity]] = None,\n        label: Optional[str] = None,\n    ):\n        \"\"\"Create a vUser.\"\"\"\n        super().__init__(at, after, label)\n\n        self._user_requests: List[vUserRequest] = list()\n        simulation.USERS.append(self)\n\n    def creation(self):\n        \"\"\"Creation process of the vUser\"\"\"\n        return super().creation()\n\n    def termination(self):\n        \"\"\"Termination process of the vUser\"\"\"\n        return super().termination()\n\n    def request_sfc(\n        self,\n        sfc: vSFC,\n        priority: Union[int, Callable] = 0,\n        retry: Union[bool, Callable] = True,\n        backoff: Union[int, float, Callable] = lambda: random.random(),\n        process_length: Union[int, Callable] = 100,\n        packet_size: Union[int, Callable] = 65536,\n        num_packets: Union[int, Callable] = 1,\n        at: Union[int, float, Callable] = simulation.now,\n        after: Optional[Entity | List[Entity]] = None,\n    ):\n        \"\"\"Request a vSFC.\n\n        Args:\n            sfc (vSFC): the requested vSFC.\n            priority (Union[int, Callable], optional): the priority of the user request. Defaults to 0.\n            retry (Union[bool, Callable], optional): set to true if the user request will repeat untill sucess. Defaults to True.\n            backoff (_type_, optional): the random backoff. Defaults to lambda:random.random().\n            process_length (Union[int, Callable], optional): the length of generated process. Defaults to 100.\n            packet_size (Union[int, Callable], optional): the packet size of the packet size. Defaults to 65536.\n            num_packets (Union[int, Callable], optional): the number of the packet for this user request. Defaults to 1.\n            at (Union[int, float, Callable], optional): same as entity. Defaults to simulation.now.\n            after (Optional[Entity  |  List[Entity]], optional): same as entity. Defaults to None.\n        \"\"\"        \n        user_request = vUserRequest(\n            at=at,\n            after=after,\n            user=self,\n            sfc=sfc,\n            priority=priority,\n            process_length=process_length,\n            packet_size=packet_size,\n            num_packets=num_packets,\n            retry=retry,\n            backoff=backoff,\n            label=f\"U-{self.label}-R-{len(self.user_request)}-SFC-{sfc.label}\",\n        )\n        self.user_request.append(user_request)\n        return user_request\n\n    @property\n    def user_request(self) -&gt; List[vUserRequest]:\n        \"\"\"The list of user requests of the vUser.\"\"\"\n        return self._user_requests\n</code></pre>"},{"location":"api/virtual_entity/v_user/#PyCloudSim.entity.v_user.vUser.user_request","title":"<code>user_request: List[vUserRequest]</code>  <code>property</code>","text":"<p>The list of user requests of the vUser.</p>"},{"location":"api/virtual_entity/v_user/#PyCloudSim.entity.v_user.vUser.__init__","title":"<code>__init__(at=simulation.now, after=None, label=None)</code>","text":"<p>Create a vUser.</p> Source code in <code>PyCloudSim\\entity\\v_user.py</code> <pre><code>def __init__(\n    self,\n    at: Union[int, float, Callable] = simulation.now,\n    after: Optional[Entity | List[Entity]] = None,\n    label: Optional[str] = None,\n):\n    \"\"\"Create a vUser.\"\"\"\n    super().__init__(at, after, label)\n\n    self._user_requests: List[vUserRequest] = list()\n    simulation.USERS.append(self)\n</code></pre>"},{"location":"api/virtual_entity/v_user/#PyCloudSim.entity.v_user.vUser.creation","title":"<code>creation()</code>","text":"<p>Creation process of the vUser</p> Source code in <code>PyCloudSim\\entity\\v_user.py</code> <pre><code>def creation(self):\n    \"\"\"Creation process of the vUser\"\"\"\n    return super().creation()\n</code></pre>"},{"location":"api/virtual_entity/v_user/#PyCloudSim.entity.v_user.vUser.request_sfc","title":"<code>request_sfc(sfc, priority=0, retry=True, backoff=lambda : random.random(), process_length=100, packet_size=65536, num_packets=1, at=simulation.now, after=None)</code>","text":"<p>Request a vSFC.</p> <p>Parameters:</p> Name Type Description Default <code>sfc</code> <code>vSFC</code> <p>the requested vSFC.</p> required <code>priority</code> <code>Union[int, Callable]</code> <p>the priority of the user request. Defaults to 0.</p> <code>0</code> <code>retry</code> <code>Union[bool, Callable]</code> <p>set to true if the user request will repeat untill sucess. Defaults to True.</p> <code>True</code> <code>backoff</code> <code>_type_</code> <p>the random backoff. Defaults to lambda:random.random().</p> <code>lambda : random()</code> <code>process_length</code> <code>Union[int, Callable]</code> <p>the length of generated process. Defaults to 100.</p> <code>100</code> <code>packet_size</code> <code>Union[int, Callable]</code> <p>the packet size of the packet size. Defaults to 65536.</p> <code>65536</code> <code>num_packets</code> <code>Union[int, Callable]</code> <p>the number of the packet for this user request. Defaults to 1.</p> <code>1</code> <code>at</code> <code>Union[int, float, Callable]</code> <p>same as entity. Defaults to simulation.now.</p> <code>now</code> <code>after</code> <code>Optional[Entity | List[Entity]]</code> <p>same as entity. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_user.py</code> <pre><code>def request_sfc(\n    self,\n    sfc: vSFC,\n    priority: Union[int, Callable] = 0,\n    retry: Union[bool, Callable] = True,\n    backoff: Union[int, float, Callable] = lambda: random.random(),\n    process_length: Union[int, Callable] = 100,\n    packet_size: Union[int, Callable] = 65536,\n    num_packets: Union[int, Callable] = 1,\n    at: Union[int, float, Callable] = simulation.now,\n    after: Optional[Entity | List[Entity]] = None,\n):\n    \"\"\"Request a vSFC.\n\n    Args:\n        sfc (vSFC): the requested vSFC.\n        priority (Union[int, Callable], optional): the priority of the user request. Defaults to 0.\n        retry (Union[bool, Callable], optional): set to true if the user request will repeat untill sucess. Defaults to True.\n        backoff (_type_, optional): the random backoff. Defaults to lambda:random.random().\n        process_length (Union[int, Callable], optional): the length of generated process. Defaults to 100.\n        packet_size (Union[int, Callable], optional): the packet size of the packet size. Defaults to 65536.\n        num_packets (Union[int, Callable], optional): the number of the packet for this user request. Defaults to 1.\n        at (Union[int, float, Callable], optional): same as entity. Defaults to simulation.now.\n        after (Optional[Entity  |  List[Entity]], optional): same as entity. Defaults to None.\n    \"\"\"        \n    user_request = vUserRequest(\n        at=at,\n        after=after,\n        user=self,\n        sfc=sfc,\n        priority=priority,\n        process_length=process_length,\n        packet_size=packet_size,\n        num_packets=num_packets,\n        retry=retry,\n        backoff=backoff,\n        label=f\"U-{self.label}-R-{len(self.user_request)}-SFC-{sfc.label}\",\n    )\n    self.user_request.append(user_request)\n    return user_request\n</code></pre>"},{"location":"api/virtual_entity/v_user/#PyCloudSim.entity.v_user.vUser.termination","title":"<code>termination()</code>","text":"<p>Termination process of the vUser</p> Source code in <code>PyCloudSim\\entity\\v_user.py</code> <pre><code>def termination(self):\n    \"\"\"Termination process of the vUser\"\"\"\n    return super().termination()\n</code></pre>"},{"location":"api/virtual_entity/v_user/#vuserrequest","title":"vUserRequest","text":"<p>             Bases: <code>VirtualEntity</code></p> Source code in <code>PyCloudSim\\entity\\v_user.py</code> <pre><code>class vUserRequest(VirtualEntity):\n    def __init__(\n        self,\n        user: vUser,\n        sfc: vSFC,\n        priority: Union[int, Callable] = 0,\n        retry: Union[bool, Callable] = True,\n        backoff: Union[int, float, Callable] = lambda: random.random(),\n        process_length: Union[int, Callable] = 100,\n        packet_size: Union[int, Callable] = 65536,\n        num_packets: Union[int, Callable] = 1,\n        at: int | float | Callable[..., Any] = simulation.now,\n        after: Entity | List[Entity] | None = None,\n        label: str | None = None,\n    ):\n        \"\"\"Create a new vUserRequest.\n\n        Args:\n            user (vUser): the vUser.\n            sfc (vSFC): the requested vSFC.\n            priority (Union[int, Callable], optional): the priority of the user request. Defaults to 0.\n            retry (Union[bool, Callable], optional): set to true if repeat untill sucess. Defaults to True.\n            backoff (_type_, optional): the random backoff. Defaults to lambda:random.random().\n            process_length (Union[int, Callable], optional): the length of the generated process. Defaults to 100.\n            packet_size (Union[int, Callable], optional): the size of the generated packets. Defaults to 65536.\n            num_packets (Union[int, Callable], optional): the number of generated packets. Defaults to 1.\n            at (int | float | Callable[..., Any], optional): same as entity. Defaults to simulation.now.\n            after (Entity | List[Entity] | None, optional): same as entity. Defaults to None.\n            label (str | None, optional): same as entity. Defaults to None.\n        \"\"\"\n        super().__init__(at, after, label)\n        self._user = user\n        self._sfc_id = sfc.id\n        self._priority = priority\n        self._retry = retry\n        self._backoff = backoff\n        self._process_length = process_length\n        self._packet_size = packet_size\n        self._num_packets = num_packets\n        self._flows: List[WorkFlow] = list()\n\n    def creation(self):\n        \"\"\"Creation process of the vUserRequest\"\"\"\n        self.initialize_workflow()\n        simulation.USER_REQUESTS.append(self)\n        return super().creation()\n\n    def initialize_workflow(self, delay: int | float = 0):\n        \"\"\"Initialize a workflow for the user request.\"\"\"\n        def _initialize_workflow():\n            if self.sfc.ready:\n                flow = WorkFlow(\n                    at=simulation.now,\n                    user=self.user,\n                    user_request=self,\n                    sfc=self.sfc,\n                    priority=self.priority,\n                    process_length=self.process_length,\n                    packet_size=self.packet_size,\n                    num_packets=self.num_packets,\n                    label=f\"{self.label}-F-{len(self.flows)}\",\n                )\n                self.flows.append(flow)\n                LOGGER.info(\n                    f\"{simulation.now:0.2f}:\\tvUser {self.label} requests SFC {self.sfc.label} as WorkFlow {flow.label}.\"\n                )\n            else:\n                if callable(self.backoff):\n                    Actor(\n                        at=simulation.now + self.backoff(),\n                        action=_initialize_workflow,\n                        label=f\"vUserRequest {self.label} Initialize Workflow\",\n                    )\n                else:\n                    Actor(\n                        at=simulation.now + self.backoff,\n                        action=_initialize_workflow,\n                        label=f\"vUserRequest {self.label} Initialize Workflow\",\n                    )\n                LOGGER.info(\n                    f\"{simulation.now:0.2f}:\\tvUserRequest {self.label} backs off Workflow initialization because SFC {self.sfc.label} is not ready.\"\n                )\n        Actor(\n            at=simulation.now+delay,\n            action=_initialize_workflow,\n            label=f\"vUserRequest {self.label} Initialize Workflow\",\n            priority=CREATION\n        )\n\n    def termination(self):\n        \"\"\"Termination process of the vUserRequest\"\"\"\n        super().termination()\n        if all(user_request.completed for user_request in simulation.USER_REQUESTS):\n            simulation._env.stop()\n\n    def fail(self):\n        \"\"\"Fail the user request and engage the termination process if no retry is set.\"\"\"\n        LOGGER.info(f\"{simulation.now:0.2f}:\\tvUserRequest {self.label} failed, retries.\")\n        if callable(self.backoff):\n            self.initialize_workflow(delay=self.backoff())\n        else:\n            self.initialize_workflow(delay=self.backoff)\n\n    def complete(self):\n        \"\"\"Complete the user request and engage the termination process.\"\"\"\n        self.status.append(COMPLETED)\n        LOGGER.info(f\"{simulation.now:0.2f}:\\tvUserRequest {self.label} completed.\")\n        self.terminate()\n\n\n    @property\n    def user(self):\n        \"\"\"Return the vUser of the vUserRequest.\"\"\"\n        return self._user\n\n    @property\n    def process_length(self):\n        \"\"\"Return the process length of the vUserRequest.\"\"\"\n        return self._process_length\n\n    @property\n    def packet_size(self):\n        \"\"\"Return the packet size\"\"\"\n        return self._packet_size\n\n    @property\n    def num_packets(self):\n        \"\"\"Return the number of packets\"\"\"\n        return self._num_packets\n\n    @property\n    def priority(self):\n        \"\"\"Return the priority of the vUserRequest.\"\"\"\n        return self._priority\n\n    @property\n    def retry(self):\n        \"\"\"Return the retry of the vUserRequest.\"\"\"\n        return self._retry\n\n    @property\n    def backoff(self):\n        \"\"\"Return the backoff of the vUserRequest.\"\"\"\n        return self._backoff\n\n    @property\n    def sfc_id(self):\n        \"\"\"Return the sfc id of the vUserRequest.\"\"\"\n        return self._sfc_id\n\n    @property\n    def sfc(self) -&gt; vSFC:\n        \"\"\"Return the vSFC of the vUserRequest.\"\"\"\n        for sfc in simulation.SFCS:\n            if sfc.id == self._sfc_id:\n                return sfc\n        raise ValueError(f\"SFCFlow {self.label} can not find its associated vSFC.\")\n\n    @property\n    def flows(self) -&gt; List[WorkFlow]:\n        \"\"\"Return the list of WorkFlows of the vUserRequest.\"\"\"\n        return self._flows\n</code></pre>"},{"location":"api/virtual_entity/v_user/#PyCloudSim.entity.v_user.vUserRequest.backoff","title":"<code>backoff</code>  <code>property</code>","text":"<p>Return the backoff of the vUserRequest.</p>"},{"location":"api/virtual_entity/v_user/#PyCloudSim.entity.v_user.vUserRequest.flows","title":"<code>flows: List[WorkFlow]</code>  <code>property</code>","text":"<p>Return the list of WorkFlows of the vUserRequest.</p>"},{"location":"api/virtual_entity/v_user/#PyCloudSim.entity.v_user.vUserRequest.num_packets","title":"<code>num_packets</code>  <code>property</code>","text":"<p>Return the number of packets</p>"},{"location":"api/virtual_entity/v_user/#PyCloudSim.entity.v_user.vUserRequest.packet_size","title":"<code>packet_size</code>  <code>property</code>","text":"<p>Return the packet size</p>"},{"location":"api/virtual_entity/v_user/#PyCloudSim.entity.v_user.vUserRequest.priority","title":"<code>priority</code>  <code>property</code>","text":"<p>Return the priority of the vUserRequest.</p>"},{"location":"api/virtual_entity/v_user/#PyCloudSim.entity.v_user.vUserRequest.process_length","title":"<code>process_length</code>  <code>property</code>","text":"<p>Return the process length of the vUserRequest.</p>"},{"location":"api/virtual_entity/v_user/#PyCloudSim.entity.v_user.vUserRequest.retry","title":"<code>retry</code>  <code>property</code>","text":"<p>Return the retry of the vUserRequest.</p>"},{"location":"api/virtual_entity/v_user/#PyCloudSim.entity.v_user.vUserRequest.sfc","title":"<code>sfc: vSFC</code>  <code>property</code>","text":"<p>Return the vSFC of the vUserRequest.</p>"},{"location":"api/virtual_entity/v_user/#PyCloudSim.entity.v_user.vUserRequest.sfc_id","title":"<code>sfc_id</code>  <code>property</code>","text":"<p>Return the sfc id of the vUserRequest.</p>"},{"location":"api/virtual_entity/v_user/#PyCloudSim.entity.v_user.vUserRequest.user","title":"<code>user</code>  <code>property</code>","text":"<p>Return the vUser of the vUserRequest.</p>"},{"location":"api/virtual_entity/v_user/#PyCloudSim.entity.v_user.vUserRequest.__init__","title":"<code>__init__(user, sfc, priority=0, retry=True, backoff=lambda : random.random(), process_length=100, packet_size=65536, num_packets=1, at=simulation.now, after=None, label=None)</code>","text":"<p>Create a new vUserRequest.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>vUser</code> <p>the vUser.</p> required <code>sfc</code> <code>vSFC</code> <p>the requested vSFC.</p> required <code>priority</code> <code>Union[int, Callable]</code> <p>the priority of the user request. Defaults to 0.</p> <code>0</code> <code>retry</code> <code>Union[bool, Callable]</code> <p>set to true if repeat untill sucess. Defaults to True.</p> <code>True</code> <code>backoff</code> <code>_type_</code> <p>the random backoff. Defaults to lambda:random.random().</p> <code>lambda : random()</code> <code>process_length</code> <code>Union[int, Callable]</code> <p>the length of the generated process. Defaults to 100.</p> <code>100</code> <code>packet_size</code> <code>Union[int, Callable]</code> <p>the size of the generated packets. Defaults to 65536.</p> <code>65536</code> <code>num_packets</code> <code>Union[int, Callable]</code> <p>the number of generated packets. Defaults to 1.</p> <code>1</code> <code>at</code> <code>int | float | Callable[..., Any]</code> <p>same as entity. Defaults to simulation.now.</p> <code>now</code> <code>after</code> <code>Entity | List[Entity] | None</code> <p>same as entity. Defaults to None.</p> <code>None</code> <code>label</code> <code>str | None</code> <p>same as entity. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_user.py</code> <pre><code>def __init__(\n    self,\n    user: vUser,\n    sfc: vSFC,\n    priority: Union[int, Callable] = 0,\n    retry: Union[bool, Callable] = True,\n    backoff: Union[int, float, Callable] = lambda: random.random(),\n    process_length: Union[int, Callable] = 100,\n    packet_size: Union[int, Callable] = 65536,\n    num_packets: Union[int, Callable] = 1,\n    at: int | float | Callable[..., Any] = simulation.now,\n    after: Entity | List[Entity] | None = None,\n    label: str | None = None,\n):\n    \"\"\"Create a new vUserRequest.\n\n    Args:\n        user (vUser): the vUser.\n        sfc (vSFC): the requested vSFC.\n        priority (Union[int, Callable], optional): the priority of the user request. Defaults to 0.\n        retry (Union[bool, Callable], optional): set to true if repeat untill sucess. Defaults to True.\n        backoff (_type_, optional): the random backoff. Defaults to lambda:random.random().\n        process_length (Union[int, Callable], optional): the length of the generated process. Defaults to 100.\n        packet_size (Union[int, Callable], optional): the size of the generated packets. Defaults to 65536.\n        num_packets (Union[int, Callable], optional): the number of generated packets. Defaults to 1.\n        at (int | float | Callable[..., Any], optional): same as entity. Defaults to simulation.now.\n        after (Entity | List[Entity] | None, optional): same as entity. Defaults to None.\n        label (str | None, optional): same as entity. Defaults to None.\n    \"\"\"\n    super().__init__(at, after, label)\n    self._user = user\n    self._sfc_id = sfc.id\n    self._priority = priority\n    self._retry = retry\n    self._backoff = backoff\n    self._process_length = process_length\n    self._packet_size = packet_size\n    self._num_packets = num_packets\n    self._flows: List[WorkFlow] = list()\n</code></pre>"},{"location":"api/virtual_entity/v_user/#PyCloudSim.entity.v_user.vUserRequest.complete","title":"<code>complete()</code>","text":"<p>Complete the user request and engage the termination process.</p> Source code in <code>PyCloudSim\\entity\\v_user.py</code> <pre><code>def complete(self):\n    \"\"\"Complete the user request and engage the termination process.\"\"\"\n    self.status.append(COMPLETED)\n    LOGGER.info(f\"{simulation.now:0.2f}:\\tvUserRequest {self.label} completed.\")\n    self.terminate()\n</code></pre>"},{"location":"api/virtual_entity/v_user/#PyCloudSim.entity.v_user.vUserRequest.creation","title":"<code>creation()</code>","text":"<p>Creation process of the vUserRequest</p> Source code in <code>PyCloudSim\\entity\\v_user.py</code> <pre><code>def creation(self):\n    \"\"\"Creation process of the vUserRequest\"\"\"\n    self.initialize_workflow()\n    simulation.USER_REQUESTS.append(self)\n    return super().creation()\n</code></pre>"},{"location":"api/virtual_entity/v_user/#PyCloudSim.entity.v_user.vUserRequest.fail","title":"<code>fail()</code>","text":"<p>Fail the user request and engage the termination process if no retry is set.</p> Source code in <code>PyCloudSim\\entity\\v_user.py</code> <pre><code>def fail(self):\n    \"\"\"Fail the user request and engage the termination process if no retry is set.\"\"\"\n    LOGGER.info(f\"{simulation.now:0.2f}:\\tvUserRequest {self.label} failed, retries.\")\n    if callable(self.backoff):\n        self.initialize_workflow(delay=self.backoff())\n    else:\n        self.initialize_workflow(delay=self.backoff)\n</code></pre>"},{"location":"api/virtual_entity/v_user/#PyCloudSim.entity.v_user.vUserRequest.initialize_workflow","title":"<code>initialize_workflow(delay=0)</code>","text":"<p>Initialize a workflow for the user request.</p> Source code in <code>PyCloudSim\\entity\\v_user.py</code> <pre><code>def initialize_workflow(self, delay: int | float = 0):\n    \"\"\"Initialize a workflow for the user request.\"\"\"\n    def _initialize_workflow():\n        if self.sfc.ready:\n            flow = WorkFlow(\n                at=simulation.now,\n                user=self.user,\n                user_request=self,\n                sfc=self.sfc,\n                priority=self.priority,\n                process_length=self.process_length,\n                packet_size=self.packet_size,\n                num_packets=self.num_packets,\n                label=f\"{self.label}-F-{len(self.flows)}\",\n            )\n            self.flows.append(flow)\n            LOGGER.info(\n                f\"{simulation.now:0.2f}:\\tvUser {self.label} requests SFC {self.sfc.label} as WorkFlow {flow.label}.\"\n            )\n        else:\n            if callable(self.backoff):\n                Actor(\n                    at=simulation.now + self.backoff(),\n                    action=_initialize_workflow,\n                    label=f\"vUserRequest {self.label} Initialize Workflow\",\n                )\n            else:\n                Actor(\n                    at=simulation.now + self.backoff,\n                    action=_initialize_workflow,\n                    label=f\"vUserRequest {self.label} Initialize Workflow\",\n                )\n            LOGGER.info(\n                f\"{simulation.now:0.2f}:\\tvUserRequest {self.label} backs off Workflow initialization because SFC {self.sfc.label} is not ready.\"\n            )\n    Actor(\n        at=simulation.now+delay,\n        action=_initialize_workflow,\n        label=f\"vUserRequest {self.label} Initialize Workflow\",\n        priority=CREATION\n    )\n</code></pre>"},{"location":"api/virtual_entity/v_user/#PyCloudSim.entity.v_user.vUserRequest.termination","title":"<code>termination()</code>","text":"<p>Termination process of the vUserRequest</p> Source code in <code>PyCloudSim\\entity\\v_user.py</code> <pre><code>def termination(self):\n    \"\"\"Termination process of the vUserRequest\"\"\"\n    super().termination()\n    if all(user_request.completed for user_request in simulation.USER_REQUESTS):\n        simulation._env.stop()\n</code></pre>"},{"location":"api/virtual_entity/v_user/#workflow","title":"WorkFLow","text":"<p>             Bases: <code>VirtualEntity</code></p> Source code in <code>PyCloudSim\\entity\\v_user.py</code> <pre><code>class WorkFlow(VirtualEntity):\n    def __init__(\n        self,\n        user: vUser,\n        user_request: vUserRequest,\n        sfc: vSFC,\n        process_length: Union[int, Callable] = 100,\n        packet_size: Union[int, Callable] = 65536,\n        num_packets: Union[int, Callable] = 1,\n        priority: Union[int, Callable] = 0,\n        at: int | float | Callable[..., Any] = simulation.now,\n        after: Entity | List[Entity] | None = None,\n        label: str | None = None,\n    ):\n        \"\"\"Create a new WorkFlow.\n\n        Args:\n            user (vUser): the vUser.\n            sfc (vSFC): the vSFC.\n            process_length (Union[int, Callable], optional): the process length. Defaults to 100.\n            packet_size (Union[int, Callable], optional): the packet size. Defaults to 65536.\n            num_packets (Union[int, Callable], optional): the number of packet (Do not change the GET/ACK packet). Defaults to 1.\n            priority (Union[int, Callable], optional): the priority of the workflow. Defaults to 0.\n            retry (Union[bool, Callable], optional): set true for retrying until complete. Defaults to True.\n            retry_delay (_type_, optional): the delay beofore retrying the workflow. Defaults to lambda:random.random().\n            at (int | float | Callable[..., Any], optional): when the workflow should be created. Defaults to simulation.now.\n            after (Entity | List[Entity] | None, optional): the entity that the workflow must be created after. Defaults to None.\n            label (str | None, optional): short desciption of the workflow. Defaults to None.\n        \"\"\"\n        super().__init__(at, after, label)\n        self._user = user\n        self._user_request = user_request\n        self._sfc_id = sfc.id\n        self._process_length = process_length\n        self._packet_size = packet_size\n        self._num_packets = num_packets\n        self._priority = priority\n        self._requests = list()\n        self._on_creation = self.initialize_requests\n        simulation.WORKFLOWS.append(self)\n\n    def termination(self):\n        if self.completed:\n            self.user_request.complete()\n\n        if self.failed:\n            self.user_request.fail()            \n        super().termination()\n\n    def initialize_requests(self, delay: int | float = 0):\n        if self.sfc.entry is not None and not self.sfc.internal:\n            self.requests.append(\n                vRequest(\n                    at=simulation.now,\n                    source=self.user,\n                    target=self.sfc.entry[0],\n                    flow=self,\n                    type=self.sfc.entry[1],\n                    label=f\"{self.label}-R-{len(self.requests)}\",\n                )\n            )\n        # initialize path request\n        for link in self.sfc.path:\n            self.requests.append(\n                vRequest(\n                    at=simulation.now,\n                    source=link[0],\n                    target=link[1],\n                    type=link[2],\n                    flow=self,\n                    label=f\"{self.label}-R-{len(self.requests)}\",\n                    after=self.requests[-1] if len(self.requests) &gt; 0 else None,\n                )\n            )\n        # initialize tail request\n        if self.sfc.exit is not None and not self.sfc.internal:\n            self.requests.append(\n                vRequest(\n                    at=simulation.now,\n                    source=self.sfc.exit[0],\n                    target=self.user,\n                    type=self.sfc.exit[1],\n                    flow=self,\n                    label=f\"{self.label}-R-{len(self.requests)}\",\n                    after=self.requests[-1] if len(self.requests) &gt; 0 else None,\n                )\n            )\n\n        self.requests[-1]._on_termination = (\n            lambda: self.complete()\n            if self.requests[-1].completed and not self.failed\n            else None\n        )\n        LOGGER.info(\n            f\"{simulation.now:0.2f}:\\tWorkflow {self.label} initialized vRequests.\"\n        )\n\n    def complete(self):\n        \"\"\"COMPLETE the workflow and engage the termination process.\"\"\"\n        self.status.append(COMPLETED)\n        self.terminate()\n        LOGGER.info(f\"{simulation.now:0.2f}:\\tWorkflow {self.label} completed.\")\n\n    def fail(self):\n        \"\"\"Fail the workflow and engage the termination process if no retry is set.\"\"\"\n        self.status.append(FAILED)\n        self.terminate()\n        LOGGER.info(f\"{simulation.now:0.2f}:\\tWorkflow {self.label} failed.\")\n\n    @property\n    def requests(self) -&gt; List[vRequest]:\n        return self._requests\n\n    @property\n    def user(self):\n        return self._user\n\n    @property\n    def user_request(self):\n        return self._user_request\n\n    @property\n    def process_length(self):\n        return self._process_length\n\n    @property\n    def packet_size(self):\n        return self._packet_size\n\n    @property\n    def num_packets(self):\n        return self._num_packets\n\n    @property\n    def priority(self):\n        return self._priority\n\n    @property\n    def sfc_id(self):\n        return self._sfc_id\n\n    @property\n    def sfc(self) -&gt; vSFC:\n        for sfc in simulation.SFCS:\n            if sfc.id == self._sfc_id:\n                return sfc\n        raise ValueError(f\"SFCFlow {self.label} can not find its associated vSFC.\")\n</code></pre>"},{"location":"api/virtual_entity/v_user/#PyCloudSim.entity.v_user.WorkFlow.__init__","title":"<code>__init__(user, user_request, sfc, process_length=100, packet_size=65536, num_packets=1, priority=0, at=simulation.now, after=None, label=None)</code>","text":"<p>Create a new WorkFlow.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>vUser</code> <p>the vUser.</p> required <code>sfc</code> <code>vSFC</code> <p>the vSFC.</p> required <code>process_length</code> <code>Union[int, Callable]</code> <p>the process length. Defaults to 100.</p> <code>100</code> <code>packet_size</code> <code>Union[int, Callable]</code> <p>the packet size. Defaults to 65536.</p> <code>65536</code> <code>num_packets</code> <code>Union[int, Callable]</code> <p>the number of packet (Do not change the GET/ACK packet). Defaults to 1.</p> <code>1</code> <code>priority</code> <code>Union[int, Callable]</code> <p>the priority of the workflow. Defaults to 0.</p> <code>0</code> <code>retry</code> <code>Union[bool, Callable]</code> <p>set true for retrying until complete. Defaults to True.</p> required <code>retry_delay</code> <code>_type_</code> <p>the delay beofore retrying the workflow. Defaults to lambda:random.random().</p> required <code>at</code> <code>int | float | Callable[..., Any]</code> <p>when the workflow should be created. Defaults to simulation.now.</p> <code>now</code> <code>after</code> <code>Entity | List[Entity] | None</code> <p>the entity that the workflow must be created after. Defaults to None.</p> <code>None</code> <code>label</code> <code>str | None</code> <p>short desciption of the workflow. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_user.py</code> <pre><code>def __init__(\n    self,\n    user: vUser,\n    user_request: vUserRequest,\n    sfc: vSFC,\n    process_length: Union[int, Callable] = 100,\n    packet_size: Union[int, Callable] = 65536,\n    num_packets: Union[int, Callable] = 1,\n    priority: Union[int, Callable] = 0,\n    at: int | float | Callable[..., Any] = simulation.now,\n    after: Entity | List[Entity] | None = None,\n    label: str | None = None,\n):\n    \"\"\"Create a new WorkFlow.\n\n    Args:\n        user (vUser): the vUser.\n        sfc (vSFC): the vSFC.\n        process_length (Union[int, Callable], optional): the process length. Defaults to 100.\n        packet_size (Union[int, Callable], optional): the packet size. Defaults to 65536.\n        num_packets (Union[int, Callable], optional): the number of packet (Do not change the GET/ACK packet). Defaults to 1.\n        priority (Union[int, Callable], optional): the priority of the workflow. Defaults to 0.\n        retry (Union[bool, Callable], optional): set true for retrying until complete. Defaults to True.\n        retry_delay (_type_, optional): the delay beofore retrying the workflow. Defaults to lambda:random.random().\n        at (int | float | Callable[..., Any], optional): when the workflow should be created. Defaults to simulation.now.\n        after (Entity | List[Entity] | None, optional): the entity that the workflow must be created after. Defaults to None.\n        label (str | None, optional): short desciption of the workflow. Defaults to None.\n    \"\"\"\n    super().__init__(at, after, label)\n    self._user = user\n    self._user_request = user_request\n    self._sfc_id = sfc.id\n    self._process_length = process_length\n    self._packet_size = packet_size\n    self._num_packets = num_packets\n    self._priority = priority\n    self._requests = list()\n    self._on_creation = self.initialize_requests\n    simulation.WORKFLOWS.append(self)\n</code></pre>"},{"location":"api/virtual_entity/v_user/#PyCloudSim.entity.v_user.WorkFlow.complete","title":"<code>complete()</code>","text":"<p>COMPLETE the workflow and engage the termination process.</p> Source code in <code>PyCloudSim\\entity\\v_user.py</code> <pre><code>def complete(self):\n    \"\"\"COMPLETE the workflow and engage the termination process.\"\"\"\n    self.status.append(COMPLETED)\n    self.terminate()\n    LOGGER.info(f\"{simulation.now:0.2f}:\\tWorkflow {self.label} completed.\")\n</code></pre>"},{"location":"api/virtual_entity/v_user/#PyCloudSim.entity.v_user.WorkFlow.fail","title":"<code>fail()</code>","text":"<p>Fail the workflow and engage the termination process if no retry is set.</p> Source code in <code>PyCloudSim\\entity\\v_user.py</code> <pre><code>def fail(self):\n    \"\"\"Fail the workflow and engage the termination process if no retry is set.\"\"\"\n    self.status.append(FAILED)\n    self.terminate()\n    LOGGER.info(f\"{simulation.now:0.2f}:\\tWorkflow {self.label} failed.\")\n</code></pre>"},{"location":"api/virtual_entity/v_volume/","title":"vVolume","text":"<p>The class \"vVolume\" is implemented to resemble a volume that can be attached to a container in Docker or Kubernetes which consumes the ROM from \"vHost\". A \"vContainer\" could be attached with multiple \"vVolume\" and those  \"vVolume\" could be allocated on different \"vHost\" rather than the \"vHost\" where the \"vContainer\" is hosted. A \"vVolume\" could be persistent by setting attribute \"retain\" equals to true. If a \"vVolume\" is persistent, it will not be destoried when its associated \"vContainer\" is terminated and could be reattached to a new instance of the \"vContainer\". The \"vVolume\" must be allocated first before a \"vContainer\" is scheduled. If any \"vVolume\" is failed to be allocated onto \"vHost\", the schedule of its associated \"vContainer\" will be on hold.</p> <p>             Bases: <code>VirtualEntity</code></p> Source code in <code>PyCloudSim\\entity\\v_volume.py</code> <pre><code>class vVolume(VirtualEntity):\n    def __init__(\n        self,\n        tag: Optional[str] = None,\n        path: Optional[str] = None,\n        size: int = 100,\n        retain: bool = False,\n        taint: Optional[str] = None,\n        at: Union[int, float, Callable] = simulation.now,\n        after: Optional[Entity | List[Entity]] = None,\n        label: Optional[str] = None,\n    ):\n        \"\"\"Create a vVolume.\n\n        Args:\n            tag (Optional[str], optional): the tag of the vVolume. Defaults to None.\n            path (Optional[str], optional): the path of the vVolume. Defaults to None.\n            size (int, optional): the sime of the vVolume in MiB. Defaults to 100.\n            retain (bool, optional): set true if the vVolume will be retained. Defaults to False.\n            taint (Optional[str], optional): the taint of the vVolume. Defaults to None.\n            at (Union[int, float, Callable], optional): same as entity. Defaults to simulation.now.\n            after (Optional[Entity  |  List[Entity]], optional): same as entity. Defaults to None.\n            label (Optional[str], optional): same as entity. Defaults to None.\n        \"\"\"        \n        super().__init__(at, after, label)\n        self._container_id = int()\n        self._host_id = int()\n        self._tag = tag or str()\n        self._path = path or str()\n        self._size = MiB(size)\n        self._retain = retain\n        self._taint = taint or str()\n        self._attached = False\n        self._allocated = False\n        self._on_creation = simulation.volume_allocator.allocate\n        simulation.VOLUMES.append(self)\n\n    def termination(self):\n        \"\"\"The termination of a vVolume.\"\"\"\n        super().termination()\n        if self.allocated:\n            self.host.rom.release(self)\n        simulation.volume_allocator.allocate()\n\n    def attach(self, container: vContainer):\n        \"\"\"Attach the vVolume to a vContainer.\"\"\"\n        def _attach():\n            self._container_id = container.id\n            self._attached = True\n            LOGGER.info(f\"{simulation.now:0.2f}:\\tVirtual Volume {self.label} is attached to vContainer {container.label}.\")\n\n        Actor(\n            action=_attach,\n            at=simulation.now,\n            label=f\"vVolume {self.label} Attach\",\n            priority=VOLUME_ATACH,\n        )\n\n    def detach(self):\n        \"\"\"Detach the vVolume from a vContainer.\"\"\"\n        def _detach():\n            LOGGER.info(f\"{simulation.now:0.2f}:\\tVirtual Volume {self.label} is detached from vContainer {self.container.label}.\")\n            self._container_id = int()\n            self._attached = False\n\n        Actor(\n            action=_detach,\n            at=simulation.now,\n            label=f\"vVolume {self.label} Detach\",\n            priority=VOLUME_DETACH,\n        )\n\n    @property\n    def container_id(self) -&gt; int:\n        \"\"\"The id of the vContainer that the vVolume is attached to.\"\"\"\n        return self._container_id\n\n    @property\n    def container(self) -&gt; vContainer:\n        \"\"\"The vContainer that the vVolume is attached to.\"\"\"\n        for container in simulation.CONTAINERS:\n            if container.id == self.container_id:\n                return container\n        warnings.warn(f\"Virtual Volume {self.label} is detached.\")\n        return None  # type: ignore\n\n    @property\n    def host_id(self) -&gt; int:\n        \"\"\"The id of the vHost that the vVolume is allocated on.\"\"\"\n        return self._host_id\n\n    @property\n    def host(self) -&gt; vHost:\n        \"\"\"The vHost that the vVolume is allocated on.\"\"\"\n        for host in simulation.HOSTS:\n            if host.id == self.host_id:\n                return host\n        raise RuntimeError(f\"Virtual Volume {self.label} is not allocated on any host.\")\n\n    @property\n    def tag(self) -&gt; str:\n        \"\"\"The tag of the vVolume.\"\"\"\n        return self._tag\n\n    @property\n    def path(self) -&gt; str:\n        \"\"\"The path of the vVolume.\"\"\"\n        return self._path\n\n    @property\n    def size(self) -&gt; Union[int, float]:\n        \"\"\"The size of the vVolume in MiB.\"\"\"\n        return self._size.bytes\n\n    @property\n    def retain(self) -&gt; bool:\n        \"\"\"Return true if the vVolume is retained.\"\"\"\n        return self._retain\n\n    @property\n    def taint(self) -&gt; str:\n        \"\"\"The taint of the vVolume.\"\"\"\n        return self._taint\n\n    @property\n    def attached(self) -&gt; bool:\n        \"\"\"Check if the vVolume is attached to a vContainer.\"\"\"\n        return self._attached\n\n    @property\n    def allocated(self) -&gt; bool:\n        \"\"\"Check if the vVolume is allocated on a vHost.\"\"\"\n        return self._allocated\n</code></pre>"},{"location":"api/virtual_entity/v_volume/#PyCloudSim.entity.v_volume.vVolume.allocated","title":"<code>allocated: bool</code>  <code>property</code>","text":"<p>Check if the vVolume is allocated on a vHost.</p>"},{"location":"api/virtual_entity/v_volume/#PyCloudSim.entity.v_volume.vVolume.attached","title":"<code>attached: bool</code>  <code>property</code>","text":"<p>Check if the vVolume is attached to a vContainer.</p>"},{"location":"api/virtual_entity/v_volume/#PyCloudSim.entity.v_volume.vVolume.container","title":"<code>container: vContainer</code>  <code>property</code>","text":"<p>The vContainer that the vVolume is attached to.</p>"},{"location":"api/virtual_entity/v_volume/#PyCloudSim.entity.v_volume.vVolume.container_id","title":"<code>container_id: int</code>  <code>property</code>","text":"<p>The id of the vContainer that the vVolume is attached to.</p>"},{"location":"api/virtual_entity/v_volume/#PyCloudSim.entity.v_volume.vVolume.host","title":"<code>host: vHost</code>  <code>property</code>","text":"<p>The vHost that the vVolume is allocated on.</p>"},{"location":"api/virtual_entity/v_volume/#PyCloudSim.entity.v_volume.vVolume.host_id","title":"<code>host_id: int</code>  <code>property</code>","text":"<p>The id of the vHost that the vVolume is allocated on.</p>"},{"location":"api/virtual_entity/v_volume/#PyCloudSim.entity.v_volume.vVolume.path","title":"<code>path: str</code>  <code>property</code>","text":"<p>The path of the vVolume.</p>"},{"location":"api/virtual_entity/v_volume/#PyCloudSim.entity.v_volume.vVolume.retain","title":"<code>retain: bool</code>  <code>property</code>","text":"<p>Return true if the vVolume is retained.</p>"},{"location":"api/virtual_entity/v_volume/#PyCloudSim.entity.v_volume.vVolume.size","title":"<code>size: Union[int, float]</code>  <code>property</code>","text":"<p>The size of the vVolume in MiB.</p>"},{"location":"api/virtual_entity/v_volume/#PyCloudSim.entity.v_volume.vVolume.tag","title":"<code>tag: str</code>  <code>property</code>","text":"<p>The tag of the vVolume.</p>"},{"location":"api/virtual_entity/v_volume/#PyCloudSim.entity.v_volume.vVolume.taint","title":"<code>taint: str</code>  <code>property</code>","text":"<p>The taint of the vVolume.</p>"},{"location":"api/virtual_entity/v_volume/#PyCloudSim.entity.v_volume.vVolume.__init__","title":"<code>__init__(tag=None, path=None, size=100, retain=False, taint=None, at=simulation.now, after=None, label=None)</code>","text":"<p>Create a vVolume.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>Optional[str]</code> <p>the tag of the vVolume. Defaults to None.</p> <code>None</code> <code>path</code> <code>Optional[str]</code> <p>the path of the vVolume. Defaults to None.</p> <code>None</code> <code>size</code> <code>int</code> <p>the sime of the vVolume in MiB. Defaults to 100.</p> <code>100</code> <code>retain</code> <code>bool</code> <p>set true if the vVolume will be retained. Defaults to False.</p> <code>False</code> <code>taint</code> <code>Optional[str]</code> <p>the taint of the vVolume. Defaults to None.</p> <code>None</code> <code>at</code> <code>Union[int, float, Callable]</code> <p>same as entity. Defaults to simulation.now.</p> <code>now</code> <code>after</code> <code>Optional[Entity | List[Entity]]</code> <p>same as entity. Defaults to None.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>same as entity. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_volume.py</code> <pre><code>def __init__(\n    self,\n    tag: Optional[str] = None,\n    path: Optional[str] = None,\n    size: int = 100,\n    retain: bool = False,\n    taint: Optional[str] = None,\n    at: Union[int, float, Callable] = simulation.now,\n    after: Optional[Entity | List[Entity]] = None,\n    label: Optional[str] = None,\n):\n    \"\"\"Create a vVolume.\n\n    Args:\n        tag (Optional[str], optional): the tag of the vVolume. Defaults to None.\n        path (Optional[str], optional): the path of the vVolume. Defaults to None.\n        size (int, optional): the sime of the vVolume in MiB. Defaults to 100.\n        retain (bool, optional): set true if the vVolume will be retained. Defaults to False.\n        taint (Optional[str], optional): the taint of the vVolume. Defaults to None.\n        at (Union[int, float, Callable], optional): same as entity. Defaults to simulation.now.\n        after (Optional[Entity  |  List[Entity]], optional): same as entity. Defaults to None.\n        label (Optional[str], optional): same as entity. Defaults to None.\n    \"\"\"        \n    super().__init__(at, after, label)\n    self._container_id = int()\n    self._host_id = int()\n    self._tag = tag or str()\n    self._path = path or str()\n    self._size = MiB(size)\n    self._retain = retain\n    self._taint = taint or str()\n    self._attached = False\n    self._allocated = False\n    self._on_creation = simulation.volume_allocator.allocate\n    simulation.VOLUMES.append(self)\n</code></pre>"},{"location":"api/virtual_entity/v_volume/#PyCloudSim.entity.v_volume.vVolume.attach","title":"<code>attach(container)</code>","text":"<p>Attach the vVolume to a vContainer.</p> Source code in <code>PyCloudSim\\entity\\v_volume.py</code> <pre><code>def attach(self, container: vContainer):\n    \"\"\"Attach the vVolume to a vContainer.\"\"\"\n    def _attach():\n        self._container_id = container.id\n        self._attached = True\n        LOGGER.info(f\"{simulation.now:0.2f}:\\tVirtual Volume {self.label} is attached to vContainer {container.label}.\")\n\n    Actor(\n        action=_attach,\n        at=simulation.now,\n        label=f\"vVolume {self.label} Attach\",\n        priority=VOLUME_ATACH,\n    )\n</code></pre>"},{"location":"api/virtual_entity/v_volume/#PyCloudSim.entity.v_volume.vVolume.detach","title":"<code>detach()</code>","text":"<p>Detach the vVolume from a vContainer.</p> Source code in <code>PyCloudSim\\entity\\v_volume.py</code> <pre><code>def detach(self):\n    \"\"\"Detach the vVolume from a vContainer.\"\"\"\n    def _detach():\n        LOGGER.info(f\"{simulation.now:0.2f}:\\tVirtual Volume {self.label} is detached from vContainer {self.container.label}.\")\n        self._container_id = int()\n        self._attached = False\n\n    Actor(\n        action=_detach,\n        at=simulation.now,\n        label=f\"vVolume {self.label} Detach\",\n        priority=VOLUME_DETACH,\n    )\n</code></pre>"},{"location":"api/virtual_entity/v_volume/#PyCloudSim.entity.v_volume.vVolume.termination","title":"<code>termination()</code>","text":"<p>The termination of a vVolume.</p> Source code in <code>PyCloudSim\\entity\\v_volume.py</code> <pre><code>def termination(self):\n    \"\"\"The termination of a vVolume.\"\"\"\n    super().termination()\n    if self.allocated:\n        self.host.rom.release(self)\n    simulation.volume_allocator.allocate()\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/","title":"Index","text":"<p>The \"vProcess\" class represents a simulated computation task similar to a \"Cloudlet\" in CloudSim (Plus). It contains a randomly generated set of instructions, measured in bytes, and the RAM usage is determined by the total length of the instruction set. The \"vCPU\" distributes the \"vProcess\" onto the available \"vCPUCore\" instances, where the instructions of the \"vProcess\" are consumed. Once all instructions have been executed, the \"vProcess\" is considered completed, and a termination process is initiated to release the computational resources. However, the \"vProcess\" may also be terminated abruptly by other events during the simulation. In such cases, if not all instructions have been executed, the \"vProcess\" is considered failed, and the termination process is still triggered.</p> <p>On the other hand, the \"vPacket\" class represents simulated packets for network traffic. Similar to the \"vProcess\", the content of the \"vPacket\" is randomly generated bytes. The \"vPacket\" is transferred between different entities such as \"vSwitch\", \"vRouter\", \"vHost\", and \"vGateway\" using their respective \"vNIC\" instances.</p> <p>The \"vRequest\" class is the implementation of a simulated API call, which creates a sequence of \"vProcess\" and \"vPacket\" instances to simulate the usage of network services. A \"vRequest\" requires a source and a target, which can be a simulated container or a simulated user. If a simulated user is a source or target, the \"vPacket\" will be sent from or received by a \"vGateway\". The type of \"vRequest\" includes GET, POST, DELETE, and LIST, which determine the order and number of \"vProcess\" and \"vPacket\" creations. When a simulated user engages with a simulated Service Function Chain (SFC), a series of requests will be generated and scheduled to interact with the network services. The success of a \"vRequest\" depends on the completion of all associated \"vProcess\" and \"vPacket\" executions or transmissions. If any of them fail, the \"vRequest\" is considered failed and may be retried after a specified delay.</p> <p>The \"vUser\" class represents simulated users who engage with the \"vSFC\" during the simulation. Each user's interaction is modelled as a \"Workflow\" that contains a series of \"vRequest\" instances required to complete a specific \"vSFC\". If any \"vRequest\" fails, the \"Workflow\" is reset, clearing all remaining \"vRequest\" that have not started, and the entire set of \"vRequest\" is recreated to be rescheduled and executed. Simulated users can request to engage with multiple \"vSFC\" instances simultaneously, and each \"Workflow\" is created independently. Users can also request \"vSFC\" in order, where the corresponding \"Workflow\" is executed sequentially. If any \"Workflow\" fails, subsequent \"Workflow\" instances will be terminated immediately.</p> <p>By modelling these classes, the simulation environment can simulate user interactions, the execution of computational tasks, and the transmission of network packets within a simulated cloud environment, allowing for the evaluation of system performance and behaviour.</p>"},{"location":"api/virtual_entity/process_packet_request/v_packet/","title":"vPacket","text":"<p>             Bases: <code>VirtualEntity</code></p> Source code in <code>PyCloudSim\\entity\\v_packet.py</code> <pre><code>class vPacket(VirtualEntity):\n    def __init__(\n        self,\n        source: Union[vHost, vGateway],\n        destination: Union[vHost, vGateway],\n        size: int = 65536,\n        request: Optional[vRequest] = None,\n        at: Union[int, float, Callable] = simulation.now,\n        after: Optional[Entity | List[Entity]] = None,\n        label: Optional[str] = None,\n    ):\n        \"\"\"Create a vPacket\n\n        Args:\n            source (Union[vHost, vGateway]): the source of the vPacket.\n            destination (Union[vHost, vGateway]): the destination of the vPacket.\n            size (int, optional): the size of the vPacket in bytes. Defaults to 65536.\n            request (Optional[vRequest], optional): the assoicated vRequest. Defaults to None.\n            at (Union[int, float, Callable], optional): same as entity. Defaults to simulation.now.\n            after (Optional[Entity  |  List[Entity]], optional): same as entity. Defaults to None.\n            label (Optional[str], optional): same as entity. Defaults to None.\n\n        Raises:\n            AttributeError: _description_\n        \"\"\"\n        super().__init__(at, after, label)\n        self._source = source\n        self._destination = destination\n        if source is destination:\n            self._loopback = True\n            self._path = [source]\n            self._current_hop = self.path[0]\n        else:\n            path = nx.shortest_path(simulation.topology, source, destination)\n            if len(path) != 0:\n                self._path = path\n                self._current_hop = path[0]\n            else:\n                raise AttributeError(\n                    f\"No path found between {source.__class__.__name__} {source.label} and {destination.__class__.__name__} {destination.label}\"\n                )\n        self._request_id = request.id if request is not None else None\n        self._nic_id = int()\n        self._content = randbytes(size)\n        self._size = len(self.content) * simulation.packet_size_amplifier\n        self._on_creation = lambda: self.source.cache_packet(self)\n\n    def creation(self):\n        \"\"\"The creation process of the vPacket.\"\"\"\n        if self.request:\n            if self.request.failed:\n                LOGGER.debug(f\"{simulation.now:0.2f}:\\tvPacket {self.label} creation cancelled due to vRequest {self.request.label} failed.\")\n                return\n        simulation.PACKETS.append(self)\n        return super().creation()\n\n    def termination(self):\n        \"\"\"The termination process of the vPacket.\"\"\"\n        super().termination()\n        if self.completed:\n            # release the ram of the current hop\n            if self.current_hop.__class__.__name__ != \"vGateway\":\n                self.current_hop.ram.release(self)\n            self.current_hop.packets.remove(self)\n        if self.dropped:\n            # fail the associated request\n            if self.request is not None:\n                self.request.fail()\n\n    def complete(self):\n        \"\"\"Complete the vPacket.\"\"\"\n        if not self.completed:\n            if self.request is not None:\n                if not self.request.failed:\n                    self.status.append(COMPLETED)\n            else:\n                self.status.append(COMPLETED)\n            self.terminate()\n            LOGGER.info(\n                f\"{simulation.now:0.2f}:\\tvPacket {self.label} reached destination {self.current_hop.__class__.__name__} {self.current_hop.label}.\"\n            )\n\n    def drop(self):\n        \"\"\"Drop the vPacket.\"\"\"\n        if not self.dropped:\n            self.status.append(DROPPED)\n            self.terminate()\n\n    @property\n    def source(self) -&gt; Union[vHost, vGateway]:\n        \"\"\"Return the source of the vPacket.\"\"\"\n        return self._source\n\n    @property\n    def destination(self) -&gt; Union[vHost, vGateway]:\n        \"\"\"Return the destination of the vPacket.\"\"\"\n        return self._destination\n\n    @property\n    def path(self) -&gt; List[PhysicalEntity]:\n        \"\"\"Return the path of the vPacket.\"\"\"\n        return self._path  # type: ignore\n\n    @property\n    def content(self) -&gt; bytes:\n        \"\"\"The content of the vPacket.\"\"\"\n        return self._content\n\n    @property\n    def size(self) -&gt; int:\n        \"\"\"The size of the vPacket in bytes.\"\"\"\n        return self._size\n\n    @property\n    def loopback(self) -&gt; bool:\n        \"\"\"return true if the source and destination is on the same host.\"\"\"\n        return self._loopback\n\n    @property\n    def request_id(self) -&gt; Optional[int]:\n        \"\"\"The id of the associated vRequest.\"\"\"\n        return self._request_id\n\n    @property\n    def request(self) -&gt; Optional[vRequest]:\n        \"\"\"The associated vRequest.\"\"\"\n        if self.request_id is None:\n            return None\n        else:\n            for request in simulation.REQUESTS:\n                if request.id == self.request_id:\n                    return request\n            raise RuntimeError(\n                f\"vPacket {self.label} can not find its associated request.\"\n            )\n\n    @property\n    def current_hop(self) -&gt; Union[vHost, vRouter, vSwitch, vGateway]:\n        \"\"\"The current hop of the vPacket.\"\"\"\n        return self._current_hop  # type: ignore\n\n    @property\n    def next_hop(self) -&gt; Union[vHost, vRouter, vSwitch, vGateway]:\n        \"\"\"The next hop of the vPacket.\"\"\"\n        if self.current_hop == self.destination:\n            return self.destination\n        else:\n            return self.path[self.path.index(self.current_hop) + 1]  # type: ignore\n\n    @property\n    def nic_id(self) -&gt; int:\n        \"\"\"The id of the associated vNIC.\"\"\"\n        return self._nic_id\n\n    @property\n    def nic(self) -&gt; vNIC:\n        \"\"\"The associated vNIC.\"\"\"\n        for nic in simulation.NICS:\n            if nic.id == self.nic_id:\n                return nic\n        raise RuntimeError(f\"vPacket {self.label} can not find its associated NIC.\")\n\n    @property\n    def transmitting(self) -&gt; bool:\n        \"\"\"Return true if the vPacket is transmitting.\"\"\"\n        return TRANSMITTING in self.status\n\n    @property\n    def priority(self) -&gt; int:\n        \"\"\"Return the priority of the vPacket.\"\"\"\n        if self.request is None:\n            return 0\n        else:\n            return self.request.priority\n\n    @property\n    def dropped(self) -&gt; bool:\n        \"\"\"Return true if the vPacket is dropped.\"\"\"\n        return DROPPED in self.status\n\n    @property\n    def queued(self) -&gt; bool:\n        \"\"\"Return true if the vPacket is queued.\"\"\"\n        return QUEUED in self.status\n\n    @property\n    def decoded(self) -&gt; bool:\n        \"\"\"Return true if the vPacket is decoded.\"\"\"\n        return DECODED in self.status\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_packet/#PyCloudSim.entity.v_packet.vPacket.content","title":"<code>content: bytes</code>  <code>property</code>","text":"<p>The content of the vPacket.</p>"},{"location":"api/virtual_entity/process_packet_request/v_packet/#PyCloudSim.entity.v_packet.vPacket.current_hop","title":"<code>current_hop: Union[vHost, vRouter, vSwitch, vGateway]</code>  <code>property</code>","text":"<p>The current hop of the vPacket.</p>"},{"location":"api/virtual_entity/process_packet_request/v_packet/#PyCloudSim.entity.v_packet.vPacket.decoded","title":"<code>decoded: bool</code>  <code>property</code>","text":"<p>Return true if the vPacket is decoded.</p>"},{"location":"api/virtual_entity/process_packet_request/v_packet/#PyCloudSim.entity.v_packet.vPacket.destination","title":"<code>destination: Union[vHost, vGateway]</code>  <code>property</code>","text":"<p>Return the destination of the vPacket.</p>"},{"location":"api/virtual_entity/process_packet_request/v_packet/#PyCloudSim.entity.v_packet.vPacket.dropped","title":"<code>dropped: bool</code>  <code>property</code>","text":"<p>Return true if the vPacket is dropped.</p>"},{"location":"api/virtual_entity/process_packet_request/v_packet/#PyCloudSim.entity.v_packet.vPacket.loopback","title":"<code>loopback: bool</code>  <code>property</code>","text":"<p>return true if the source and destination is on the same host.</p>"},{"location":"api/virtual_entity/process_packet_request/v_packet/#PyCloudSim.entity.v_packet.vPacket.next_hop","title":"<code>next_hop: Union[vHost, vRouter, vSwitch, vGateway]</code>  <code>property</code>","text":"<p>The next hop of the vPacket.</p>"},{"location":"api/virtual_entity/process_packet_request/v_packet/#PyCloudSim.entity.v_packet.vPacket.nic","title":"<code>nic: vNIC</code>  <code>property</code>","text":"<p>The associated vNIC.</p>"},{"location":"api/virtual_entity/process_packet_request/v_packet/#PyCloudSim.entity.v_packet.vPacket.nic_id","title":"<code>nic_id: int</code>  <code>property</code>","text":"<p>The id of the associated vNIC.</p>"},{"location":"api/virtual_entity/process_packet_request/v_packet/#PyCloudSim.entity.v_packet.vPacket.path","title":"<code>path: List[PhysicalEntity]</code>  <code>property</code>","text":"<p>Return the path of the vPacket.</p>"},{"location":"api/virtual_entity/process_packet_request/v_packet/#PyCloudSim.entity.v_packet.vPacket.priority","title":"<code>priority: int</code>  <code>property</code>","text":"<p>Return the priority of the vPacket.</p>"},{"location":"api/virtual_entity/process_packet_request/v_packet/#PyCloudSim.entity.v_packet.vPacket.queued","title":"<code>queued: bool</code>  <code>property</code>","text":"<p>Return true if the vPacket is queued.</p>"},{"location":"api/virtual_entity/process_packet_request/v_packet/#PyCloudSim.entity.v_packet.vPacket.request","title":"<code>request: Optional[vRequest]</code>  <code>property</code>","text":"<p>The associated vRequest.</p>"},{"location":"api/virtual_entity/process_packet_request/v_packet/#PyCloudSim.entity.v_packet.vPacket.request_id","title":"<code>request_id: Optional[int]</code>  <code>property</code>","text":"<p>The id of the associated vRequest.</p>"},{"location":"api/virtual_entity/process_packet_request/v_packet/#PyCloudSim.entity.v_packet.vPacket.size","title":"<code>size: int</code>  <code>property</code>","text":"<p>The size of the vPacket in bytes.</p>"},{"location":"api/virtual_entity/process_packet_request/v_packet/#PyCloudSim.entity.v_packet.vPacket.source","title":"<code>source: Union[vHost, vGateway]</code>  <code>property</code>","text":"<p>Return the source of the vPacket.</p>"},{"location":"api/virtual_entity/process_packet_request/v_packet/#PyCloudSim.entity.v_packet.vPacket.transmitting","title":"<code>transmitting: bool</code>  <code>property</code>","text":"<p>Return true if the vPacket is transmitting.</p>"},{"location":"api/virtual_entity/process_packet_request/v_packet/#PyCloudSim.entity.v_packet.vPacket.__init__","title":"<code>__init__(source, destination, size=65536, request=None, at=simulation.now, after=None, label=None)</code>","text":"<p>Create a vPacket</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Union[vHost, vGateway]</code> <p>the source of the vPacket.</p> required <code>destination</code> <code>Union[vHost, vGateway]</code> <p>the destination of the vPacket.</p> required <code>size</code> <code>int</code> <p>the size of the vPacket in bytes. Defaults to 65536.</p> <code>65536</code> <code>request</code> <code>Optional[vRequest]</code> <p>the assoicated vRequest. Defaults to None.</p> <code>None</code> <code>at</code> <code>Union[int, float, Callable]</code> <p>same as entity. Defaults to simulation.now.</p> <code>now</code> <code>after</code> <code>Optional[Entity | List[Entity]]</code> <p>same as entity. Defaults to None.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>same as entity. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>AttributeError</code> <p>description</p> Source code in <code>PyCloudSim\\entity\\v_packet.py</code> <pre><code>def __init__(\n    self,\n    source: Union[vHost, vGateway],\n    destination: Union[vHost, vGateway],\n    size: int = 65536,\n    request: Optional[vRequest] = None,\n    at: Union[int, float, Callable] = simulation.now,\n    after: Optional[Entity | List[Entity]] = None,\n    label: Optional[str] = None,\n):\n    \"\"\"Create a vPacket\n\n    Args:\n        source (Union[vHost, vGateway]): the source of the vPacket.\n        destination (Union[vHost, vGateway]): the destination of the vPacket.\n        size (int, optional): the size of the vPacket in bytes. Defaults to 65536.\n        request (Optional[vRequest], optional): the assoicated vRequest. Defaults to None.\n        at (Union[int, float, Callable], optional): same as entity. Defaults to simulation.now.\n        after (Optional[Entity  |  List[Entity]], optional): same as entity. Defaults to None.\n        label (Optional[str], optional): same as entity. Defaults to None.\n\n    Raises:\n        AttributeError: _description_\n    \"\"\"\n    super().__init__(at, after, label)\n    self._source = source\n    self._destination = destination\n    if source is destination:\n        self._loopback = True\n        self._path = [source]\n        self._current_hop = self.path[0]\n    else:\n        path = nx.shortest_path(simulation.topology, source, destination)\n        if len(path) != 0:\n            self._path = path\n            self._current_hop = path[0]\n        else:\n            raise AttributeError(\n                f\"No path found between {source.__class__.__name__} {source.label} and {destination.__class__.__name__} {destination.label}\"\n            )\n    self._request_id = request.id if request is not None else None\n    self._nic_id = int()\n    self._content = randbytes(size)\n    self._size = len(self.content) * simulation.packet_size_amplifier\n    self._on_creation = lambda: self.source.cache_packet(self)\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_packet/#PyCloudSim.entity.v_packet.vPacket.complete","title":"<code>complete()</code>","text":"<p>Complete the vPacket.</p> Source code in <code>PyCloudSim\\entity\\v_packet.py</code> <pre><code>def complete(self):\n    \"\"\"Complete the vPacket.\"\"\"\n    if not self.completed:\n        if self.request is not None:\n            if not self.request.failed:\n                self.status.append(COMPLETED)\n        else:\n            self.status.append(COMPLETED)\n        self.terminate()\n        LOGGER.info(\n            f\"{simulation.now:0.2f}:\\tvPacket {self.label} reached destination {self.current_hop.__class__.__name__} {self.current_hop.label}.\"\n        )\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_packet/#PyCloudSim.entity.v_packet.vPacket.creation","title":"<code>creation()</code>","text":"<p>The creation process of the vPacket.</p> Source code in <code>PyCloudSim\\entity\\v_packet.py</code> <pre><code>def creation(self):\n    \"\"\"The creation process of the vPacket.\"\"\"\n    if self.request:\n        if self.request.failed:\n            LOGGER.debug(f\"{simulation.now:0.2f}:\\tvPacket {self.label} creation cancelled due to vRequest {self.request.label} failed.\")\n            return\n    simulation.PACKETS.append(self)\n    return super().creation()\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_packet/#PyCloudSim.entity.v_packet.vPacket.drop","title":"<code>drop()</code>","text":"<p>Drop the vPacket.</p> Source code in <code>PyCloudSim\\entity\\v_packet.py</code> <pre><code>def drop(self):\n    \"\"\"Drop the vPacket.\"\"\"\n    if not self.dropped:\n        self.status.append(DROPPED)\n        self.terminate()\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_packet/#PyCloudSim.entity.v_packet.vPacket.termination","title":"<code>termination()</code>","text":"<p>The termination process of the vPacket.</p> Source code in <code>PyCloudSim\\entity\\v_packet.py</code> <pre><code>def termination(self):\n    \"\"\"The termination process of the vPacket.\"\"\"\n    super().termination()\n    if self.completed:\n        # release the ram of the current hop\n        if self.current_hop.__class__.__name__ != \"vGateway\":\n            self.current_hop.ram.release(self)\n        self.current_hop.packets.remove(self)\n    if self.dropped:\n        # fail the associated request\n        if self.request is not None:\n            self.request.fail()\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_process/","title":"vInstruction","text":"<p>             Bases: <code>ABC</code></p> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>class vInstruction(ABC):\n    def __init__(self) -&gt; None:\n        \"\"\"Create a vInstruction.\n        \"\"\"\n        super().__init__()\n        self._content = bytes()\n\n    @property\n    def content(self) -&gt; bytes:\n        \"\"\"Return the content of the vInstruction.\"\"\"\n        return self._content\n\n    @property\n    def length(self) -&gt; int:\n        \"\"\"Return the length of the vInstruction.\"\"\"\n        return len(self.content)\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vInstruction.content","title":"<code>content: bytes</code>  <code>property</code>","text":"<p>Return the content of the vInstruction.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vInstruction.length","title":"<code>length: int</code>  <code>property</code>","text":"<p>Return the length of the vInstruction.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vInstruction.__init__","title":"<code>__init__()</code>","text":"<p>Create a vInstruction.</p> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Create a vInstruction.\n    \"\"\"\n    super().__init__()\n    self._content = bytes()\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_process/#vx86instruction","title":"vX86Instruction","text":"<p>             Bases: <code>vInstruction</code></p> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>class vX86Instruction(vInstruction):\n    def __init__(self) -&gt; None:\n        \"\"\"Create a vX86Instruction.\"\"\"\n        super().__init__()\n        self._content = randbytes(randint(1, 16))\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vX86Instruction.__init__","title":"<code>__init__()</code>","text":"<p>Create a vX86Instruction.</p> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Create a vX86Instruction.\"\"\"\n    super().__init__()\n    self._content = randbytes(randint(1, 16))\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_process/#varminstruction","title":"vARMInstruction","text":"<p>             Bases: <code>vInstruction</code></p> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>class vARMInstruction(vInstruction):\n    def __init__(self) -&gt; None:\n        \"\"\"Create a vARMInstruction.\"\"\"\n        super().__init__()\n        self._content = randbytes(4)\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vARMInstruction.__init__","title":"<code>__init__()</code>","text":"<p>Create a vARMInstruction.</p> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Create a vARMInstruction.\"\"\"\n    super().__init__()\n    self._content = randbytes(4)\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_process/#vprocess","title":"vProcess","text":"<p>             Bases: <code>VirtualEntity</code></p> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>class vProcess(VirtualEntity):\n    def __init__(\n        self,\n        length: int,\n        priority: Union[int, float],\n        request: Optional[vRequest] = None,\n        container: Optional[vContainer] = None,\n        at: Union[int, float, Callable] = simulation.now,\n        after: Optional[Entity | List[Entity]] = None,\n        label: Optional[str] = None,\n    ):\n        \"\"\"Create a vProcess.\n\n        Args:\n            length (int): the length in terms of instructions.\n            priority (Union[int, float]): the priority of the vProcess.\n            request (Optional[vRequest], optional): the request that the vProcess is associated with. Defaults to None.\n            container (Optional[vContainer], optional): the container that the vProcess is on. Defaults to None.\n            at (Union[int, float, Callable], optional): same as entity. Defaults to simulation.now.\n            after (Optional[Entity  |  List[Entity]], optional): same as entity. Defaults to None.\n            label (Optional[str], optional): same as entity. Defaults to None.\n        \"\"\"\n        super().__init__(at, after, label)\n        self._length = length\n        self._priority = priority\n        self._instructions = list()\n        self._request_id = request.id if request else None\n        self._container_id = container.id if container else None\n        self._host_id = int()\n        self._cpu_id = int()\n        self._cpu_core_id = int()\n        self._progress = 0\n        self._current_scheduled_length = 0\n        self._executing_cores: List[vCPUCore] = list()\n        if self.request is not None:\n            self.request.processes.append(self)\n        self.on_creation = lambda: self.container.accept_process(self) if self.container else None\n\n    def creation(self):\n        \"\"\"The creation process of a vProcess.\"\"\"\n        if self.request:\n            if self.request.failed:\n                LOGGER.debug(f\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} creation cancelled due to vRequest {self.request.label} failed.\")\n                return\n\n        # generate instructions and wrap them as priority items\n        self._instructions = list()\n        for _ in range(self.length):\n            if simulation.platform == X86_64:\n                instruction = vX86Instruction()\n                self.instructions.append(instruction)\n            if simulation.platform == ARM:\n                instruction = vARMInstruction()\n                self.instructions.append(instruction)\n        simulation.PROCESSES.append(self)\n        return super().creation()\n\n    def termination(self):\n        \"\"\"The termination process of a vProcess.\"\"\"\n        super().terminate()\n        self.release_resources()\n\n        if self.cached:\n            self.cpu.schedule_process()\n\n    def release_resources(self):\n        \"\"\"Release the resources that the vProcess is holding.\"\"\"\n        if self.scheduled and self.container:\n            self.container.processes.remove(self)\n            self.container.ram.release(self)\n            self.container.cpu.release(self)\n            for claim in self.container.cpu.claims:\n                if claim.user is self:\n                    LOGGER.error(\n                        f\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} failed to release CPU resources from vContainer {self.container.label}, remaining {claim.quantity} CPU\"\n                    )\n                    raise RuntimeError()\n            LOGGER.debug(\n                f\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} release resources from vContainer {self.container.label}\"\n            )\n            LOGGER.debug(\n                f\"{simulation.now:0.2f}:\\tvContainer {self.container.label}: {self.container.cpu.available_quantity} CPU, {self.container.ram.available_quantity} RAM, {len(self.container.processes)} Processes.\"\n            )\n\n        if self.cached:\n            self.host.processes.remove(self)\n            self.host.ram.release(self)\n            self.cpu.processes.remove(self)\n            if self.executing:\n                for core in self.executing_cores:\n                    core.processes.remove(self)\n                    core.computational_power.release(self)\n            LOGGER.debug(\n                f\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} release resources from vHost {self.host.label}\"\n            )\n            LOGGER.debug(\n                f\"{simulation.now:0.2f}:\\tvHost {self.host.label}: {self.host.cpu.availablity} CPU, {self.host.ram.available_quantity} RAM\"\n            )\n\n    def crash(self):\n        \"\"\"Crash the vProcess.\"\"\"\n        if not self.failed:\n            self.status.append(FAILED)\n            self.terminate()\n            LOGGER.info(\n                f\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} failed\"\n            )\n            if self.request:\n                if not self.request.failed:\n                    self.request.fail()\n\n    def complete(self):\n        \"\"\"Complete the vProcess.\"\"\"\n        if not self.completed and not self.failed and not self.terminated:\n            if self.remaining &lt;= 0:\n                self.status.append(COMPLETED)\n                self.terminate()\n                LOGGER.info(\n                    f\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} completed\"\n                )\n\n    @property\n    def length(self) -&gt; int:\n        \"\"\"Return the length of the vProcess.\"\"\"\n        return self._length\n\n    @property\n    def priority(self) -&gt; Union[int, float]:\n        \"\"\"Return the priority of the vProcess.\"\"\"\n        return self._priority\n\n    @property\n    def instructions(self) -&gt; List[vInstruction]:\n        \"\"\"Return the instructions of the vProcess.\"\"\"\n        return self._instructions\n\n    @property\n    def ram_usage(self) -&gt; int:\n        \"\"\"Return the RAM usage of the vProcess.\"\"\"\n        return (\n            sum([instruction.length for instruction in self.instructions])\n            * simulation.ram_amplifier\n        )\n\n    @property\n    def container_id(self) -&gt; int | None:\n        \"\"\"Return the container id of the vProcess.\"\"\"\n        return self._container_id\n\n    @property\n    def host_id(self) -&gt; int:\n        \"\"\"Return the host id of the vProcess.\"\"\"\n        return self._host_id\n\n    @property\n    def request_id(self) -&gt; Optional[int]:\n        \"\"\"Return the request id of the vProcess.\"\"\"\n        return self._request_id\n\n    @property\n    def container(self) -&gt; vContainer | None:\n        \"\"\"Return the container of the vProcess.\"\"\"\n        if self.container_id is None:\n            return None\n        else:\n            for container in simulation.CONTAINERS:\n                if container.id == self.container_id:\n                    return container\n            raise RuntimeError(\n                f\"{self.__class__.__name__} {self.label} is not associated with any vContainer.\"\n            )\n\n    @property\n    def host(self) -&gt; vHost:\n        \"\"\"Return the host of the vProcess.\"\"\"\n        for host in simulation.HOSTS:\n            if host.id == self.host_id:\n                return host\n        raise RuntimeError(\n            f\"{self.__class__.__name__} {self.label} is not found on any vHost.\"\n        )\n\n    @property\n    def request(self) -&gt; Optional[vRequest]:\n        \"\"\"Return the request of the vProcess.\"\"\"\n        if self.request_id is None:\n            return None\n        else:\n            for request in simulation.REQUESTS:\n                if request.id == self.request_id:\n                    return request\n            raise RuntimeError(\n                f\"{self.__class__.__name__} {self.label} is not associated with any vRequest.\"\n            )\n\n    @property\n    def cpu_id(self) -&gt; int:\n        \"\"\"Return the cpu id of the vProcess.\"\"\"\n        return self._cpu_id\n\n    @property\n    def cpu(self) -&gt; vCPU:\n        \"\"\"Return the cpu of the vProcess.\"\"\"\n        for cpu in simulation.CPUS:\n            if cpu.id == self.cpu_id:\n                return cpu\n        raise RuntimeError(\n            f\"{self.__class__.__name__} {self.label} is not associated with any vCPU.\"\n        )\n\n    @property\n    def cpu_core_id(self) -&gt; int:\n        \"\"\"Return the cpu core id of the vProcess.\"\"\"\n        return self._cpu_core_id\n\n    @property\n    def cpu_core(self) -&gt; vCPUCore:\n        \"\"\"Return the cpu core of the vProcess.\"\"\"\n        for cpu_core in simulation.CPU_CORES:\n            if cpu_core.id == self.cpu_core_id:\n                return cpu_core\n        raise RuntimeError(\n            f\"{self.__class__.__name__} {self.label} is not associated with any vCPU Core.\"\n        )\n\n    @property\n    def cached(self) -&gt; bool:\n        \"\"\"Return whether the vProcess is cached or not.\"\"\"\n        return CACHED in self.status\n\n    @property\n    def executing(self) -&gt; bool:\n        \"\"\"Return whether the vProcess is executing or not.\"\"\"\n        return EXECUTING in self.status\n\n    @property\n    def progress(self) -&gt; int:\n        \"\"\"Return the progress of the vProcess.\"\"\"\n        return self._progress\n\n    @property\n    def remaining(self) -&gt; int:\n        \"\"\"Return the remaining length of the vProcess.\"\"\"\n        return self.length - self.progress\n\n    @property\n    def current_scheduled_length(self) -&gt; int:\n        \"\"\"Return the current scheduled length of the vProcess.\"\"\"\n        return self._current_scheduled_length\n\n    @property\n    def executing_cores(self) -&gt; List[vCPUCore]:\n        \"\"\"Return the executing cores of the vProcess.\"\"\"\n        return self._executing_cores\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.cached","title":"<code>cached: bool</code>  <code>property</code>","text":"<p>Return whether the vProcess is cached or not.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.container","title":"<code>container: vContainer | None</code>  <code>property</code>","text":"<p>Return the container of the vProcess.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.container_id","title":"<code>container_id: int | None</code>  <code>property</code>","text":"<p>Return the container id of the vProcess.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.cpu","title":"<code>cpu: vCPU</code>  <code>property</code>","text":"<p>Return the cpu of the vProcess.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.cpu_core","title":"<code>cpu_core: vCPUCore</code>  <code>property</code>","text":"<p>Return the cpu core of the vProcess.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.cpu_core_id","title":"<code>cpu_core_id: int</code>  <code>property</code>","text":"<p>Return the cpu core id of the vProcess.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.cpu_id","title":"<code>cpu_id: int</code>  <code>property</code>","text":"<p>Return the cpu id of the vProcess.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.current_scheduled_length","title":"<code>current_scheduled_length: int</code>  <code>property</code>","text":"<p>Return the current scheduled length of the vProcess.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.executing","title":"<code>executing: bool</code>  <code>property</code>","text":"<p>Return whether the vProcess is executing or not.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.executing_cores","title":"<code>executing_cores: List[vCPUCore]</code>  <code>property</code>","text":"<p>Return the executing cores of the vProcess.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.host","title":"<code>host: vHost</code>  <code>property</code>","text":"<p>Return the host of the vProcess.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.host_id","title":"<code>host_id: int</code>  <code>property</code>","text":"<p>Return the host id of the vProcess.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.instructions","title":"<code>instructions: List[vInstruction]</code>  <code>property</code>","text":"<p>Return the instructions of the vProcess.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.length","title":"<code>length: int</code>  <code>property</code>","text":"<p>Return the length of the vProcess.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.priority","title":"<code>priority: Union[int, float]</code>  <code>property</code>","text":"<p>Return the priority of the vProcess.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.progress","title":"<code>progress: int</code>  <code>property</code>","text":"<p>Return the progress of the vProcess.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.ram_usage","title":"<code>ram_usage: int</code>  <code>property</code>","text":"<p>Return the RAM usage of the vProcess.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.remaining","title":"<code>remaining: int</code>  <code>property</code>","text":"<p>Return the remaining length of the vProcess.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.request","title":"<code>request: Optional[vRequest]</code>  <code>property</code>","text":"<p>Return the request of the vProcess.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.request_id","title":"<code>request_id: Optional[int]</code>  <code>property</code>","text":"<p>Return the request id of the vProcess.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.__init__","title":"<code>__init__(length, priority, request=None, container=None, at=simulation.now, after=None, label=None)</code>","text":"<p>Create a vProcess.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>the length in terms of instructions.</p> required <code>priority</code> <code>Union[int, float]</code> <p>the priority of the vProcess.</p> required <code>request</code> <code>Optional[vRequest]</code> <p>the request that the vProcess is associated with. Defaults to None.</p> <code>None</code> <code>container</code> <code>Optional[vContainer]</code> <p>the container that the vProcess is on. Defaults to None.</p> <code>None</code> <code>at</code> <code>Union[int, float, Callable]</code> <p>same as entity. Defaults to simulation.now.</p> <code>now</code> <code>after</code> <code>Optional[Entity | List[Entity]]</code> <p>same as entity. Defaults to None.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>same as entity. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>def __init__(\n    self,\n    length: int,\n    priority: Union[int, float],\n    request: Optional[vRequest] = None,\n    container: Optional[vContainer] = None,\n    at: Union[int, float, Callable] = simulation.now,\n    after: Optional[Entity | List[Entity]] = None,\n    label: Optional[str] = None,\n):\n    \"\"\"Create a vProcess.\n\n    Args:\n        length (int): the length in terms of instructions.\n        priority (Union[int, float]): the priority of the vProcess.\n        request (Optional[vRequest], optional): the request that the vProcess is associated with. Defaults to None.\n        container (Optional[vContainer], optional): the container that the vProcess is on. Defaults to None.\n        at (Union[int, float, Callable], optional): same as entity. Defaults to simulation.now.\n        after (Optional[Entity  |  List[Entity]], optional): same as entity. Defaults to None.\n        label (Optional[str], optional): same as entity. Defaults to None.\n    \"\"\"\n    super().__init__(at, after, label)\n    self._length = length\n    self._priority = priority\n    self._instructions = list()\n    self._request_id = request.id if request else None\n    self._container_id = container.id if container else None\n    self._host_id = int()\n    self._cpu_id = int()\n    self._cpu_core_id = int()\n    self._progress = 0\n    self._current_scheduled_length = 0\n    self._executing_cores: List[vCPUCore] = list()\n    if self.request is not None:\n        self.request.processes.append(self)\n    self.on_creation = lambda: self.container.accept_process(self) if self.container else None\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.complete","title":"<code>complete()</code>","text":"<p>Complete the vProcess.</p> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>def complete(self):\n    \"\"\"Complete the vProcess.\"\"\"\n    if not self.completed and not self.failed and not self.terminated:\n        if self.remaining &lt;= 0:\n            self.status.append(COMPLETED)\n            self.terminate()\n            LOGGER.info(\n                f\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} completed\"\n            )\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.crash","title":"<code>crash()</code>","text":"<p>Crash the vProcess.</p> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>def crash(self):\n    \"\"\"Crash the vProcess.\"\"\"\n    if not self.failed:\n        self.status.append(FAILED)\n        self.terminate()\n        LOGGER.info(\n            f\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} failed\"\n        )\n        if self.request:\n            if not self.request.failed:\n                self.request.fail()\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.creation","title":"<code>creation()</code>","text":"<p>The creation process of a vProcess.</p> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>def creation(self):\n    \"\"\"The creation process of a vProcess.\"\"\"\n    if self.request:\n        if self.request.failed:\n            LOGGER.debug(f\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} creation cancelled due to vRequest {self.request.label} failed.\")\n            return\n\n    # generate instructions and wrap them as priority items\n    self._instructions = list()\n    for _ in range(self.length):\n        if simulation.platform == X86_64:\n            instruction = vX86Instruction()\n            self.instructions.append(instruction)\n        if simulation.platform == ARM:\n            instruction = vARMInstruction()\n            self.instructions.append(instruction)\n    simulation.PROCESSES.append(self)\n    return super().creation()\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.release_resources","title":"<code>release_resources()</code>","text":"<p>Release the resources that the vProcess is holding.</p> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>def release_resources(self):\n    \"\"\"Release the resources that the vProcess is holding.\"\"\"\n    if self.scheduled and self.container:\n        self.container.processes.remove(self)\n        self.container.ram.release(self)\n        self.container.cpu.release(self)\n        for claim in self.container.cpu.claims:\n            if claim.user is self:\n                LOGGER.error(\n                    f\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} failed to release CPU resources from vContainer {self.container.label}, remaining {claim.quantity} CPU\"\n                )\n                raise RuntimeError()\n        LOGGER.debug(\n            f\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} release resources from vContainer {self.container.label}\"\n        )\n        LOGGER.debug(\n            f\"{simulation.now:0.2f}:\\tvContainer {self.container.label}: {self.container.cpu.available_quantity} CPU, {self.container.ram.available_quantity} RAM, {len(self.container.processes)} Processes.\"\n        )\n\n    if self.cached:\n        self.host.processes.remove(self)\n        self.host.ram.release(self)\n        self.cpu.processes.remove(self)\n        if self.executing:\n            for core in self.executing_cores:\n                core.processes.remove(self)\n                core.computational_power.release(self)\n        LOGGER.debug(\n            f\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} release resources from vHost {self.host.label}\"\n        )\n        LOGGER.debug(\n            f\"{simulation.now:0.2f}:\\tvHost {self.host.label}: {self.host.cpu.availablity} CPU, {self.host.ram.available_quantity} RAM\"\n        )\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vProcess.termination","title":"<code>termination()</code>","text":"<p>The termination process of a vProcess.</p> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>def termination(self):\n    \"\"\"The termination process of a vProcess.\"\"\"\n    super().terminate()\n    self.release_resources()\n\n    if self.cached:\n        self.cpu.schedule_process()\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_process/#vdeamonprocess","title":"vDeamonProcess","text":"<p>             Bases: <code>vProcess</code></p> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>class vDeamonProcess(vProcess):\n    def __init__(\n        self,\n        length: int,\n        container: vContainer,\n        at: Union[int, float, Callable] = simulation.now,\n        after: Optional[Entity | List[Entity]] = None,\n        label: Optional[str] = None,\n    ):\n        \"\"\"Create a vDeamonProcess.\n\n        Args:\n            length (int): the length in terms of instructions.\n            container (vContainer): the cache that the vDeamonProcess is on.\n            at (Union[int, float, Callable], optional): same as entity. Defaults to simulation.now.\n            after (Optional[Entity  |  List[Entity]], optional): same as entity. Defaults to None.\n            label (Optional[str], optional): same as entity. Defaults to None.\n        \"\"\"\n        super().__init__(length=length, priority=-inf, at=at, after=after, label=label)\n        self._container_id = container.id\n\n    def creation(self):\n        \"\"\"Creation process of a vDeamonProcess.\"\"\"\n        super().creation()\n        self.container.accept_process(self)\n\n    def termination(self):\n        \"\"\"Termination process of a vDeamonProcess.\"\"\"\n        super(vProcess, self).termination()\n        if not self.failed:\n            self.release_resources()\n            self.container.init_deamon()\n        else:\n            self.release_resources()\n\n    @property\n    def container_id(self) -&gt; int:\n        \"\"\"The container id of the vDeamonProcess.\"\"\"\n        return self._container_id\n\n    @property\n    def container(self) -&gt; vContainer:\n        \"\"\"The container of the vDeamonProcess.\"\"\"\n        for container in simulation.CONTAINERS:\n            if container.id == self.container_id:\n                return container\n        raise RuntimeError(\n            f\"{self.__class__.__name__} {self.label} is not associated with any vContainer.\"\n        )\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vDeamonProcess.container","title":"<code>container: vContainer</code>  <code>property</code>","text":"<p>The container of the vDeamonProcess.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vDeamonProcess.container_id","title":"<code>container_id: int</code>  <code>property</code>","text":"<p>The container id of the vDeamonProcess.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vDeamonProcess.__init__","title":"<code>__init__(length, container, at=simulation.now, after=None, label=None)</code>","text":"<p>Create a vDeamonProcess.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>the length in terms of instructions.</p> required <code>container</code> <code>vContainer</code> <p>the cache that the vDeamonProcess is on.</p> required <code>at</code> <code>Union[int, float, Callable]</code> <p>same as entity. Defaults to simulation.now.</p> <code>now</code> <code>after</code> <code>Optional[Entity | List[Entity]]</code> <p>same as entity. Defaults to None.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>same as entity. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>def __init__(\n    self,\n    length: int,\n    container: vContainer,\n    at: Union[int, float, Callable] = simulation.now,\n    after: Optional[Entity | List[Entity]] = None,\n    label: Optional[str] = None,\n):\n    \"\"\"Create a vDeamonProcess.\n\n    Args:\n        length (int): the length in terms of instructions.\n        container (vContainer): the cache that the vDeamonProcess is on.\n        at (Union[int, float, Callable], optional): same as entity. Defaults to simulation.now.\n        after (Optional[Entity  |  List[Entity]], optional): same as entity. Defaults to None.\n        label (Optional[str], optional): same as entity. Defaults to None.\n    \"\"\"\n    super().__init__(length=length, priority=-inf, at=at, after=after, label=label)\n    self._container_id = container.id\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vDeamonProcess.creation","title":"<code>creation()</code>","text":"<p>Creation process of a vDeamonProcess.</p> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>def creation(self):\n    \"\"\"Creation process of a vDeamonProcess.\"\"\"\n    super().creation()\n    self.container.accept_process(self)\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vDeamonProcess.termination","title":"<code>termination()</code>","text":"<p>Termination process of a vDeamonProcess.</p> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>def termination(self):\n    \"\"\"Termination process of a vDeamonProcess.\"\"\"\n    super(vProcess, self).termination()\n    if not self.failed:\n        self.release_resources()\n        self.container.init_deamon()\n    else:\n        self.release_resources()\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_process/#vpackethandler","title":"vPacketHandler","text":"<p>             Bases: <code>vProcess</code></p> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>class vPacketHandler(vProcess):\n    def __init__(\n        self,\n        length: int,\n        packet: vPacket,\n        host: Union[vHost, vSwitch, vRouter],\n        at: Union[int, float, Callable] = simulation.now,\n        after: Optional[Entity | List[Entity]] = None,\n        label: Optional[str] = None,\n    ):\n        \"\"\"Create a vPacketHandler.\n\n        Args:\n            length (int): the length of the vPacketHandler, will be determined by processing delay.\n            packet (vPacket): the assoicated vPacket.\n            host (Union[vHost, vSwitch, vRouter]): the host that the vPacketHandler is on.\n            at (Union[int, float, Callable], optional): same as entity. Defaults to simulation.now.\n            after (Optional[Entity  |  List[Entity]], optional): same as entity. Defaults to None.\n            label (Optional[str], optional): same as entity. Defaults to None.\n        \"\"\"\n        super().__init__(\n            length=length,\n            priority=packet.request.priority if packet.request else 0,\n            at=at,\n            after=after,\n            label=label,\n        )\n        self._packet_id = packet.id\n        self._host = host\n\n    def creation(self):\n        \"\"\"The creation process of a vPacketHandler.\"\"\"\n        super().creation()\n\n    def termination(self):\n        \"\"\"The termination process of a vPacketHandler.\"\"\"\n        super(vProcess, self).termination()\n        self.release_resources()\n        self.packet.status.append(DECODED)\n        LOGGER.debug(f\"{simulation.now:0.2f}:\\tvPacket {self.packet.label} is decoded.\")\n        self.packet.current_hop.send_packets()\n\n    def complete(self):\n        \"\"\"Complete the vPacketHandler.\"\"\"\n        if not self.completed and not self.failed and not self.terminated:\n            if self.remaining &lt;= 0:\n                self.status.append(COMPLETED)\n                self.terminate()\n                LOGGER.info(\n                    f\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} completed\"\n                )\n                if self.packet.path[-1] is self.packet.current_hop:\n                    self.packet.complete()\n\n    @property\n    def packet_id(self) -&gt; int:\n        \"\"\"The id of the associated vPacket.\"\"\"\n        return self._packet_id\n\n    @property\n    def packet(self) -&gt; vPacket:\n        \"\"\"The associated vPacket.\"\"\"\n        for packet in simulation.PACKETS:\n            if packet.id == self.packet_id:\n                return packet\n        raise RuntimeError(\n            f\"vPacketHandler {self.label} is not associated with any vPacket.\"\n        )\n\n    @property\n    def host(self) -&gt; Union[vHost, vSwitch, vRouter]:\n        \"\"\"The host that the vPacketHandler is on.\"\"\"\n        return self._host\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vPacketHandler.host","title":"<code>host: Union[vHost, vSwitch, vRouter]</code>  <code>property</code>","text":"<p>The host that the vPacketHandler is on.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vPacketHandler.packet","title":"<code>packet: vPacket</code>  <code>property</code>","text":"<p>The associated vPacket.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vPacketHandler.packet_id","title":"<code>packet_id: int</code>  <code>property</code>","text":"<p>The id of the associated vPacket.</p>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vPacketHandler.__init__","title":"<code>__init__(length, packet, host, at=simulation.now, after=None, label=None)</code>","text":"<p>Create a vPacketHandler.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>the length of the vPacketHandler, will be determined by processing delay.</p> required <code>packet</code> <code>vPacket</code> <p>the assoicated vPacket.</p> required <code>host</code> <code>Union[vHost, vSwitch, vRouter]</code> <p>the host that the vPacketHandler is on.</p> required <code>at</code> <code>Union[int, float, Callable]</code> <p>same as entity. Defaults to simulation.now.</p> <code>now</code> <code>after</code> <code>Optional[Entity | List[Entity]]</code> <p>same as entity. Defaults to None.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>same as entity. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>def __init__(\n    self,\n    length: int,\n    packet: vPacket,\n    host: Union[vHost, vSwitch, vRouter],\n    at: Union[int, float, Callable] = simulation.now,\n    after: Optional[Entity | List[Entity]] = None,\n    label: Optional[str] = None,\n):\n    \"\"\"Create a vPacketHandler.\n\n    Args:\n        length (int): the length of the vPacketHandler, will be determined by processing delay.\n        packet (vPacket): the assoicated vPacket.\n        host (Union[vHost, vSwitch, vRouter]): the host that the vPacketHandler is on.\n        at (Union[int, float, Callable], optional): same as entity. Defaults to simulation.now.\n        after (Optional[Entity  |  List[Entity]], optional): same as entity. Defaults to None.\n        label (Optional[str], optional): same as entity. Defaults to None.\n    \"\"\"\n    super().__init__(\n        length=length,\n        priority=packet.request.priority if packet.request else 0,\n        at=at,\n        after=after,\n        label=label,\n    )\n    self._packet_id = packet.id\n    self._host = host\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vPacketHandler.complete","title":"<code>complete()</code>","text":"<p>Complete the vPacketHandler.</p> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>def complete(self):\n    \"\"\"Complete the vPacketHandler.\"\"\"\n    if not self.completed and not self.failed and not self.terminated:\n        if self.remaining &lt;= 0:\n            self.status.append(COMPLETED)\n            self.terminate()\n            LOGGER.info(\n                f\"{simulation.now:0.2f}:\\t{self.__class__.__name__} {self.label} completed\"\n            )\n            if self.packet.path[-1] is self.packet.current_hop:\n                self.packet.complete()\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vPacketHandler.creation","title":"<code>creation()</code>","text":"<p>The creation process of a vPacketHandler.</p> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>def creation(self):\n    \"\"\"The creation process of a vPacketHandler.\"\"\"\n    super().creation()\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_process/#PyCloudSim.entity.v_process.vPacketHandler.termination","title":"<code>termination()</code>","text":"<p>The termination process of a vPacketHandler.</p> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>def termination(self):\n    \"\"\"The termination process of a vPacketHandler.\"\"\"\n    super(vProcess, self).termination()\n    self.release_resources()\n    self.packet.status.append(DECODED)\n    LOGGER.debug(f\"{simulation.now:0.2f}:\\tvPacket {self.packet.label} is decoded.\")\n    self.packet.current_hop.send_packets()\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_request/","title":"vRequest","text":"<p>             Bases: <code>VirtualEntity</code></p> Source code in <code>PyCloudSim\\entity\\v_request.py</code> <pre><code>class vRequest(VirtualEntity):\n    def __init__(\n        self,\n        source: Union[vUser, vMicroservice],\n        target: Union[vUser, vMicroservice],\n        flow: Optional[WorkFlow] = None,\n        type: str = GET,\n        at: Union[int, float, Callable] = simulation.now,\n        after: Optional[Entity | List[Entity]] = None,\n        label: Optional[str] = None,\n    ):\n        \"\"\"Create a request.\n\n        Args:\n            source (Union[vUser, vMicroservice]): the source of this request, can be vUser or vMicroservice.\n            target (Union[vUser, vMicroservice]): the target of this request, can be vUser or vMicroservice.\n            flow (Optional[WorkFlow], optional): the workflow of this request. Defaults to None.\n            type (str, optional): type of the request, GET, POST, LIST, DELETE. Defaults to GET.\n            at (Union[int, float, Callable], optional): when the request should be created. Defaults to simulation.now.\n            after (Optional[Entity  |  List[Entity]], optional): the entity that this request must be created after. Defaults to None.\n            label (Optional[str], optional): short description of the request. Defaults to None.\n        \"\"\"\n        super().__init__(at, after, label)\n        self._source = source\n        self._target = target\n        self._flow = flow if flow else None\n        if self.flow:\n            if callable(self.flow.priority):\n                self._priority = self.flow.priority()\n            else:\n                self._priority = self.flow.priority\n        else:\n            self._priority = 0\n        self._processes = list()\n        self._packets = list()\n        self._source_endpoint: vContainer = None  # type: ignore\n        self._target_endpoint: vContainer = None  # type: ignore\n        self._type = type\n        self._on_creation = simulation.request_scheduler.schedule\n\n    def creation(self):\n        if self.flow:\n            if self.flow.failed:\n                LOGGER.debug(f\"{simulation.now:0.2f}:\\tvRequest {self.label} creation cancelled due to Workflow {self.flow.label} failed.\")\n                return\n        simulation.REQUESTS.append(self)\n        return super().creation()\n\n\n    def execute(self):\n        \"\"\"Exceute the request by initiating the processes and packets according to the request type.\n\n        Raises:\n            RuntimeError: raise if the request is not scheduled.\n        \"\"\"\n        if self.scheduled:\n            LOGGER.info(f\"{simulation.now:0.2f}:\\tvRequest {self.label} is executing.\")\n            if self.flow is not None:\n                if callable(self.flow.process_length):\n                    process_length = self.flow.process_length()\n                else:\n                    process_length = self.flow.process_length\n            else:\n                process_length = 100\n\n            if self.flow is not None:\n                if callable(self.flow.packet_size):\n                    packet_size = self.flow.packet_size()\n                else:\n                    packet_size = self.flow.packet_size\n            else:\n                packet_size = 65536\n\n            if self.flow is not None:\n                if callable(self.flow.num_packets):\n                    num_packets = self.flow.num_packets()\n                else:\n                    num_packets = self.flow.num_packets\n            else:\n                num_packets = 1\n\n            if self.type == GET:\n                self.execute_get(process_length, packet_size, num_packets)\n            elif self.type == POST:\n                self.execute_post(process_length, packet_size, num_packets)\n            elif self.type == LIST:\n                self.execute_list(process_length, packet_size, num_packets)\n\n        else:\n            raise RuntimeError(f\"vRequest {self.label} is not scheduled.\")\n\n    def execute_get(self, process_length: int, packet_size: int, num_packets: int):\n        \"\"\"Execute the get type request.\n\n        Args:\n            process_length (int): the length of the process, given by the workflow.\n            packet_size (int): the size of the packet, given by the workflow.\n            num_packets (int): the number of packets, given by the workflow.\n        \"\"\"\n        physical_source = (\n            self.source_endpoint.host\n            if self.source_endpoint is not None\n            else simulation.gateway\n        )\n        physical_destination = (\n            self.target_endpoint.host\n            if self.target_endpoint is not None\n            else simulation.gateway\n        )\n\n        if self.source.__class__.__name__ != \"vUser\":\n            process = vProcess(\n                process_length,\n                priority=self.priority,\n                request=self,\n                container=self.source_endpoint,\n                at=simulation.now,\n                label=f\"{self.label}-get\",\n            )\n        else:\n            process = None\n\n        packets = list()\n        packet = vPacket(\n            source=physical_source,\n            destination=physical_destination,\n            request=self,\n            size=packet_size,\n            at=simulation.now,\n            after=process,\n            label=f\"{self.label}-get\",\n        )\n        self.packets.append(packet)\n        packets.append(packet)\n\n        if self.target.__class__.__name__ != \"vUser\":\n            process = vProcess(\n                process_length,\n                priority=self.priority,\n                request=self,\n                container=self.target_endpoint,\n                at=simulation.now,\n                label=f\"{self.label}-reply\",\n                after=packets,\n            )\n        else:\n            process = None\n\n        packets.clear()\n        for _ in range(num_packets):\n            packet = vPacket(\n                source=physical_destination,\n                destination=physical_source,\n                request=self,\n                size=packet_size,\n                at=simulation.now,\n                after=process,\n                label=f\"{self.label}-reply\",\n            )\n            self.packets.append(packet)\n            packets.append(packet)\n\n        if self.source.__class__.__name__ != \"vUser\":\n            process = vProcess(\n                process_length,\n                priority=self.priority,\n                request=self,\n                container=self.source_endpoint,\n                at=simulation.now,\n                label=f\"{self.label}-ack\",\n                after=packets,\n            )\n        else:\n            process = None\n\n        packet = vPacket(\n            source=physical_destination,\n            destination=physical_source,\n            request=self,\n            size=packet_size,\n            at=simulation.now,\n            after=process if process is not None else packets,\n            label=f\"{self.label}-ack\",\n        )\n        packet._on_termination = (\n            lambda: self.complete() if packet.completed and not self.failed else None\n        )\n        self.packets.append(packet)\n        packets.append(packet)\n\n    def execute_post(self, process_length: int, packet_size: int, num_packets: int):\n        \"\"\"Execute the post type request.\n\n        Args:\n            process_length (int): the length of the process, given by the workflow.\n            packet_size (int): the size of the packet, given by the workflow.\n            num_packets (int): the number of packets, given by the workflow.\n        \"\"\"\n        physical_source = (\n            self.source_endpoint.host\n            if self.source_endpoint is not None\n            else simulation.gateway\n        )\n        physical_destination = (\n            self.target_endpoint.host\n            if self.target_endpoint is not None\n            else simulation.gateway\n        )\n\n        if self.source.__class__.__name__ != \"vUser\":\n            process = vProcess(\n                process_length,\n                priority=self.priority,\n                request=self,\n                container=self.source_endpoint,\n                at=simulation.now,\n                label=f\"{self.label}-post\",\n            )\n        else:\n            process = None\n\n        packets = list()\n        for _ in range(num_packets):\n            packet = vPacket(\n                source=physical_source,\n                destination=physical_destination,\n                request=self,\n                size=packet_size,\n                at=simulation.now,\n                after=process,\n                label=f\"{self.label}-post\",\n            )\n            self.packets.append(packet)\n            packets.append(packet)\n\n        if self.target.__class__.__name__ != \"vUser\":\n            process = vProcess(\n                process_length,\n                priority=self.priority,\n                request=self,\n                container=self.target_endpoint,\n                at=simulation.now,\n                label=f\"{self.label}-ack\",\n                after=packets,\n            )\n        else:\n            process = None\n\n        packets.clear()\n        for _ in range(num_packets):\n            packet = vPacket(\n                source=physical_destination,\n                destination=physical_source,\n                request=self,\n                size=packet_size,\n                at=simulation.now,\n                after=process,\n                label=f\"{self.label}-ack\",\n            )\n            self.packets.append(packet)\n            packets.append(packet)\n\n        if self.source.__class__.__name__ != \"vUser\":\n            process = vProcess(\n                process_length,\n                priority=self.priority,\n                request=self,\n                container=self.source_endpoint,\n                at=simulation.now,\n                label=f\"{self.label}-ack\",\n                after=packets,\n            )\n            process._on_termination = (\n                lambda: self.complete()\n                if process and process.completed and not self.failed\n                else None\n            )\n        else:\n            process = None\n            packets[-1].on_termination = (\n                lambda: self.complete()\n                if packets[-1].completed and not self.failed\n                else None\n            )\n\n    def execute_list(self, process_length: int, packet_size: int, num_packets: int):\n        \"\"\"Execute the list type request.\n\n        Args:\n            process_length (int): the length of the process, given by the workflow.\n            packet_size (int): the size of the packet, given by the workflow.\n            num_packets (int): the number of packets, given by the workflow.\n        \"\"\"\n        physical_source = (\n            self.source_endpoint.host\n            if self.source_endpoint is not None\n            else simulation.gateway\n        )\n        physical_destination = (\n            self.target_endpoint.host\n            if self.target_endpoint is not None\n            else simulation.gateway\n        )\n\n        if self.source.__class__.__name__ != \"vUser\":\n            process = vProcess(\n                process_length,\n                priority=self.priority,\n                request=self,\n                container=self.source_endpoint,\n                at=simulation.now,\n                label=f\"{self.label}-get\",\n            )\n        else:\n            process = None\n\n        packets = list()\n        packet = vPacket(\n            source=physical_source,\n            destination=physical_destination,\n            request=self,\n            size=packet_size,\n            at=simulation.now,\n            after=process,\n            label=f\"{self.label}-get\",\n        )\n        self.packets.append(packet)\n        packets.append(packet)\n\n        if self.target.__class__.__name__ != \"vUser\":\n            process = vProcess(\n                process_length,\n                priority=self.priority,\n                request=self,\n                container=self.target_endpoint,\n                at=simulation.now,\n                label=f\"{self.label}-reply\",\n                after=packets,\n            )\n        else:\n            process = None\n\n        packets.clear()\n        for _ in range(num_packets):\n            packet = vPacket(\n                source=physical_destination,\n                destination=physical_source,\n                request=self,\n                size=packet_size,\n                at=simulation.now,\n                after=process,\n                label=f\"{self.label}-reply\",\n            )\n            self.packets.append(packet)\n            packets.append(packet)\n\n        if self.source.__class__.__name__ != \"vUser\":\n            process = vProcess(\n                process_length,\n                priority=self.priority,\n                request=self,\n                container=self.source_endpoint,\n                at=simulation.now,\n                label=f\"{self.label}-ack\",\n                after=packets,\n            )\n        else:\n            process = None\n\n        packet = vPacket(\n            source=physical_destination,\n            destination=physical_source,\n            request=self,\n            size=packet_size,\n            at=simulation.now,\n            after=process if process is not None else packets,\n            label=f\"{self.label}-ack\",\n        )\n        packet._on_termination = (\n            lambda: self.complete() if packet.completed and not self.failed else None\n        )\n        self.packets.append(packet)\n        packets.append(packet)\n\n    def termination(self):\n        \"\"\"Terminate the request by terminating all the processes, and remove the request from the source and target endpoints.\"\"\"\n        super().termination()\n\n        if self.scheduled:\n            if self.source_endpoint is not None:\n                self.source_endpoint.requests.remove(self)\n                LOGGER.info(\n                    f\"{simulation.now:0.2f}:\\tvRequest {self.label} removed from {self.source_endpoint.label}.\"\n                )\n            if self.target_endpoint is not None:\n                self.target_endpoint.requests.remove(self)\n                LOGGER.info(\n                    f\"{simulation.now:0.2f}:\\tvRequest {self.label} removed from {self.target_endpoint.label}.\"\n                )\n        simulation.request_scheduler.schedule()\n\n    def complete(self):\n        \"\"\"Complete the request and engage the termination of the request.\"\"\"\n        if not self.completed:\n            self.status.append(COMPLETED)\n            self.terminate()\n            LOGGER.info(f\"{simulation.now:0.2f}:\\tvRequest {self.label} completed.\")\n\n    def fail(self):\n        \"\"\"Fail the request and engage the termination of the request.\"\"\"\n        if not self.failed:\n            self.status.append(FAILED)\n            self.terminate()\n            LOGGER.info(f\"{simulation.now:0.2f}:\\tvRequest {self.label} failed.\")\n            if self.flow is not None:\n                self.flow.fail()\n\n    @property\n    def source(self) -&gt; Union[vUser, vMicroservice]:\n        return self._source\n\n    @property\n    def source_endpoint(self) -&gt; vContainer:\n        return self._source_endpoint\n\n    @property\n    def target(self) -&gt; Union[vUser, vMicroservice]:\n        return self._target\n\n    @property\n    def target_endpoint(self) -&gt; vContainer:\n        return self._target_endpoint\n\n    @property\n    def processes(self) -&gt; List[vProcess]:\n        return self._processes\n\n    @property\n    def user(self) -&gt; Optional[vUser]:\n        if self.flow:\n            return self.flow.user\n        else:\n            return None\n\n    @property\n    def flow(self):\n        return self._flow\n\n    @property\n    def priority(self) -&gt; int:\n        return self._priority\n\n    @property\n    def ram_usage(self) -&gt; int:\n        return sum([process.ram_usage for process in self.processes])\n\n    @property\n    def packets(self) -&gt; List[vPacket]:\n        return self._packets\n\n    @property\n    def type(self) -&gt; str:\n        return self._type\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_request/#PyCloudSim.entity.v_request.vRequest.__init__","title":"<code>__init__(source, target, flow=None, type=GET, at=simulation.now, after=None, label=None)</code>","text":"<p>Create a request.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Union[vUser, vMicroservice]</code> <p>the source of this request, can be vUser or vMicroservice.</p> required <code>target</code> <code>Union[vUser, vMicroservice]</code> <p>the target of this request, can be vUser or vMicroservice.</p> required <code>flow</code> <code>Optional[WorkFlow]</code> <p>the workflow of this request. Defaults to None.</p> <code>None</code> <code>type</code> <code>str</code> <p>type of the request, GET, POST, LIST, DELETE. Defaults to GET.</p> <code>GET</code> <code>at</code> <code>Union[int, float, Callable]</code> <p>when the request should be created. Defaults to simulation.now.</p> <code>now</code> <code>after</code> <code>Optional[Entity | List[Entity]]</code> <p>the entity that this request must be created after. Defaults to None.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>short description of the request. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_request.py</code> <pre><code>def __init__(\n    self,\n    source: Union[vUser, vMicroservice],\n    target: Union[vUser, vMicroservice],\n    flow: Optional[WorkFlow] = None,\n    type: str = GET,\n    at: Union[int, float, Callable] = simulation.now,\n    after: Optional[Entity | List[Entity]] = None,\n    label: Optional[str] = None,\n):\n    \"\"\"Create a request.\n\n    Args:\n        source (Union[vUser, vMicroservice]): the source of this request, can be vUser or vMicroservice.\n        target (Union[vUser, vMicroservice]): the target of this request, can be vUser or vMicroservice.\n        flow (Optional[WorkFlow], optional): the workflow of this request. Defaults to None.\n        type (str, optional): type of the request, GET, POST, LIST, DELETE. Defaults to GET.\n        at (Union[int, float, Callable], optional): when the request should be created. Defaults to simulation.now.\n        after (Optional[Entity  |  List[Entity]], optional): the entity that this request must be created after. Defaults to None.\n        label (Optional[str], optional): short description of the request. Defaults to None.\n    \"\"\"\n    super().__init__(at, after, label)\n    self._source = source\n    self._target = target\n    self._flow = flow if flow else None\n    if self.flow:\n        if callable(self.flow.priority):\n            self._priority = self.flow.priority()\n        else:\n            self._priority = self.flow.priority\n    else:\n        self._priority = 0\n    self._processes = list()\n    self._packets = list()\n    self._source_endpoint: vContainer = None  # type: ignore\n    self._target_endpoint: vContainer = None  # type: ignore\n    self._type = type\n    self._on_creation = simulation.request_scheduler.schedule\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_request/#PyCloudSim.entity.v_request.vRequest.complete","title":"<code>complete()</code>","text":"<p>Complete the request and engage the termination of the request.</p> Source code in <code>PyCloudSim\\entity\\v_request.py</code> <pre><code>def complete(self):\n    \"\"\"Complete the request and engage the termination of the request.\"\"\"\n    if not self.completed:\n        self.status.append(COMPLETED)\n        self.terminate()\n        LOGGER.info(f\"{simulation.now:0.2f}:\\tvRequest {self.label} completed.\")\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_request/#PyCloudSim.entity.v_request.vRequest.execute","title":"<code>execute()</code>","text":"<p>Exceute the request by initiating the processes and packets according to the request type.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>raise if the request is not scheduled.</p> Source code in <code>PyCloudSim\\entity\\v_request.py</code> <pre><code>def execute(self):\n    \"\"\"Exceute the request by initiating the processes and packets according to the request type.\n\n    Raises:\n        RuntimeError: raise if the request is not scheduled.\n    \"\"\"\n    if self.scheduled:\n        LOGGER.info(f\"{simulation.now:0.2f}:\\tvRequest {self.label} is executing.\")\n        if self.flow is not None:\n            if callable(self.flow.process_length):\n                process_length = self.flow.process_length()\n            else:\n                process_length = self.flow.process_length\n        else:\n            process_length = 100\n\n        if self.flow is not None:\n            if callable(self.flow.packet_size):\n                packet_size = self.flow.packet_size()\n            else:\n                packet_size = self.flow.packet_size\n        else:\n            packet_size = 65536\n\n        if self.flow is not None:\n            if callable(self.flow.num_packets):\n                num_packets = self.flow.num_packets()\n            else:\n                num_packets = self.flow.num_packets\n        else:\n            num_packets = 1\n\n        if self.type == GET:\n            self.execute_get(process_length, packet_size, num_packets)\n        elif self.type == POST:\n            self.execute_post(process_length, packet_size, num_packets)\n        elif self.type == LIST:\n            self.execute_list(process_length, packet_size, num_packets)\n\n    else:\n        raise RuntimeError(f\"vRequest {self.label} is not scheduled.\")\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_request/#PyCloudSim.entity.v_request.vRequest.execute_get","title":"<code>execute_get(process_length, packet_size, num_packets)</code>","text":"<p>Execute the get type request.</p> <p>Parameters:</p> Name Type Description Default <code>process_length</code> <code>int</code> <p>the length of the process, given by the workflow.</p> required <code>packet_size</code> <code>int</code> <p>the size of the packet, given by the workflow.</p> required <code>num_packets</code> <code>int</code> <p>the number of packets, given by the workflow.</p> required Source code in <code>PyCloudSim\\entity\\v_request.py</code> <pre><code>def execute_get(self, process_length: int, packet_size: int, num_packets: int):\n    \"\"\"Execute the get type request.\n\n    Args:\n        process_length (int): the length of the process, given by the workflow.\n        packet_size (int): the size of the packet, given by the workflow.\n        num_packets (int): the number of packets, given by the workflow.\n    \"\"\"\n    physical_source = (\n        self.source_endpoint.host\n        if self.source_endpoint is not None\n        else simulation.gateway\n    )\n    physical_destination = (\n        self.target_endpoint.host\n        if self.target_endpoint is not None\n        else simulation.gateway\n    )\n\n    if self.source.__class__.__name__ != \"vUser\":\n        process = vProcess(\n            process_length,\n            priority=self.priority,\n            request=self,\n            container=self.source_endpoint,\n            at=simulation.now,\n            label=f\"{self.label}-get\",\n        )\n    else:\n        process = None\n\n    packets = list()\n    packet = vPacket(\n        source=physical_source,\n        destination=physical_destination,\n        request=self,\n        size=packet_size,\n        at=simulation.now,\n        after=process,\n        label=f\"{self.label}-get\",\n    )\n    self.packets.append(packet)\n    packets.append(packet)\n\n    if self.target.__class__.__name__ != \"vUser\":\n        process = vProcess(\n            process_length,\n            priority=self.priority,\n            request=self,\n            container=self.target_endpoint,\n            at=simulation.now,\n            label=f\"{self.label}-reply\",\n            after=packets,\n        )\n    else:\n        process = None\n\n    packets.clear()\n    for _ in range(num_packets):\n        packet = vPacket(\n            source=physical_destination,\n            destination=physical_source,\n            request=self,\n            size=packet_size,\n            at=simulation.now,\n            after=process,\n            label=f\"{self.label}-reply\",\n        )\n        self.packets.append(packet)\n        packets.append(packet)\n\n    if self.source.__class__.__name__ != \"vUser\":\n        process = vProcess(\n            process_length,\n            priority=self.priority,\n            request=self,\n            container=self.source_endpoint,\n            at=simulation.now,\n            label=f\"{self.label}-ack\",\n            after=packets,\n        )\n    else:\n        process = None\n\n    packet = vPacket(\n        source=physical_destination,\n        destination=physical_source,\n        request=self,\n        size=packet_size,\n        at=simulation.now,\n        after=process if process is not None else packets,\n        label=f\"{self.label}-ack\",\n    )\n    packet._on_termination = (\n        lambda: self.complete() if packet.completed and not self.failed else None\n    )\n    self.packets.append(packet)\n    packets.append(packet)\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_request/#PyCloudSim.entity.v_request.vRequest.execute_list","title":"<code>execute_list(process_length, packet_size, num_packets)</code>","text":"<p>Execute the list type request.</p> <p>Parameters:</p> Name Type Description Default <code>process_length</code> <code>int</code> <p>the length of the process, given by the workflow.</p> required <code>packet_size</code> <code>int</code> <p>the size of the packet, given by the workflow.</p> required <code>num_packets</code> <code>int</code> <p>the number of packets, given by the workflow.</p> required Source code in <code>PyCloudSim\\entity\\v_request.py</code> <pre><code>def execute_list(self, process_length: int, packet_size: int, num_packets: int):\n    \"\"\"Execute the list type request.\n\n    Args:\n        process_length (int): the length of the process, given by the workflow.\n        packet_size (int): the size of the packet, given by the workflow.\n        num_packets (int): the number of packets, given by the workflow.\n    \"\"\"\n    physical_source = (\n        self.source_endpoint.host\n        if self.source_endpoint is not None\n        else simulation.gateway\n    )\n    physical_destination = (\n        self.target_endpoint.host\n        if self.target_endpoint is not None\n        else simulation.gateway\n    )\n\n    if self.source.__class__.__name__ != \"vUser\":\n        process = vProcess(\n            process_length,\n            priority=self.priority,\n            request=self,\n            container=self.source_endpoint,\n            at=simulation.now,\n            label=f\"{self.label}-get\",\n        )\n    else:\n        process = None\n\n    packets = list()\n    packet = vPacket(\n        source=physical_source,\n        destination=physical_destination,\n        request=self,\n        size=packet_size,\n        at=simulation.now,\n        after=process,\n        label=f\"{self.label}-get\",\n    )\n    self.packets.append(packet)\n    packets.append(packet)\n\n    if self.target.__class__.__name__ != \"vUser\":\n        process = vProcess(\n            process_length,\n            priority=self.priority,\n            request=self,\n            container=self.target_endpoint,\n            at=simulation.now,\n            label=f\"{self.label}-reply\",\n            after=packets,\n        )\n    else:\n        process = None\n\n    packets.clear()\n    for _ in range(num_packets):\n        packet = vPacket(\n            source=physical_destination,\n            destination=physical_source,\n            request=self,\n            size=packet_size,\n            at=simulation.now,\n            after=process,\n            label=f\"{self.label}-reply\",\n        )\n        self.packets.append(packet)\n        packets.append(packet)\n\n    if self.source.__class__.__name__ != \"vUser\":\n        process = vProcess(\n            process_length,\n            priority=self.priority,\n            request=self,\n            container=self.source_endpoint,\n            at=simulation.now,\n            label=f\"{self.label}-ack\",\n            after=packets,\n        )\n    else:\n        process = None\n\n    packet = vPacket(\n        source=physical_destination,\n        destination=physical_source,\n        request=self,\n        size=packet_size,\n        at=simulation.now,\n        after=process if process is not None else packets,\n        label=f\"{self.label}-ack\",\n    )\n    packet._on_termination = (\n        lambda: self.complete() if packet.completed and not self.failed else None\n    )\n    self.packets.append(packet)\n    packets.append(packet)\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_request/#PyCloudSim.entity.v_request.vRequest.execute_post","title":"<code>execute_post(process_length, packet_size, num_packets)</code>","text":"<p>Execute the post type request.</p> <p>Parameters:</p> Name Type Description Default <code>process_length</code> <code>int</code> <p>the length of the process, given by the workflow.</p> required <code>packet_size</code> <code>int</code> <p>the size of the packet, given by the workflow.</p> required <code>num_packets</code> <code>int</code> <p>the number of packets, given by the workflow.</p> required Source code in <code>PyCloudSim\\entity\\v_request.py</code> <pre><code>def execute_post(self, process_length: int, packet_size: int, num_packets: int):\n    \"\"\"Execute the post type request.\n\n    Args:\n        process_length (int): the length of the process, given by the workflow.\n        packet_size (int): the size of the packet, given by the workflow.\n        num_packets (int): the number of packets, given by the workflow.\n    \"\"\"\n    physical_source = (\n        self.source_endpoint.host\n        if self.source_endpoint is not None\n        else simulation.gateway\n    )\n    physical_destination = (\n        self.target_endpoint.host\n        if self.target_endpoint is not None\n        else simulation.gateway\n    )\n\n    if self.source.__class__.__name__ != \"vUser\":\n        process = vProcess(\n            process_length,\n            priority=self.priority,\n            request=self,\n            container=self.source_endpoint,\n            at=simulation.now,\n            label=f\"{self.label}-post\",\n        )\n    else:\n        process = None\n\n    packets = list()\n    for _ in range(num_packets):\n        packet = vPacket(\n            source=physical_source,\n            destination=physical_destination,\n            request=self,\n            size=packet_size,\n            at=simulation.now,\n            after=process,\n            label=f\"{self.label}-post\",\n        )\n        self.packets.append(packet)\n        packets.append(packet)\n\n    if self.target.__class__.__name__ != \"vUser\":\n        process = vProcess(\n            process_length,\n            priority=self.priority,\n            request=self,\n            container=self.target_endpoint,\n            at=simulation.now,\n            label=f\"{self.label}-ack\",\n            after=packets,\n        )\n    else:\n        process = None\n\n    packets.clear()\n    for _ in range(num_packets):\n        packet = vPacket(\n            source=physical_destination,\n            destination=physical_source,\n            request=self,\n            size=packet_size,\n            at=simulation.now,\n            after=process,\n            label=f\"{self.label}-ack\",\n        )\n        self.packets.append(packet)\n        packets.append(packet)\n\n    if self.source.__class__.__name__ != \"vUser\":\n        process = vProcess(\n            process_length,\n            priority=self.priority,\n            request=self,\n            container=self.source_endpoint,\n            at=simulation.now,\n            label=f\"{self.label}-ack\",\n            after=packets,\n        )\n        process._on_termination = (\n            lambda: self.complete()\n            if process and process.completed and not self.failed\n            else None\n        )\n    else:\n        process = None\n        packets[-1].on_termination = (\n            lambda: self.complete()\n            if packets[-1].completed and not self.failed\n            else None\n        )\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_request/#PyCloudSim.entity.v_request.vRequest.fail","title":"<code>fail()</code>","text":"<p>Fail the request and engage the termination of the request.</p> Source code in <code>PyCloudSim\\entity\\v_request.py</code> <pre><code>def fail(self):\n    \"\"\"Fail the request and engage the termination of the request.\"\"\"\n    if not self.failed:\n        self.status.append(FAILED)\n        self.terminate()\n        LOGGER.info(f\"{simulation.now:0.2f}:\\tvRequest {self.label} failed.\")\n        if self.flow is not None:\n            self.flow.fail()\n</code></pre>"},{"location":"api/virtual_entity/process_packet_request/v_request/#PyCloudSim.entity.v_request.vRequest.termination","title":"<code>termination()</code>","text":"<p>Terminate the request by terminating all the processes, and remove the request from the source and target endpoints.</p> Source code in <code>PyCloudSim\\entity\\v_request.py</code> <pre><code>def termination(self):\n    \"\"\"Terminate the request by terminating all the processes, and remove the request from the source and target endpoints.\"\"\"\n    super().termination()\n\n    if self.scheduled:\n        if self.source_endpoint is not None:\n            self.source_endpoint.requests.remove(self)\n            LOGGER.info(\n                f\"{simulation.now:0.2f}:\\tvRequest {self.label} removed from {self.source_endpoint.label}.\"\n            )\n        if self.target_endpoint is not None:\n            self.target_endpoint.requests.remove(self)\n            LOGGER.info(\n                f\"{simulation.now:0.2f}:\\tvRequest {self.label} removed from {self.target_endpoint.label}.\"\n            )\n    simulation.request_scheduler.schedule()\n</code></pre>"},{"location":"api/virtual_entity/sfc_networkservice/","title":"Index","text":"<p>The class \"vSFC\" represents the simulated Service Function Chain, which is comprised of one or more instances of the \"vMicroservice\" class. The topology of the \"vMicroservice\" instances within the \"vSFC\" determines the order and type of simulated API calls when the \"vSFC\" is engaged by a simulated user.</p> <p>The directional links between \"vMicroservice\" instances within the \"vSFC\" define the sequence of API calls that will occur. This topology simulates the flow of requests and interactions between the different microservices within the Service Function Chain.</p> <p>On the other hand, the class \"vNetworkService\" serves as a collection of \"vMicroservice\" instances and their associated topology. Multiple instances of the \"vSFC\" class can be derived from a single \"vNetworkService\". For example, a \"vNetworkService\" representing the 5G SA core could contain one \"vSFC\" for user device authentication and another \"vSFC\" for internet access.</p> <p>Both the \"vSFC\" and \"vNetworkService\" classes are considered ready only when all their associated \"vMicroservice\" instances have reached a ready state. The readiness of a \"vMicroservice\" is determined by various factors, such as the completion of initialization and the fulfilment of resource requirements.</p> <p>When a \"vSFC\" is ready, it can be engaged by a simulated user. However, if the \"vSFC\" is not yet ready, the engagement will be put on hold until all the necessary components are in a ready state.</p> <p>Overall, the \"vSFC\" and \"vNetworkService\" classes enable the modelling and simulation of Service Function Chains and their associated network services, ensuring readiness and proper sequencing of simulated API calls within the simulated cloud environment.</p>"},{"location":"api/virtual_entity/sfc_networkservice/v_networkservice/","title":"vNetworkService","text":"<p>             Bases: <code>VirtualEntity</code></p> Source code in <code>PyCloudSim\\entity\\v_networkservice.py</code> <pre><code>class vNetworkService(VirtualEntity):\n    def __init__(\n        self,\n        microservices: List[vMicroservice],\n        links: List[Tuple[vMicroservice, vMicroservice]],\n        entry: Optional[vMicroservice | List[vMicroservice]],\n        exit: Optional[vMicroservice | List[vMicroservice]],\n        at: Union[int, float, Callable] = simulation.now,\n        after: Optional[Entity | List[Entity]] = None,\n        label: Optional[str] = None,\n    ):\n        \"\"\"Create a vNetworkService\n\n        Args:\n            microservices (List[vMicroservice]): the list of engaged microservices.\n            links (List[Tuple[vMicroservice, vMicroservice]]): the links of the microservices.\n            entry (Optional[vMicroservice  |  List[vMicroservice]]): the entry point of the network service, aka the microservice that will accept user's request at the beginning.\n            exit (Optional[vMicroservice  |  List[vMicroservice]]): _description_\n            at (Union[int, float, Callable], optional): _description_. Defaults to simulation.now.\n            after (Optional[Entity  |  List[Entity]], optional): _description_. Defaults to None.\n            label (Optional[str], optional): _description_. Defaults to None.\n        \"\"\"\n        super().__init__(at=at, after=after, label=label)\n\n        self._microservices = microservices\n        self._links = links\n        self._graph = nx.DiGraph()\n        self.graph.add_nodes_from(self.microservices)\n        for link in self.links:\n            self.graph.add_edge(link[0], link[1])\n            self.graph.add_edge(link[1], link[0])\n\n        if isinstance(entry, list):\n            self._entry = list()\n            for e in entry:\n                if e in self.graph.nodes:\n                    self._entry.append(e)\n                else:\n                    raise ValueError(\n                        f\"vMicroservice {e.label} is not in the topology of vNetworkService {self.label}\"\n                    )\n        elif isinstance(entry, vMicroservice):\n            if entry in self.graph.nodes:\n                self._entry = entry\n            else:\n                raise ValueError(\n                    f\"vMicroservice {entry.label} is not in the topology of vNetworkService {self.label}\"\n                )\n\n        if isinstance(exit, list):\n            self._exit = list()\n            for e in exit:\n                if e in self.graph.nodes:\n                    self._exit.append(e)\n                else:\n                    raise ValueError(\n                        f\"vMicroservice {e.label} is not in the topology of vNetworkService {self.label}\"\n                    )\n        elif isinstance(exit, vMicroservice):\n            if exit in self.graph.nodes:\n                self._exit = exit\n            else:\n                raise ValueError(\n                    f\"vMicroservice {exit.label} is not in the topology of vNetworkService {self.label}\"\n                )\n\n        simulation.NETWORKSERVICES.append(self)\n\n    def termination(self):\n        \"\"\"Terminate the vNetworkService and all its microservices and SFCS\"\"\"\n        super().termination()\n        for ms in self.microservices:\n            ms.terminate()\n        for sfc in simulation.SFCS:\n            if sfc.network_service is self:\n                sfc.terminate()\n\n    def draw(self, save: bool = False):\n        \"\"\"Plot the topology of the vNetworkService\"\"\"\n        fig, ax = plt.subplots()\n        label_mapping = dict()\n        for ms in self.microservices:\n            label_mapping[ms] = ms.label\n        pos = spring_layout(self.graph)\n        for node in self.graph.nodes:\n            draw_networkx_nodes(\n                self.graph, pos, ax=ax, nodelist=[node], node_color=\"tab:green\"\n            )\n        for edge in self.graph.edges:\n            draw_networkx_edges(\n                self.graph, pos, ax=ax, edgelist=[edge], edge_color=\"tab:gray\"\n            )\n        if isinstance(self.entry, list):\n            draw_networkx_nodes(\n                self.graph, pos, ax=ax, nodelist=self.entry, node_color=\"tab:red\"\n            )\n        elif isinstance(self.entry, vMicroservice):\n            draw_networkx_nodes(\n                self.graph, pos, ax=ax, nodelist=[self.entry], node_color=\"tab:red\"\n            )\n        if isinstance(self.exit, list):\n            draw_networkx_nodes(\n                self.graph, pos, ax=ax, nodelist=self.exit, node_color=\"tab:blue\"\n            )\n        elif isinstance(self.exit, vMicroservice):\n            draw_networkx_nodes(\n                self.graph, pos, ax=ax, nodelist=[self.exit], node_color=\"tab:blue\"\n            )\n        draw_networkx_labels(self.graph, pos, labels=label_mapping, ax=ax)\n        plt.show()\n        if save:\n            fig.savefig(f\"{self.label}.png\")\n\n    @property\n    def microservices(self) -&gt; List[vMicroservice]:\n        \"\"\"The list of microservices engaged in the vNetworkService\"\"\"\n        return self._microservices\n\n    @property\n    def links(self) -&gt; List[Tuple[vMicroservice, vMicroservice]]:\n        \"\"\"The links of the microservices\"\"\"\n        return self._links\n\n    @property\n    def graph(self) -&gt; nx.DiGraph:\n        \"\"\"The topology of the vNetworkService\"\"\"\n        return self._graph\n\n    @property\n    def entry(self) -&gt; Optional[vMicroservice | List[vMicroservice]]:\n        \"\"\"The entry point of the vNetworkService\"\"\"\n        return self._entry\n\n    @property\n    def exit(self) -&gt; Optional[vMicroservice | List[vMicroservice]]:\n        \"\"\"The exit point of the vNetworkService\"\"\"\n        return self._exit\n</code></pre>"},{"location":"api/virtual_entity/sfc_networkservice/v_networkservice/#PyCloudSim.entity.v_networkservice.vNetworkService.entry","title":"<code>entry: Optional[vMicroservice | List[vMicroservice]]</code>  <code>property</code>","text":"<p>The entry point of the vNetworkService</p>"},{"location":"api/virtual_entity/sfc_networkservice/v_networkservice/#PyCloudSim.entity.v_networkservice.vNetworkService.exit","title":"<code>exit: Optional[vMicroservice | List[vMicroservice]]</code>  <code>property</code>","text":"<p>The exit point of the vNetworkService</p>"},{"location":"api/virtual_entity/sfc_networkservice/v_networkservice/#PyCloudSim.entity.v_networkservice.vNetworkService.graph","title":"<code>graph: nx.DiGraph</code>  <code>property</code>","text":"<p>The topology of the vNetworkService</p>"},{"location":"api/virtual_entity/sfc_networkservice/v_networkservice/#PyCloudSim.entity.v_networkservice.vNetworkService.links","title":"<code>links: List[Tuple[vMicroservice, vMicroservice]]</code>  <code>property</code>","text":"<p>The links of the microservices</p>"},{"location":"api/virtual_entity/sfc_networkservice/v_networkservice/#PyCloudSim.entity.v_networkservice.vNetworkService.microservices","title":"<code>microservices: List[vMicroservice]</code>  <code>property</code>","text":"<p>The list of microservices engaged in the vNetworkService</p>"},{"location":"api/virtual_entity/sfc_networkservice/v_networkservice/#PyCloudSim.entity.v_networkservice.vNetworkService.__init__","title":"<code>__init__(microservices, links, entry, exit, at=simulation.now, after=None, label=None)</code>","text":"<p>Create a vNetworkService</p> <p>Parameters:</p> Name Type Description Default <code>microservices</code> <code>List[vMicroservice]</code> <p>the list of engaged microservices.</p> required <code>links</code> <code>List[Tuple[vMicroservice, vMicroservice]]</code> <p>the links of the microservices.</p> required <code>entry</code> <code>Optional[vMicroservice | List[vMicroservice]]</code> <p>the entry point of the network service, aka the microservice that will accept user's request at the beginning.</p> required <code>exit</code> <code>Optional[vMicroservice | List[vMicroservice]]</code> <p>description</p> required <code>at</code> <code>Union[int, float, Callable]</code> <p>description. Defaults to simulation.now.</p> <code>now</code> <code>after</code> <code>Optional[Entity | List[Entity]]</code> <p>description. Defaults to None.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>description. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_networkservice.py</code> <pre><code>def __init__(\n    self,\n    microservices: List[vMicroservice],\n    links: List[Tuple[vMicroservice, vMicroservice]],\n    entry: Optional[vMicroservice | List[vMicroservice]],\n    exit: Optional[vMicroservice | List[vMicroservice]],\n    at: Union[int, float, Callable] = simulation.now,\n    after: Optional[Entity | List[Entity]] = None,\n    label: Optional[str] = None,\n):\n    \"\"\"Create a vNetworkService\n\n    Args:\n        microservices (List[vMicroservice]): the list of engaged microservices.\n        links (List[Tuple[vMicroservice, vMicroservice]]): the links of the microservices.\n        entry (Optional[vMicroservice  |  List[vMicroservice]]): the entry point of the network service, aka the microservice that will accept user's request at the beginning.\n        exit (Optional[vMicroservice  |  List[vMicroservice]]): _description_\n        at (Union[int, float, Callable], optional): _description_. Defaults to simulation.now.\n        after (Optional[Entity  |  List[Entity]], optional): _description_. Defaults to None.\n        label (Optional[str], optional): _description_. Defaults to None.\n    \"\"\"\n    super().__init__(at=at, after=after, label=label)\n\n    self._microservices = microservices\n    self._links = links\n    self._graph = nx.DiGraph()\n    self.graph.add_nodes_from(self.microservices)\n    for link in self.links:\n        self.graph.add_edge(link[0], link[1])\n        self.graph.add_edge(link[1], link[0])\n\n    if isinstance(entry, list):\n        self._entry = list()\n        for e in entry:\n            if e in self.graph.nodes:\n                self._entry.append(e)\n            else:\n                raise ValueError(\n                    f\"vMicroservice {e.label} is not in the topology of vNetworkService {self.label}\"\n                )\n    elif isinstance(entry, vMicroservice):\n        if entry in self.graph.nodes:\n            self._entry = entry\n        else:\n            raise ValueError(\n                f\"vMicroservice {entry.label} is not in the topology of vNetworkService {self.label}\"\n            )\n\n    if isinstance(exit, list):\n        self._exit = list()\n        for e in exit:\n            if e in self.graph.nodes:\n                self._exit.append(e)\n            else:\n                raise ValueError(\n                    f\"vMicroservice {e.label} is not in the topology of vNetworkService {self.label}\"\n                )\n    elif isinstance(exit, vMicroservice):\n        if exit in self.graph.nodes:\n            self._exit = exit\n        else:\n            raise ValueError(\n                f\"vMicroservice {exit.label} is not in the topology of vNetworkService {self.label}\"\n            )\n\n    simulation.NETWORKSERVICES.append(self)\n</code></pre>"},{"location":"api/virtual_entity/sfc_networkservice/v_networkservice/#PyCloudSim.entity.v_networkservice.vNetworkService.draw","title":"<code>draw(save=False)</code>","text":"<p>Plot the topology of the vNetworkService</p> Source code in <code>PyCloudSim\\entity\\v_networkservice.py</code> <pre><code>def draw(self, save: bool = False):\n    \"\"\"Plot the topology of the vNetworkService\"\"\"\n    fig, ax = plt.subplots()\n    label_mapping = dict()\n    for ms in self.microservices:\n        label_mapping[ms] = ms.label\n    pos = spring_layout(self.graph)\n    for node in self.graph.nodes:\n        draw_networkx_nodes(\n            self.graph, pos, ax=ax, nodelist=[node], node_color=\"tab:green\"\n        )\n    for edge in self.graph.edges:\n        draw_networkx_edges(\n            self.graph, pos, ax=ax, edgelist=[edge], edge_color=\"tab:gray\"\n        )\n    if isinstance(self.entry, list):\n        draw_networkx_nodes(\n            self.graph, pos, ax=ax, nodelist=self.entry, node_color=\"tab:red\"\n        )\n    elif isinstance(self.entry, vMicroservice):\n        draw_networkx_nodes(\n            self.graph, pos, ax=ax, nodelist=[self.entry], node_color=\"tab:red\"\n        )\n    if isinstance(self.exit, list):\n        draw_networkx_nodes(\n            self.graph, pos, ax=ax, nodelist=self.exit, node_color=\"tab:blue\"\n        )\n    elif isinstance(self.exit, vMicroservice):\n        draw_networkx_nodes(\n            self.graph, pos, ax=ax, nodelist=[self.exit], node_color=\"tab:blue\"\n        )\n    draw_networkx_labels(self.graph, pos, labels=label_mapping, ax=ax)\n    plt.show()\n    if save:\n        fig.savefig(f\"{self.label}.png\")\n</code></pre>"},{"location":"api/virtual_entity/sfc_networkservice/v_networkservice/#PyCloudSim.entity.v_networkservice.vNetworkService.termination","title":"<code>termination()</code>","text":"<p>Terminate the vNetworkService and all its microservices and SFCS</p> Source code in <code>PyCloudSim\\entity\\v_networkservice.py</code> <pre><code>def termination(self):\n    \"\"\"Terminate the vNetworkService and all its microservices and SFCS\"\"\"\n    super().termination()\n    for ms in self.microservices:\n        ms.terminate()\n    for sfc in simulation.SFCS:\n        if sfc.network_service is self:\n            sfc.terminate()\n</code></pre>"},{"location":"api/virtual_entity/sfc_networkservice/v_sfc/","title":"vSFC","text":"<p>             Bases: <code>VirtualEntity</code></p> Source code in <code>PyCloudSim\\entity\\v_sfc.py</code> <pre><code>class vSFC(VirtualEntity):\n    def __init__(\n        self,\n        entry: Optional[Tuple[vMicroservice, str]] = None,\n        exit: Optional[Tuple[vMicroservice, str]] = None,\n        path: Optional[List[Tuple[vMicroservice, vMicroservice, str]]] = None,\n        network_service: Optional[vNetworkService] = None,\n        internal: bool = False,\n        at: Union[int, float, Callable] = simulation.now,\n        after: Optional[Entity | List[Entity]] = None,\n        label: Optional[str] = None,\n    ):\n        \"\"\"Create a vSFC (with respective of a network service)\n\n        Args:\n            entry (Optional[vMicroservice], optional): the entry point of the SFC, aka the microservice that will accept user's request at the beginning. Defaults to None, must be set if the sfc is not internal.\n            exit (Optional[vMicroservice], optional): the exit point of the SFC, aka the microservice that will return user's request at the last. Defaults to None.\n            path (Optional[List[Tuple[vMicroservice, vMicroservice]]], optional): the path of the engaged microservices, must be a list of tuple of two microservice. Defaults to None.\n            network_service (Optional[vNetworkService], optional): the associated network service. Defaults to None.\n            process_length (Union[int, Callable], optional): the process length of each request. Defaults to 100, can alse be a callable function.\n            packet_size (Union[int, Callable], optional): the packet size of each packet. Defaults to 65536, can alse be a callable function.\n            num_packets (Union[int, Callable], optional): the number of packets per request. Defaults to 1, can alse be a callable function.\n            priority (int, optional): the priority of the SFC. Defaults to 0.\n            num_users (int, optional): the number of users. Defaults to 1.\n            internal (bool, optional): set true for internal SFC, aka the engaged microservices does not need to communicate with the user. Defaults to False.\n            retry (bool, optional): if true, failed user will have its request being re-initialized. Defaults to False.\n            at (Union[int, float, Callable], optional): when the SFC will be created. Defaults to simulation.now.\n            after (Optional[Entity  |  List[Entity]], optional): the other SFCs that must complete before this SFC. Defaults to None.\n            label (Optional[str], optional): short description of this SFC. Defaults to None.\n        \"\"\"\n        super().__init__(at, after, label)\n        # check if the vSFC is valid\n        self._entry = entry\n        self._exit = exit\n        self._path = path if path is not None else list()\n\n        if path is not None:\n            if self.entry is not None:\n                if self.entry[0] is not path[0][0]:\n                    raise ValueError(\n                        f\"Start vMicroservice {self.entry[0].label} is not the same as the first node {path[0][0].label} in the path\"\n                    )\n            if self.exit is not None:\n                if self.exit[0] is not path[-1][1]:\n                    raise ValueError(\n                        f\"End vMicroservice {self.exit[0].label} is not the same as the last node {path[-1][1].label} in the path\"\n                    )\n\n        # check if the vSFC is valid with respect to the vNetworkService\n        self._ns_id = network_service.id if network_service is not None else None\n        if self.network_service is not None:\n            if self.entry is not None:\n                if isinstance(self.network_service.entry, list):\n                    if self.entry[0] not in self.network_service.entry:\n                        raise ValueError(\n                            f\"vSFC {self.label} Start vMicroservice {self.entry[0].label} is not one of the entries vNetworkService {self.network_service.label}\"\n                        )\n                else:\n                    if self.entry[0] is not self.network_service.entry:\n                        raise ValueError(\n                            f\"vSFC {self.label} Start vMicroservice {self.entry[0].label} is not the entry vNetworkService {self.network_service.label}\"\n                        )\n            if self.exit is not None:\n                if isinstance(self.network_service.exit, list):\n                    if self.exit[0] not in self.network_service.exit:\n                        raise ValueError(\n                            f\"vSFC {self.label} End vMicroservice {self.exit[0].label} is not one of the exits vNetworkService {self.network_service.label}\"\n                        )\n                else:\n                    if self.exit[0] is not self.network_service.exit:\n                        raise ValueError(\n                            f\"vSFC {self.label} End vMicroservice {self.exit[0].label} is not the exit vNetworkService {self.network_service.label}\"\n                        )\n\n        self._microservices: List[vMicroservice] = list()\n        for link in self.path:\n            if link[0] not in self.microservices:\n                self.microservices.append(link[0])\n            if link[1] not in self.microservices:\n                self.microservices.append(link[1])\n        self._users = list()\n        self._internal = internal\n        self._after: Union[vSFC, List[vSFC]] = after  # type: ignore\n        simulation.SFCS.append(self)\n\n    def termination(self):\n        \"\"\"Terminate the vSFC and all its microservices.\"\"\"\n        super().termination()\n        for ms in self.microservices:\n            if not ms.terminated:\n                ms.terminate()\n\n    def evaluate(self):\n        \"\"\"Evaluate the vSFC and all its microservices. Change the status of the vSFC to READY if all its microservices are ready.\"\"\"\n        if all(ms.ready for ms in self.microservices):\n            self.status.append(READY)\n            LOGGER.info(f\"{simulation.now:0.2f}:\\tvSFC {self.label} is ready.\")\n        else:\n            if self.ready:\n                self.status.remove(READY)\n\n    @property\n    def entry(self):\n        \"\"\"The entry point of the SFC, aka the microservice that will accept user's request at the beginning.\"\"\"\n        return self._entry\n\n    @property\n    def exit(self):\n        \"\"\"The exit point of the SFC, aka the microservice that will return user's request at the last.\"\"\"\n        return self._exit\n\n    @property\n    def path(self):\n        \"\"\"The path of the engaged microservices, must be a list of tuple of two microservice and request type.\"\"\"\n        return self._path\n\n    @property\n    def users(self):\n        \"\"\"The users of the vSFC.\"\"\"\n        return self._users\n\n    @property\n    def microservices(self):\n        \"\"\"The microservices of the vSFC.\"\"\"\n        return self._microservices\n\n    @property\n    def network_service(self) -&gt; Optional[vNetworkService]:\n        \"\"\"The associated network service.\"\"\"\n        if self._ns_id is not None:\n            for ns in simulation.NETWORKSERVICES:\n                if ns.id == self._ns_id:\n                    return ns\n            raise RuntimeError(\n                f\"vSFC {self.label} cannot find its associated network service\"\n            )\n        else:\n            return None\n\n    @property\n    def internal(self):\n        \"\"\"Return true if the vSFC is internal, aka the engaged microservices does not need to communicate with the user.\"\"\"\"\"\n        return self._internal\n\n    @property\n    def after(self):\n        \"\"\"Same as entity.\"\"\"\n        return self._after\n\n    @property\n    def ready(self):\n        \"\"\"Return true if the vSFC is ready, aka all its microservices are ready.\"\"\"\n        return READY in self.status\n</code></pre>"},{"location":"api/virtual_entity/sfc_networkservice/v_sfc/#PyCloudSim.entity.v_sfc.vSFC.after","title":"<code>after</code>  <code>property</code>","text":"<p>Same as entity.</p>"},{"location":"api/virtual_entity/sfc_networkservice/v_sfc/#PyCloudSim.entity.v_sfc.vSFC.entry","title":"<code>entry</code>  <code>property</code>","text":"<p>The entry point of the SFC, aka the microservice that will accept user's request at the beginning.</p>"},{"location":"api/virtual_entity/sfc_networkservice/v_sfc/#PyCloudSim.entity.v_sfc.vSFC.exit","title":"<code>exit</code>  <code>property</code>","text":"<p>The exit point of the SFC, aka the microservice that will return user's request at the last.</p>"},{"location":"api/virtual_entity/sfc_networkservice/v_sfc/#PyCloudSim.entity.v_sfc.vSFC.internal","title":"<code>internal</code>  <code>property</code>","text":"<p>Return true if the vSFC is internal, aka the engaged microservices does not need to communicate with the user.</p>"},{"location":"api/virtual_entity/sfc_networkservice/v_sfc/#PyCloudSim.entity.v_sfc.vSFC.microservices","title":"<code>microservices</code>  <code>property</code>","text":"<p>The microservices of the vSFC.</p>"},{"location":"api/virtual_entity/sfc_networkservice/v_sfc/#PyCloudSim.entity.v_sfc.vSFC.network_service","title":"<code>network_service: Optional[vNetworkService]</code>  <code>property</code>","text":"<p>The associated network service.</p>"},{"location":"api/virtual_entity/sfc_networkservice/v_sfc/#PyCloudSim.entity.v_sfc.vSFC.path","title":"<code>path</code>  <code>property</code>","text":"<p>The path of the engaged microservices, must be a list of tuple of two microservice and request type.</p>"},{"location":"api/virtual_entity/sfc_networkservice/v_sfc/#PyCloudSim.entity.v_sfc.vSFC.ready","title":"<code>ready</code>  <code>property</code>","text":"<p>Return true if the vSFC is ready, aka all its microservices are ready.</p>"},{"location":"api/virtual_entity/sfc_networkservice/v_sfc/#PyCloudSim.entity.v_sfc.vSFC.users","title":"<code>users</code>  <code>property</code>","text":"<p>The users of the vSFC.</p>"},{"location":"api/virtual_entity/sfc_networkservice/v_sfc/#PyCloudSim.entity.v_sfc.vSFC.__init__","title":"<code>__init__(entry=None, exit=None, path=None, network_service=None, internal=False, at=simulation.now, after=None, label=None)</code>","text":"<p>Create a vSFC (with respective of a network service)</p> <p>Parameters:</p> Name Type Description Default <code>entry</code> <code>Optional[vMicroservice]</code> <p>the entry point of the SFC, aka the microservice that will accept user's request at the beginning. Defaults to None, must be set if the sfc is not internal.</p> <code>None</code> <code>exit</code> <code>Optional[vMicroservice]</code> <p>the exit point of the SFC, aka the microservice that will return user's request at the last. Defaults to None.</p> <code>None</code> <code>path</code> <code>Optional[List[Tuple[vMicroservice, vMicroservice]]]</code> <p>the path of the engaged microservices, must be a list of tuple of two microservice. Defaults to None.</p> <code>None</code> <code>network_service</code> <code>Optional[vNetworkService]</code> <p>the associated network service. Defaults to None.</p> <code>None</code> <code>process_length</code> <code>Union[int, Callable]</code> <p>the process length of each request. Defaults to 100, can alse be a callable function.</p> required <code>packet_size</code> <code>Union[int, Callable]</code> <p>the packet size of each packet. Defaults to 65536, can alse be a callable function.</p> required <code>num_packets</code> <code>Union[int, Callable]</code> <p>the number of packets per request. Defaults to 1, can alse be a callable function.</p> required <code>priority</code> <code>int</code> <p>the priority of the SFC. Defaults to 0.</p> required <code>num_users</code> <code>int</code> <p>the number of users. Defaults to 1.</p> required <code>internal</code> <code>bool</code> <p>set true for internal SFC, aka the engaged microservices does not need to communicate with the user. Defaults to False.</p> <code>False</code> <code>retry</code> <code>bool</code> <p>if true, failed user will have its request being re-initialized. Defaults to False.</p> required <code>at</code> <code>Union[int, float, Callable]</code> <p>when the SFC will be created. Defaults to simulation.now.</p> <code>now</code> <code>after</code> <code>Optional[Entity | List[Entity]]</code> <p>the other SFCs that must complete before this SFC. Defaults to None.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>short description of this SFC. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_sfc.py</code> <pre><code>def __init__(\n    self,\n    entry: Optional[Tuple[vMicroservice, str]] = None,\n    exit: Optional[Tuple[vMicroservice, str]] = None,\n    path: Optional[List[Tuple[vMicroservice, vMicroservice, str]]] = None,\n    network_service: Optional[vNetworkService] = None,\n    internal: bool = False,\n    at: Union[int, float, Callable] = simulation.now,\n    after: Optional[Entity | List[Entity]] = None,\n    label: Optional[str] = None,\n):\n    \"\"\"Create a vSFC (with respective of a network service)\n\n    Args:\n        entry (Optional[vMicroservice], optional): the entry point of the SFC, aka the microservice that will accept user's request at the beginning. Defaults to None, must be set if the sfc is not internal.\n        exit (Optional[vMicroservice], optional): the exit point of the SFC, aka the microservice that will return user's request at the last. Defaults to None.\n        path (Optional[List[Tuple[vMicroservice, vMicroservice]]], optional): the path of the engaged microservices, must be a list of tuple of two microservice. Defaults to None.\n        network_service (Optional[vNetworkService], optional): the associated network service. Defaults to None.\n        process_length (Union[int, Callable], optional): the process length of each request. Defaults to 100, can alse be a callable function.\n        packet_size (Union[int, Callable], optional): the packet size of each packet. Defaults to 65536, can alse be a callable function.\n        num_packets (Union[int, Callable], optional): the number of packets per request. Defaults to 1, can alse be a callable function.\n        priority (int, optional): the priority of the SFC. Defaults to 0.\n        num_users (int, optional): the number of users. Defaults to 1.\n        internal (bool, optional): set true for internal SFC, aka the engaged microservices does not need to communicate with the user. Defaults to False.\n        retry (bool, optional): if true, failed user will have its request being re-initialized. Defaults to False.\n        at (Union[int, float, Callable], optional): when the SFC will be created. Defaults to simulation.now.\n        after (Optional[Entity  |  List[Entity]], optional): the other SFCs that must complete before this SFC. Defaults to None.\n        label (Optional[str], optional): short description of this SFC. Defaults to None.\n    \"\"\"\n    super().__init__(at, after, label)\n    # check if the vSFC is valid\n    self._entry = entry\n    self._exit = exit\n    self._path = path if path is not None else list()\n\n    if path is not None:\n        if self.entry is not None:\n            if self.entry[0] is not path[0][0]:\n                raise ValueError(\n                    f\"Start vMicroservice {self.entry[0].label} is not the same as the first node {path[0][0].label} in the path\"\n                )\n        if self.exit is not None:\n            if self.exit[0] is not path[-1][1]:\n                raise ValueError(\n                    f\"End vMicroservice {self.exit[0].label} is not the same as the last node {path[-1][1].label} in the path\"\n                )\n\n    # check if the vSFC is valid with respect to the vNetworkService\n    self._ns_id = network_service.id if network_service is not None else None\n    if self.network_service is not None:\n        if self.entry is not None:\n            if isinstance(self.network_service.entry, list):\n                if self.entry[0] not in self.network_service.entry:\n                    raise ValueError(\n                        f\"vSFC {self.label} Start vMicroservice {self.entry[0].label} is not one of the entries vNetworkService {self.network_service.label}\"\n                    )\n            else:\n                if self.entry[0] is not self.network_service.entry:\n                    raise ValueError(\n                        f\"vSFC {self.label} Start vMicroservice {self.entry[0].label} is not the entry vNetworkService {self.network_service.label}\"\n                    )\n        if self.exit is not None:\n            if isinstance(self.network_service.exit, list):\n                if self.exit[0] not in self.network_service.exit:\n                    raise ValueError(\n                        f\"vSFC {self.label} End vMicroservice {self.exit[0].label} is not one of the exits vNetworkService {self.network_service.label}\"\n                    )\n            else:\n                if self.exit[0] is not self.network_service.exit:\n                    raise ValueError(\n                        f\"vSFC {self.label} End vMicroservice {self.exit[0].label} is not the exit vNetworkService {self.network_service.label}\"\n                    )\n\n    self._microservices: List[vMicroservice] = list()\n    for link in self.path:\n        if link[0] not in self.microservices:\n            self.microservices.append(link[0])\n        if link[1] not in self.microservices:\n            self.microservices.append(link[1])\n    self._users = list()\n    self._internal = internal\n    self._after: Union[vSFC, List[vSFC]] = after  # type: ignore\n    simulation.SFCS.append(self)\n</code></pre>"},{"location":"api/virtual_entity/sfc_networkservice/v_sfc/#PyCloudSim.entity.v_sfc.vSFC.evaluate","title":"<code>evaluate()</code>","text":"<p>Evaluate the vSFC and all its microservices. Change the status of the vSFC to READY if all its microservices are ready.</p> Source code in <code>PyCloudSim\\entity\\v_sfc.py</code> <pre><code>def evaluate(self):\n    \"\"\"Evaluate the vSFC and all its microservices. Change the status of the vSFC to READY if all its microservices are ready.\"\"\"\n    if all(ms.ready for ms in self.microservices):\n        self.status.append(READY)\n        LOGGER.info(f\"{simulation.now:0.2f}:\\tvSFC {self.label} is ready.\")\n    else:\n        if self.ready:\n            self.status.remove(READY)\n</code></pre>"},{"location":"api/virtual_entity/sfc_networkservice/v_sfc/#PyCloudSim.entity.v_sfc.vSFC.termination","title":"<code>termination()</code>","text":"<p>Terminate the vSFC and all its microservices.</p> Source code in <code>PyCloudSim\\entity\\v_sfc.py</code> <pre><code>def termination(self):\n    \"\"\"Terminate the vSFC and all its microservices.\"\"\"\n    super().termination()\n    for ms in self.microservices:\n        if not ms.terminated:\n            ms.terminate()\n</code></pre>"}]}